{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Configurar el entorno de desarrollo Flutter",
        "description": "Inicializar el proyecto Flutter con todas las dependencias necesarias para la aplicación de ayuno intermitente Zendfast",
        "details": "Configurar pubspec.yaml con dependencias clave: riverpod ^2.5.0, isar ^3.1.0, supabase_flutter ^2.5.0, go_router ^10.0.0, lottie ^3.1.0, flutter_background_service ^5.0.0, onesignal_flutter ^5.0.0, shared_preferences ^2.2.0, connectivity_plus ^5.0.0. Configurar flavors para development y production. Establecer estructura de carpetas siguiendo la arquitectura modular propuesta.",
        "testStrategy": "Verificar que 'flutter pub get' se ejecute sin errores y que las importaciones funcionen correctamente. Confirmar que el proyecto compile en modo debug y release.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar pubspec.yaml con dependencias necesarias",
            "description": "Añadir todas las dependencias requeridas al archivo pubspec.yaml incluyendo riverpod, isar, supabase_flutter, go_router, lottie, flutter_background_service, onesignal_flutter, shared_preferences y connectivity_plus con sus versiones específicas",
            "dependencies": [],
            "details": "Editar pubspec.yaml para incluir: riverpod ^2.5.0, isar ^3.1.0, supabase_flutter ^2.5.0, go_router ^10.0.0, lottie ^3.1.0, flutter_background_service ^5.0.0, onesignal_flutter ^5.0.0, shared_preferences ^2.2.0, connectivity_plus ^5.0.0. Verificar compatibilidad de versiones y ejecutar flutter pub get para validar instalación",
            "status": "pending",
            "testStrategy": "Ejecutar 'flutter pub get' sin errores y verificar que todas las dependencias se instalen correctamente"
          },
          {
            "id": 2,
            "title": "Configurar flavors para development y production",
            "description": "Establecer configuración de flavors de Flutter para separar entornos de desarrollo y producción con diferentes configuraciones y keys",
            "dependencies": [
              1
            ],
            "details": "Configurar android/app/build.gradle con flavors 'development' y 'production'. Crear archivos de configuración separados para cada flavor con diferentes app IDs, nombres y configuraciones de API. Configurar iOS schemes correspondientes en Xcode",
            "status": "pending",
            "testStrategy": "Verificar que ambos flavors compilen correctamente y generen APKs/IPAs con configuraciones distintas"
          },
          {
            "id": 3,
            "title": "Establecer estructura de carpetas modular",
            "description": "Crear la arquitectura de carpetas siguiendo el patrón modular propuesto para mantener el código organizado y escalable",
            "dependencies": [
              1
            ],
            "details": "Crear estructura: lib/features/ (auth, fasting, hydration, meditation, etc.), lib/shared/ (widgets, services, models), lib/core/ (constants, themes, utils). Establecer barrel exports y organizar imports relativos",
            "status": "pending",
            "testStrategy": "Verificar que la estructura de carpetas permita imports limpios y que no haya dependencias circulares"
          },
          {
            "id": 4,
            "title": "Configurar assets y recursos del proyecto",
            "description": "Organizar y configurar todos los assets necesarios incluyendo imágenes, animaciones Lottie, fuentes y archivos de configuración",
            "dependencies": [
              1
            ],
            "details": "Crear carpetas assets/images/, assets/animations/, assets/fonts/. Configurar pubspec.yaml para incluir todos los assets. Añadir animaciones Lottie para onboarding y meditación. Configurar fuentes personalizadas si es necesario",
            "status": "pending",
            "testStrategy": "Verificar que todos los assets se carguen correctamente en la aplicación y no haya errores de recursos faltantes"
          },
          {
            "id": 5,
            "title": "Configurar permisos específicos por plataforma",
            "description": "Establecer los permisos necesarios para iOS y Android según las funcionalidades requeridas por las dependencias integradas",
            "dependencies": [
              1
            ],
            "details": "Configurar AndroidManifest.xml con permisos para notificaciones, internet, background services. Configurar Info.plist en iOS con permisos de notificaciones y background modes. Añadir permisos específicos para OneSignal y background services",
            "status": "pending",
            "testStrategy": "Verificar que la aplicación solicite permisos correctamente en tiempo de ejecución y que las funcionalidades que requieren permisos funcionen adecuadamente"
          },
          {
            "id": 6,
            "title": "Validar setup completo del entorno",
            "description": "Realizar validación integral del entorno de desarrollo configurado ejecutando pruebas de compilación y verificando que todas las integraciones funcionen correctamente",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Ejecutar flutter doctor para verificar setup. Compilar proyecto en modo debug y release para ambos flavors. Verificar que todas las importaciones funcionen. Crear app básica con navegación mínima para probar integración de dependencias principales",
            "status": "pending",
            "testStrategy": "Ejecutar 'flutter doctor' sin warnings críticos, compilar exitosamente en debug y release, y verificar que la app básica funcione en emulador/dispositivo"
          }
        ]
      },
      {
        "id": 2,
        "title": "Crear el sistema de diseño (design system) base",
        "description": "Implementar los colores, tipografías y temas base de Zendfast con soporte para modo claro y oscuro",
        "details": "Crear ZendfastColors con paleta teal (#069494), verde (#7fb069), naranja (#ffb366). Configurar ZendfastTheme con ThemeData para light/dark mode. Implementar tipografías Inter, Source Sans Pro, Nunito Sans. Establecer sistema de espaciado y elevación. Crear componentes base reutilizables (botones, cards, inputs).",
        "testStrategy": "Verificar que los temas se apliquen correctamente. Probar contraste WCAG 2.1 AA (4.5:1). Snapshot tests para componentes UI básicos.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir paleta de colores y tokens de diseño",
            "description": "Crear la clase ZendfastColors con los colores principales: teal (#069494), verde (#7fb069), naranja (#ffb366) y sus variaciones para modo claro y oscuro",
            "dependencies": [],
            "details": "Implementar ZendfastColors con colores primarios, secundarios, de superficie, de fondo y de error. Definir tokens semánticos para cada modo (light/dark). Incluir variaciones de opacidad y estados (hover, pressed, disabled). Establecer nomenclatura consistente para todos los tokens de color.",
            "status": "pending",
            "testStrategy": "Verificar que todos los colores cumplan con contraste WCAG 2.1 AA. Probar visualización en ambos modos de tema."
          },
          {
            "id": 2,
            "title": "Configurar tipografías del sistema",
            "description": "Implementar las tipografías Inter, Source Sans Pro y Nunito Sans con sus respectivos pesos y estilos",
            "dependencies": [
              1
            ],
            "details": "Configurar GoogleFonts para cargar Inter, Source Sans Pro y Nunito Sans. Definir TextTheme personalizado con estilos para headings, body, captions y labels. Establecer jerarquía tipográfica consistente con tamaños, pesos y espaciado de línea apropiados para cada contexto de uso.",
            "status": "pending",
            "testStrategy": "Verificar carga correcta de fuentes. Probar legibilidad en diferentes tamaños de pantalla y densidades."
          },
          {
            "id": 3,
            "title": "Implementar ThemeData para modo claro y oscuro",
            "description": "Crear ZendfastTheme con configuración completa de ThemeData para ambos modos de visualización",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar lightTheme y darkTheme usando los colores y tipografías definidos. Implementar ColorScheme personalizado, AppBarTheme, ElevatedButtonTheme, InputDecorationTheme y otros componentes temáticos. Asegurar consistencia visual entre ambos modos y transiciones suaves.",
            "status": "pending",
            "testStrategy": "Probar cambio entre modos claro y oscuro. Verificar que todos los componentes respeten el tema activo."
          },
          {
            "id": 4,
            "title": "Crear sistema de espaciado y elevación",
            "description": "Establecer sistema de espaciado consistente y niveles de elevación para componentes",
            "dependencies": [
              1
            ],
            "details": "Definir escala de espaciado base (4dp) con valores 4, 8, 12, 16, 20, 24, 32, 40, 48, 64. Crear constantes para margins, paddings y gaps. Establecer niveles de elevación (0-24) para cards, modals, app bars. Implementar shadows personalizados para cada nivel.",
            "status": "pending",
            "testStrategy": "Verificar consistencia visual del espaciado. Probar elevaciones en ambos temas."
          },
          {
            "id": 5,
            "title": "Desarrollar componentes base reutilizables",
            "description": "Crear biblioteca de componentes UI fundamentales: botones, cards, inputs y otros elementos básicos",
            "dependencies": [
              3,
              4
            ],
            "details": "Implementar ZendfastButton con variantes (primary, secondary, text). Crear ZendfastCard con elevación configurable. Desarrollar ZendfastTextField con validación integrada. Añadir ZendfastChip, ZendfastBadge y otros componentes esenciales. Todos deben respetar el tema activo y ser completamente personalizables.",
            "status": "pending",
            "testStrategy": "Snapshot tests para cada componente. Verificar comportamiento en ambos temas y diferentes estados."
          },
          {
            "id": 6,
            "title": "Validar contraste y accesibilidad WCAG 2.1 AA",
            "description": "Realizar auditoría completa de contraste de colores y cumplimiento de estándares de accesibilidad",
            "dependencies": [
              1,
              3
            ],
            "details": "Usar herramientas de validación de contraste para verificar ratio mínimo 4.5:1 en texto normal y 3:1 en texto grande. Probar legibilidad con simuladores de daltonismo. Verificar que focus indicators sean visibles. Asegurar que los componentes sean navegables por teclado y screen readers.",
            "status": "pending",
            "testStrategy": "Usar accessibility scanner automático. Pruebas manuales con TalkBack/VoiceOver. Validar con usuarios con discapacidades visuales."
          },
          {
            "id": 7,
            "title": "Documentar el design system",
            "description": "Crear documentación completa del sistema de diseño para desarrolladores y diseñadores",
            "dependencies": [
              5,
              6
            ],
            "details": "Crear guía de uso con ejemplos de código para cada componente. Documentar paleta de colores, tipografías y espaciado. Incluir capturas de pantalla de componentes en ambos temas. Establecer guidelines de uso y mejores prácticas. Crear Storybook o similar para exploración interactiva de componentes.",
            "status": "pending",
            "testStrategy": "Revisar documentación con equipo de desarrollo. Verificar que todos los ejemplos de código funcionen correctamente."
          }
        ]
      },
      {
        "id": 3,
        "title": "Configurar base de datos local Isar",
        "description": "Implementar esquemas de base de datos local con Isar v3.1.0 para persistencia offline",
        "details": "Crear esquemas Isar: FastingSession, UserProfile, HydrationLog, ContentItem, NotificationPreferences. Configurar DatabaseService con inicialización de Isar, manejo de migraciones y colecciones. Implementar generación de código con build_runner. Establecer índices para consultas eficientes.",
        "testStrategy": "Unit tests para operaciones CRUD en cada modelo. Verificar que build_runner genere código sin errores. Probar migraciones de esquema.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelos de datos con anotaciones Isar",
            "description": "Implementar los modelos de datos FastingSession, UserProfile, HydrationLog, ContentItem y NotificationPreferences con las anotaciones Isar correspondientes",
            "dependencies": [],
            "details": "Crear archivos de modelo en lib/models/ con anotaciones @collection, @Id(), @Index() según sea necesario. Definir propiedades con tipos compatibles con Isar. Configurar relaciones entre modelos usando @Link() y @Backlink(). Documentar estructura de cada modelo.",
            "status": "pending",
            "testStrategy": "Unit tests para validar que los modelos se instancien correctamente y cumplan con las restricciones de Isar"
          },
          {
            "id": 2,
            "title": "Configurar DatabaseService e inicialización",
            "description": "Implementar el servicio principal para manejo de la base de datos Isar con inicialización y configuración de colecciones",
            "dependencies": [
              1
            ],
            "details": "Crear DatabaseService como singleton con método de inicialización de Isar. Configurar directorio de base de datos. Implementar apertura y cierre de conexiones. Añadir manejo de errores y logging. Configurar todas las colecciones de modelos.",
            "status": "pending",
            "testStrategy": "Unit tests para inicialización exitosa de base de datos y manejo de errores en caso de fallo"
          },
          {
            "id": 3,
            "title": "Implementar generación de código con build_runner",
            "description": "Configurar build_runner para generar automáticamente el código Isar necesario",
            "dependencies": [
              1
            ],
            "details": "Añadir dependencias isar_generator y build_runner al pubspec.yaml. Crear build.yaml con configuración específica. Implementar scripts de generación de código. Configurar gitignore para archivos generados. Documentar proceso de generación.",
            "status": "pending",
            "testStrategy": "Verificar que build_runner genere código sin errores y que los archivos .g.dart se creen correctamente"
          },
          {
            "id": 4,
            "title": "Crear índices para optimización de consultas",
            "description": "Implementar índices estratégicos en los modelos para optimizar las consultas más frecuentes",
            "dependencies": [
              1,
              2
            ],
            "details": "Añadir anotaciones @Index() en campos de consulta frecuente como fechas, status, userId. Crear índices compuestos para consultas complejas. Documentar estrategia de indexación. Medir impacto en rendimiento de consultas.",
            "status": "pending",
            "testStrategy": "Performance tests para verificar mejora en tiempo de consultas con y sin índices"
          },
          {
            "id": 5,
            "title": "Implementar migraciones de esquema",
            "description": "Configurar sistema de migraciones para manejar cambios en el esquema de base de datos",
            "dependencies": [
              2
            ],
            "details": "Implementar MigrationService con control de versiones de esquema. Crear scripts de migración para cambios futuros. Establecer estrategia de backup antes de migraciones. Implementar rollback en caso de errores. Documentar proceso de migración.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar migraciones exitosas y rollback en caso de error"
          },
          {
            "id": 6,
            "title": "Configurar colecciones y relaciones",
            "description": "Establecer todas las colecciones Isar y configurar relaciones entre entidades",
            "dependencies": [
              2,
              3
            ],
            "details": "Configurar colecciones para cada modelo en DatabaseService. Implementar relaciones uno-a-muchos y muchos-a-muchos usando Links. Configurar lazy loading para relaciones. Implementar métodos de consulta con joins. Optimizar carga de datos relacionados.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar que las relaciones funcionen correctamente y la carga lazy sea eficiente"
          },
          {
            "id": 7,
            "title": "Testing de operaciones CRUD",
            "description": "Implementar tests completos para todas las operaciones Create, Read, Update, Delete en cada modelo",
            "dependencies": [
              4,
              6
            ],
            "details": "Crear tests unitarios para operaciones CRUD en cada modelo. Verificar constraints y validaciones. Probar operaciones en batch. Testear manejo de errores y excepciones. Configurar test database separada. Implementar setup y teardown de tests.",
            "status": "pending",
            "testStrategy": "Alcanzar 90% de cobertura en operaciones CRUD con tests automatizados que se ejecuten en CI/CD"
          },
          {
            "id": 8,
            "title": "Optimización de rendimiento de base de datos",
            "description": "Analizar y optimizar el rendimiento de las operaciones de base de datos más críticas",
            "dependencies": [
              7
            ],
            "details": "Implementar profiling de consultas frecuentes. Optimizar queries complejas con explain plans. Configurar connection pooling adecuado. Implementar caching strategies para datos frecuentemente accedidos. Monitorear uso de memoria y espacio en disco.",
            "status": "pending",
            "testStrategy": "Performance benchmarks que demuestren mejoras medibles en tiempo de respuesta y uso de recursos"
          }
        ]
      },
      {
        "id": 4,
        "title": "Configurar cliente Supabase y autenticación",
        "description": "Establecer conexión con Supabase para backend-as-a-service y autenticación de usuarios",
        "details": "Configurar SupabaseService con cliente inicializado. Implementar esquemas de base de datos PostgreSQL: user_profiles, fasting_sessions, hydration_logs, content_items con Row Level Security (RLS). Configurar Supabase Auth para email/password. Establecer políticas RLS para aislamiento de datos por usuario.",
        "testStrategy": "Integration tests para autenticación (registro, login, logout). Verificar que RLS funcione correctamente. Probar conexión a base de datos remota.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar cliente inicial de Supabase",
            "description": "Instalar SDK de Supabase y configurar cliente con credenciales de proyecto",
            "dependencies": [],
            "details": "Instalar paquete supabase_flutter, crear SupabaseService singleton, configurar URL del proyecto y anon key, inicializar cliente en main.dart",
            "status": "pending",
            "testStrategy": "Unit tests para verificar inicialización correcta del cliente y conectividad básica"
          },
          {
            "id": 2,
            "title": "Diseñar esquemas de base de datos PostgreSQL",
            "description": "Crear tablas user_profiles, fasting_sessions, hydration_logs y content_items",
            "dependencies": [
              1
            ],
            "details": "Definir estructura de tablas con tipos de datos apropiados, relaciones foreign key, índices necesarios y constraints de validación para cada tabla",
            "status": "pending",
            "testStrategy": "Verificar creación de tablas y constraints mediante queries directas en Supabase dashboard"
          },
          {
            "id": 3,
            "title": "Implementar Row Level Security (RLS)",
            "description": "Habilitar RLS en todas las tablas para aislamiento de datos por usuario",
            "dependencies": [
              2
            ],
            "details": "Activar RLS en cada tabla, crear políticas base que permitan acceso solo a datos del usuario autenticado usando auth.uid()",
            "status": "pending",
            "testStrategy": "Tests de seguridad verificando que usuarios no pueden acceder a datos de otros usuarios"
          },
          {
            "id": 4,
            "title": "Configurar Supabase Auth para email/password",
            "description": "Implementar sistema de autenticación con email y contraseña",
            "dependencies": [
              1
            ],
            "details": "Configurar métodos de registro, login y logout usando Supabase Auth, manejar estados de autenticación y persistencia de sesión",
            "status": "pending",
            "testStrategy": "Integration tests para flujos completos de registro, login y logout con validación de errores"
          },
          {
            "id": 5,
            "title": "Crear políticas de seguridad específicas por usuario",
            "description": "Implementar políticas RLS detalladas para cada tabla y operación CRUD",
            "dependencies": [
              3
            ],
            "details": "Crear políticas específicas para SELECT, INSERT, UPDATE, DELETE en cada tabla, asegurando acceso solo a datos propios del usuario",
            "status": "pending",
            "testStrategy": "Tests exhaustivos verificando permisos correctos para cada operación CRUD por tabla"
          },
          {
            "id": 6,
            "title": "Configurar sincronización bidireccional",
            "description": "Implementar sistema de sincronización en tiempo real entre app y Supabase",
            "dependencies": [
              4,
              5
            ],
            "details": "Configurar realtime subscriptions para cambios en datos, implementar manejo de conflictos y sincronización offline/online",
            "status": "pending",
            "testStrategy": "Tests de sincronización verificando actualizaciones en tiempo real y resolución de conflictos"
          },
          {
            "id": 7,
            "title": "Implementar manejo de tokens y sesiones",
            "description": "Gestionar tokens de autenticación, refresh automático y manejo de expiración",
            "dependencies": [
              4
            ],
            "details": "Implementar refresh automático de tokens, manejo de expiración de sesión, persistencia segura de tokens y logout automático",
            "status": "pending",
            "testStrategy": "Tests verificando refresh automático, manejo de tokens expirados y persistencia de sesión"
          },
          {
            "id": 8,
            "title": "Testing completo de autenticación",
            "description": "Crear suite completa de tests para todos los flujos de autenticación",
            "dependencies": [
              6,
              7
            ],
            "details": "Implementar integration tests para registro, login, logout, refresh de tokens, manejo de errores y edge cases de autenticación",
            "status": "pending",
            "testStrategy": "Suite completa de tests automatizados cubriendo todos los flujos de autenticación y casos edge"
          },
          {
            "id": 9,
            "title": "Configurar webhooks de Supabase",
            "description": "Implementar webhooks para eventos de autenticación y cambios de datos",
            "dependencies": [
              8
            ],
            "details": "Configurar webhooks para eventos de registro/login, cambios en user_profiles, y otros eventos críticos del sistema",
            "status": "pending",
            "testStrategy": "Tests verificando que webhooks se disparan correctamente y manejan eventos apropiadamente"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implementar servicio de background para timer",
        "description": "Crear servicio que mantenga el timer activo incluso cuando la app está cerrada",
        "details": "Implementar TimerBackgroundService usando flutter_background_service. Configurar persistencia del estado del timer en background. Manejar reinicio del dispositivo y kill de la app. Configurar notificación persistente durante ayuno activo. Implementar recuperación del estado al reabrir la app.",
        "testStrategy": "Probar que el timer continúe funcionando después de kill de app. Verificar precisión del timer ±5 segundos después de 16 horas. Probar recuperación después de reinicio del dispositivo.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar flutter_background_service",
            "description": "Instalar y configurar el paquete flutter_background_service para permitir ejecución en background",
            "dependencies": [],
            "details": "Agregar flutter_background_service a pubspec.yaml. Configurar permisos necesarios en AndroidManifest.xml y Info.plist. Crear configuración básica del servicio background con inicialización en main.dart. Configurar service worker para ambas plataformas.",
            "status": "pending",
            "testStrategy": "Verificar que el servicio inicie correctamente en ambas plataformas y se mantenga activo en background"
          },
          {
            "id": 2,
            "title": "Implementar persistencia de estado en background",
            "description": "Crear sistema de persistencia que guarde el estado del timer en el servicio background",
            "dependencies": [
              1
            ],
            "details": "Implementar SharedPreferences para guardar timestamp de inicio, duración configurada, estado actual del timer. Crear métodos para escribir/leer estado desde el servicio background. Usar JSON para serializar datos complejos del timer.",
            "status": "pending",
            "testStrategy": "Verificar que el estado persista correctamente cuando la app está en background y tras reinicio"
          },
          {
            "id": 3,
            "title": "Manejar reinicio de dispositivo y kill de app",
            "description": "Implementar recuperación automática del timer tras reinicio del dispositivo o cierre forzado",
            "dependencies": [
              2
            ],
            "details": "Configurar BOOT_COMPLETED receiver en Android. Implementar restart automático del servicio background. Crear lógica para detectar si el timer debe continuar corriendo. Manejar casos edge como apagado prolongado.",
            "status": "pending",
            "testStrategy": "Probar reinicio del dispositivo durante timer activo y verificar continuidad. Testear kill forzado de la app"
          },
          {
            "id": 4,
            "title": "Configurar notificación persistente",
            "description": "Crear notificación permanente que muestre el progreso del timer durante ayuno activo",
            "dependencies": [
              1
            ],
            "details": "Implementar notificación foreground usando flutter_local_notifications. Mostrar tiempo transcurrido y restante. Configurar acciones rápidas (pausar/detener) desde la notificación. Actualizar contenido cada minuto.",
            "status": "pending",
            "testStrategy": "Verificar que la notificación se mantenga visible y actualizada durante todo el ayuno"
          },
          {
            "id": 5,
            "title": "Implementar recuperación de estado al reabrir app",
            "description": "Crear mecanismo para sincronizar el estado de la UI con el servicio background al abrir la app",
            "dependencies": [
              2
            ],
            "details": "Implementar comunicación bidireccional entre UI y servicio background. Crear listeners para recibir updates del timer. Sincronizar estado inmediatamente al abrir la app. Manejar discrepancias entre UI y background service.",
            "status": "pending",
            "testStrategy": "Verificar sincronización correcta tras abrir la app después de períodos largos en background"
          },
          {
            "id": 6,
            "title": "Manejar precisión temporal",
            "description": "Garantizar precisión del timer usando timestamps absolutos en lugar de contadores incrementales",
            "dependencies": [
              2
            ],
            "details": "Usar DateTime.now() para cálculos de tiempo transcurrido. Implementar compensación por drift temporal. Crear validación de coherencia temporal tras suspensión del sistema. Manejar cambios de zona horaria.",
            "status": "pending",
            "testStrategy": "Verificar precisión ±5 segundos después de 16 horas de funcionamiento y tras suspensión del dispositivo"
          },
          {
            "id": 7,
            "title": "Configuración específica por plataforma iOS/Android",
            "description": "Implementar configuraciones y optimizaciones específicas para iOS y Android",
            "dependencies": [
              1
            ],
            "details": "Configurar background modes en iOS (background-processing). Implementar WorkManager en Android para tareas programadas. Manejar limitaciones de background en iOS 13+. Configurar permisos específicos por plataforma.",
            "status": "pending",
            "testStrategy": "Verificar funcionamiento correcto en ambas plataformas con sus respectivas limitaciones"
          },
          {
            "id": 8,
            "title": "Testing de continuidad tras kill",
            "description": "Crear suite de tests para verificar que el timer continúe funcionando tras cierre forzado",
            "dependencies": [
              3,
              5
            ],
            "details": "Implementar integration tests que simulen kill de app. Crear tests para verificar recuperación de estado. Probar escenarios de memoria baja. Validar comportamiento con múltiples kills consecutivos.",
            "status": "pending",
            "testStrategy": "Tests automatizados que verifiquen continuidad del timer en todos los escenarios de cierre de app"
          },
          {
            "id": 9,
            "title": "Validación de precisión temporal",
            "description": "Crear sistema de validación que garantice la precisión del timer a largo plazo",
            "dependencies": [
              6
            ],
            "details": "Implementar logging de drift temporal. Crear métricas de precisión durante funcionamiento prolongado. Implementar auto-corrección basada en timestamps del servidor. Detectar y reportar anomalías temporales.",
            "status": "pending",
            "testStrategy": "Probar precisión durante 24+ horas de funcionamiento continuo y validar contra timestamps de referencia"
          },
          {
            "id": 10,
            "title": "Optimización de batería",
            "description": "Optimizar el servicio background para minimizar el consumo de batería",
            "dependencies": [
              4,
              6
            ],
            "details": "Implementar estrategia de wake-up mínima. Usar AlarmManager en lugar de timers continuos en Android. Optimizar frecuencia de updates de notificación. Implementar doze mode compatibility. Configurar whitelist de optimización de batería.",
            "status": "pending",
            "testStrategy": "Medir consumo de batería durante 24 horas y verificar que esté dentro de límites aceptables (<2% por hora)"
          }
        ]
      },
      {
        "id": 6,
        "title": "Configurar OneSignal para notificaciones push",
        "description": "Integrar OneSignal para sistema de notificaciones push personalizadas",
        "details": "Configurar OneSignal SDK con app_id específico. Implementar NotificationService para manejo de tokens de dispositivo. Configurar permisos de notificación para iOS y Android. Establecer manejadores para click de notificación y deep linking. Preparar estructura para notificaciones de ayuno, hidratación y engagement.",
        "testStrategy": "Verificar que las notificaciones lleguen correctamente en iOS y Android. Probar deep linking desde notificaciones. Confirmar manejo de permisos.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar OneSignal SDK inicial",
            "description": "Instalar y configurar el SDK de OneSignal en el proyecto Flutter con las credenciales y configuración básica",
            "dependencies": [],
            "details": "Agregar dependencia onesignal_flutter al pubspec.yaml. Configurar app_id en main.dart. Inicializar OneSignal SDK con configuración básica para iOS y Android. Configurar archivos de configuración específicos de plataforma.",
            "status": "pending",
            "testStrategy": "Verificar que el SDK se inicialice correctamente sin errores en ambas plataformas"
          },
          {
            "id": 2,
            "title": "Implementar NotificationService para tokens",
            "description": "Crear servicio para manejo de tokens de dispositivo y registro de usuarios en OneSignal",
            "dependencies": [
              1
            ],
            "details": "Crear NotificationService class. Implementar métodos para obtener player_id y push token. Configurar manejo de cambios de estado de suscripción. Implementar persistencia local de tokens. Añadir sincronización con Supabase user_profiles.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar obtención y persistencia de tokens. Integration tests para registro en OneSignal"
          },
          {
            "id": 3,
            "title": "Configurar permisos iOS y Android",
            "description": "Establecer configuración de permisos de notificaciones push para ambas plataformas móviles",
            "dependencies": [
              1
            ],
            "details": "Configurar ios/Runner/Info.plist con permisos de notificaciones. Actualizar android/app/src/main/AndroidManifest.xml. Implementar solicitud de permisos en tiempo de ejecución. Configurar iconos y sonidos personalizados para notificaciones.",
            "status": "pending",
            "testStrategy": "Verificar que los permisos se soliciten correctamente en primera ejecución en iOS y Android"
          },
          {
            "id": 4,
            "title": "Implementar manejadores de click de notificación",
            "description": "Crear sistema para manejar acciones cuando el usuario toca las notificaciones recibidas",
            "dependencies": [
              2
            ],
            "details": "Implementar onNotificationOpened handler. Crear NotificationAction enum para diferentes tipos de acciones. Configurar manejo de notificaciones en foreground, background y terminated state. Implementar logging de eventos de interacción.",
            "status": "pending",
            "testStrategy": "Probar que las notificaciones abran la pantalla correcta en todos los estados de la app"
          },
          {
            "id": 5,
            "title": "Configurar deep linking desde notificaciones",
            "description": "Establecer sistema de deep linking para navegación directa desde notificaciones push",
            "dependencies": [
              4
            ],
            "details": "Configurar custom URL schemes para iOS y Android. Implementar parsing de notification data para extraer rutas. Integrar con go_router para navegación automática. Configurar fallback routes para URLs inválidas. Añadir validación de autenticación antes de navegar.",
            "status": "pending",
            "testStrategy": "Verificar navegación correcta desde notificaciones a pantallas específicas con deep links"
          },
          {
            "id": 6,
            "title": "Testing de delivery en ambas plataformas",
            "description": "Probar el sistema completo de notificaciones en dispositivos iOS y Android reales",
            "dependencies": [
              5
            ],
            "details": "Configurar test devices en OneSignal dashboard. Crear tests automatizados para envío y recepción. Probar notificaciones en diferentes estados de app. Verificar delivery rates y tiempos de entrega. Documentar casos edge conocidos.",
            "status": "pending",
            "testStrategy": "Integration tests end-to-end para verificar delivery exitoso en iOS y Android físicos"
          },
          {
            "id": 7,
            "title": "Preparar estructura para tipos de notificaciones",
            "description": "Crear sistema organizado para diferentes categorías de notificaciones de la app",
            "dependencies": [
              6
            ],
            "details": "Definir NotificationType enum (fasting, hydration, engagement, premium). Crear templates para cada tipo con iconos y textos específicos. Implementar scheduling local para recordatorios. Configurar segmentación de usuarios para targeting. Preparar analytics tracking por tipo.",
            "status": "pending",
            "testStrategy": "Verificar que cada tipo de notificación se envíe con el formato y comportamiento correcto"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implementar sistema de gestión de estado con Riverpod",
        "description": "Establecer arquitectura de estado reactivo para toda la aplicación",
        "details": "Configurar providers principales: authStateProvider, fastingTimerProvider, hydrationProvider, metricsProvider. Implementar StateNotifiers para lógica de negocio compleja. Establecer patrones de dependency injection. Configurar persistencia de estado crítico. Implementar error handling a nivel de provider.",
        "testStrategy": "Unit tests para cada provider. Verificar reactividad del estado. Probar manejo de errores y loading states.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuración inicial de Riverpod en el proyecto",
            "description": "Instalar dependencias de Riverpod y configurar la estructura base para la gestión de estado",
            "dependencies": [],
            "details": "Agregar flutter_riverpod y riverpod_annotation al pubspec.yaml. Configurar ProviderScope en main.dart. Crear estructura de carpetas para providers (lib/providers/). Configurar build_runner para code generation. Establecer imports base y configuración inicial.",
            "status": "pending",
            "testStrategy": "Verificar que la app compile correctamente con Riverpod. Probar que ProviderScope esté configurado."
          },
          {
            "id": 2,
            "title": "Implementar AuthStateProvider principal",
            "description": "Crear provider de autenticación con estado reactivo y manejo de sesiones",
            "dependencies": [
              1
            ],
            "details": "Implementar AuthStateProvider usando StateNotifier. Definir AuthState con estados: loading, authenticated, unauthenticated, error. Configurar persistencia de tokens. Implementar métodos para login, logout, checkAuthStatus. Integrar con AuthService existente.",
            "status": "pending",
            "testStrategy": "Unit tests para cambios de estado de autenticación. Verificar persistencia de sesión entre reinicios."
          },
          {
            "id": 3,
            "title": "Implementar FastingTimerProvider",
            "description": "Crear provider reactivo para el estado del timer de ayuno con precisión temporal",
            "dependencies": [
              1
            ],
            "details": "Implementar FastingTimerProvider usando StateNotifier. Definir FastingState con currentPhase, startTime, duration, remainingTime. Configurar Timer periódico para updates cada segundo. Implementar métodos startFast, pauseFast, stopFast. Persistir estado en SharedPreferences.",
            "status": "pending",
            "testStrategy": "Verificar precisión temporal del timer. Probar persistencia del estado tras restart. Testing de transiciones entre fases."
          },
          {
            "id": 4,
            "title": "Implementar HydrationProvider y MetricsProvider",
            "description": "Crear providers para hidratación y métricas de usuario con estado reactivo",
            "dependencies": [
              1
            ],
            "details": "Implementar HydrationProvider con objetivo diario, consumo actual, recordatorios. Crear MetricsProvider para estadísticas de ayuno, progreso semanal/mensual. Configurar cálculos automáticos y updates reactivos. Implementar persistencia en Isar database.",
            "status": "pending",
            "testStrategy": "Verificar cálculos correctos de métricas. Probar reactividad de cambios en hidratación. Testing de persistencia de datos."
          },
          {
            "id": 5,
            "title": "Crear StateNotifiers para lógica de negocio compleja",
            "description": "Implementar StateNotifiers especializados para manejar lógica de negocio avanzada",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Crear FastingLogicNotifier para cálculos complejos de ayuno. Implementar HydrationLogicNotifier para algoritmos de recordatorios inteligentes. Crear MetricsCalculatorNotifier para estadísticas avanzadas. Configurar comunicación entre notifiers usando ref.watch/listen.",
            "status": "pending",
            "testStrategy": "Unit tests para cada StateNotifier. Verificar comunicación entre notifiers. Probar lógica de negocio compleja."
          },
          {
            "id": 6,
            "title": "Establecer patrones de dependency injection",
            "description": "Configurar inyección de dependencias usando Riverpod para servicios y repositorios",
            "dependencies": [
              1
            ],
            "details": "Crear providers para servicios: authServiceProvider, timerServiceProvider, notificationServiceProvider. Implementar repository providers para acceso a datos. Configurar provider overrides para testing. Establecer patrones de familia de providers para parámetros dinámicos.",
            "status": "pending",
            "testStrategy": "Verificar inyección correcta de dependencias. Probar provider overrides en tests. Testing de provider families."
          },
          {
            "id": 7,
            "title": "Configurar persistencia de estado crítico",
            "description": "Implementar persistencia automática para estados críticos de la aplicación",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Configurar auto-persistencia para AuthState, FastingState, HydrationState. Implementar StateNotifierProvider con persistencia usando shared_preferences e Isar. Crear mecanismo de restauración de estado al inicio. Manejar migration de versiones de estado.",
            "status": "pending",
            "testStrategy": "Verificar persistencia automática de estados. Probar restauración correcta al reiniciar app. Testing de migrations de estado."
          },
          {
            "id": 8,
            "title": "Implementar manejo de errores y optimización de performance",
            "description": "Configurar error handling a nivel provider y optimizar performance de reactividad",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Implementar AsyncValue para manejo de estados loading/error en providers. Configurar error recovery strategies. Implementar select() para optimizar rebuilds. Configurar autoDispose para providers temporales. Implementar logging de errores y performance monitoring.",
            "status": "pending",
            "testStrategy": "Testing de manejo de errores en providers. Verificar optimización de rebuilds. Probar autoDispose de providers no utilizados."
          }
        ]
      },
      {
        "id": 8,
        "title": "Crear modelos de datos para FastingSession",
        "description": "Implementar modelo de datos para sesiones de ayuno con validación y sincronización",
        "details": "Crear clase FastingSession con campos: id, userId, startTime, endTime, durationMinutes, completed, interrupted, planType. Implementar serialización JSON y mapeo a Isar. Añadir validaciones de datos y computed properties. Configurar relaciones con UserProfile.",
        "testStrategy": "Unit tests para serialización/deserialización. Verificar validaciones de datos. Probar relaciones entre modelos.",
        "priority": "high",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir clase FastingSession con campos requeridos",
            "description": "Crear la estructura básica de la clase FastingSession con todos los campos necesarios para representar una sesión de ayuno",
            "dependencies": [],
            "details": "Crear clase FastingSession con campos: String id, String userId, DateTime startTime, DateTime? endTime, int durationMinutes, bool completed, bool interrupted, String planType. Configurar imports necesarios y estructura básica del archivo en lib/models/fasting_session.dart",
            "status": "pending",
            "testStrategy": "Unit tests para verificar que la clase se instancia correctamente con todos los campos requeridos"
          },
          {
            "id": 2,
            "title": "Implementar serialización JSON",
            "description": "Configurar serialización y deserialización JSON usando json_annotation para la clase FastingSession",
            "dependencies": [
              1
            ],
            "details": "Añadir anotaciones @JsonSerializable() y @JsonKey() según sea necesario. Implementar métodos fromJson() y toJson(). Configurar json_serializable en pubspec.yaml y ejecutar build_runner para generar código. Manejar conversión de DateTime correctamente.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar serialización/deserialización JSON bidireccional con diferentes escenarios de datos"
          },
          {
            "id": 3,
            "title": "Configurar mapeo a Isar para persistencia local",
            "description": "Implementar anotaciones y configuración necesaria para persistir FastingSession en base de datos Isar",
            "dependencies": [
              1
            ],
            "details": "Añadir anotaciones @collection, @Id(), @Index() según sea necesario. Configurar tipos de datos compatibles con Isar. Implementar conversores para DateTime si es necesario. Asegurar que los campos estén correctamente mapeados para consultas eficientes.",
            "status": "pending",
            "testStrategy": "Tests de integración para verificar operaciones CRUD en Isar: crear, leer, actualizar y eliminar sesiones"
          },
          {
            "id": 4,
            "title": "Implementar validaciones de datos",
            "description": "Crear sistema de validación para asegurar integridad de datos en FastingSession",
            "dependencies": [
              1
            ],
            "details": "Implementar validaciones: startTime no puede ser futuro, endTime debe ser posterior a startTime, durationMinutes debe ser positivo, userId no puede estar vacío, planType debe ser válido. Crear métodos validate() y isValid getter. Lanzar excepciones descriptivas para datos inválidos.",
            "status": "pending",
            "testStrategy": "Unit tests exhaustivos para cada regla de validación, incluyendo casos válidos e inválidos"
          },
          {
            "id": 5,
            "title": "Crear computed properties",
            "description": "Implementar propiedades calculadas para funcionalidad adicional de FastingSession",
            "dependencies": [
              4
            ],
            "details": "Implementar getters: isActive (sesión en curso), remainingTime (tiempo restante), progressPercentage (porcentaje completado), actualDuration (duración real si completada), isOvertime (si excedió tiempo planeado). Optimizar cálculos y manejar casos edge.",
            "status": "pending",
            "testStrategy": "Unit tests para todas las computed properties con diferentes estados de sesión y escenarios temporales"
          },
          {
            "id": 6,
            "title": "Configurar relaciones con UserProfile",
            "description": "Establecer relaciones de base de datos entre FastingSession y UserProfile para integridad referencial",
            "dependencies": [
              3
            ],
            "details": "Configurar relación uno-a-muchos UserProfile -> FastingSession usando Isar links. Implementar métodos para obtener sesiones por usuario. Configurar índices para consultas eficientes. Asegurar consistencia al eliminar usuarios. Implementar cascade operations si es necesario.",
            "status": "pending",
            "testStrategy": "Tests de integración para verificar relaciones: crear sesiones vinculadas a usuario, consultar sesiones por usuario, verificar integridad referencial"
          }
        ]
      },
      {
        "id": 9,
        "title": "Implementar servicio de autenticación",
        "description": "Crear AuthService para manejo completo del ciclo de autenticación de usuarios",
        "details": "Implementar AuthService con métodos: login, register, logout, getCurrentUser, resetPassword. Manejar tokens de sesión y persistencia segura. Implementar auto-login y refresh de tokens. Configurar manejo de errores de autenticación. Integrar con Riverpod para estado reactivo.",
        "testStrategy": "Integration tests para flujos de auth completos. Verificar persistencia de sesión. Probar manejo de errores de red y credenciales inválidas.",
        "priority": "high",
        "dependencies": [
          4,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar métodos básicos de AuthService",
            "description": "Crear la estructura base del AuthService con métodos fundamentales de autenticación",
            "dependencies": [],
            "details": "Implementar AuthService como clase singleton con métodos básicos: login(email, password), register(email, password, name), y logout(). Definir interfaces para request/response. Configurar validaciones básicas de entrada. Establecer estructura de manejo de errores personalizada.",
            "status": "pending",
            "testStrategy": "Unit tests para validación de parámetros y estructura básica de métodos"
          },
          {
            "id": 2,
            "title": "Implementar manejo de tokens y persistencia segura",
            "description": "Configurar almacenamiento seguro de tokens de autenticación y sesión",
            "dependencies": [
              1
            ],
            "details": "Implementar TokenManager para manejo de access_token y refresh_token. Usar flutter_secure_storage para persistencia segura. Implementar métodos: saveTokens(), getTokens(), clearTokens(). Configurar encriptación de tokens en almacenamiento local.",
            "status": "pending",
            "testStrategy": "Unit tests para persistencia de tokens y verificar encriptación correcta"
          },
          {
            "id": 3,
            "title": "Implementar auto-login y refresh de tokens",
            "description": "Crear funcionalidad automática de login y renovación de tokens expirados",
            "dependencies": [
              2
            ],
            "details": "Implementar autoLogin() que verifique tokens válidos al iniciar app. Crear refreshToken() para renovar access_token usando refresh_token. Configurar interceptor HTTP para auto-refresh en requests fallidos por token expirado. Manejar casos de refresh_token expirado.",
            "status": "pending",
            "testStrategy": "Integration tests para auto-login y verificar renovación automática de tokens"
          },
          {
            "id": 4,
            "title": "Configurar manejo de errores específicos de autenticación",
            "description": "Implementar sistema robusto de manejo de errores para flujos de autenticación",
            "dependencies": [
              1
            ],
            "details": "Crear AuthException personalizada con tipos específicos: InvalidCredentials, NetworkError, TokenExpired, UserNotFound. Implementar AuthErrorHandler para mapear errores HTTP a excepciones específicas. Configurar logging detallado de errores. Definir mensajes de error user-friendly.",
            "status": "pending",
            "testStrategy": "Unit tests para mapeo correcto de errores y manejo de casos edge"
          },
          {
            "id": 5,
            "title": "Integrar AuthService con Riverpod para estado reactivo",
            "description": "Conectar AuthService con providers de Riverpod para manejo de estado global",
            "dependencies": [
              3,
              4
            ],
            "details": "Crear AuthNotifier extends StateNotifier<AuthState>. Implementar AuthState con estados: authenticated, unauthenticated, loading, error. Crear authProvider y currentUserProvider. Configurar listeners automáticos para cambios de estado de autenticación.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar reactividad del estado y actualizaciones de UI"
          },
          {
            "id": 6,
            "title": "Implementar método getCurrentUser",
            "description": "Crear funcionalidad para obtener información del usuario autenticado actual",
            "dependencies": [
              2
            ],
            "details": "Implementar getCurrentUser() que retorne User? desde token almacenado o API. Cachear información de usuario para acceso rápido. Configurar sincronización periódica de datos de usuario. Manejar casos de usuario no encontrado o tokens inválidos.",
            "status": "pending",
            "testStrategy": "Unit tests para obtención de usuario y verificar cache local"
          },
          {
            "id": 7,
            "title": "Implementar funcionalidad resetPassword",
            "description": "Crear sistema completo de recuperación de contraseña via email",
            "dependencies": [
              4
            ],
            "details": "Implementar resetPassword(email) que envíe email de recuperación. Crear confirmResetPassword(token, newPassword) para completar reset. Configurar validaciones de contraseña segura. Implementar rate limiting para prevenir abuso. Manejar tokens de reset expirados.",
            "status": "pending",
            "testStrategy": "Integration tests para flujo completo de reset de contraseña"
          },
          {
            "id": 8,
            "title": "Testing integral de flujos completos de autenticación",
            "description": "Crear suite completa de tests para validar todos los flujos de autenticación",
            "dependencies": [
              5,
              6,
              7
            ],
            "details": "Implementar integration tests para: registro completo, login/logout, auto-login, refresh de tokens, reset de contraseña. Crear mocks para API responses. Probar manejo de errores de red y credenciales inválidas. Verificar persistencia de sesión tras restart de app.",
            "status": "pending",
            "testStrategy": "Suite completa de integration tests cubriendo todos los flujos de autenticación y casos edge"
          }
        ]
      },
      {
        "id": 10,
        "title": "Diseñar e implementar pantallas de onboarding",
        "description": "Crear flujo de bienvenida de 6 pasos para nuevos usuarios",
        "details": "Implementar OnboardingCoordinator con 6 pantallas: splash → intro → registro → cuestionario → paywall → pregunta detox. Crear SplashScreen con logo animado. Diseñar IntroScreen con beneficios del ayuno. Implementar cuestionario para peso, altura, experiencia. Crear flujo de navegación fluido con PageController.",
        "testStrategy": "E2E test para flujo completo de onboarding. Verificar navegación entre pantallas. Probar persistencia de respuestas del cuestionario.",
        "priority": "high",
        "dependencies": [
          2,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar SplashScreen con animación",
            "description": "Crear pantalla splash inicial con logo animado y transición suave",
            "dependencies": [],
            "details": "Implementar SplashScreen widget con AnimationController para logo. Configurar fade-in del logo con duración de 2 segundos. Implementar auto-navegación a IntroScreen después de 3 segundos. Optimizar assets para diferentes densidades de pantalla.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar animación del logo y timing de transición"
          },
          {
            "id": 2,
            "title": "Crear IntroScreen con beneficios del ayuno",
            "description": "Diseñar pantalla de introducción mostrando los beneficios principales del ayuno intermitente",
            "dependencies": [
              1
            ],
            "details": "Crear IntroScreen con carousel de beneficios: pérdida de peso, claridad mental, longevidad. Implementar diseño responsive con imágenes ilustrativas. Configurar botones de navegación 'Omitir' y 'Siguiente'. Usar PageView para múltiples slides de beneficios.",
            "status": "pending",
            "testStrategy": "Widget tests para navegación del carousel y responsive design"
          },
          {
            "id": 3,
            "title": "Implementar pantallas de registro de usuario",
            "description": "Crear formularios de registro con validación de datos y términos de servicio",
            "dependencies": [
              2
            ],
            "details": "Implementar RegistrationScreen con campos: email, contraseña, confirmación. Configurar validadores para formato de email y fuerza de contraseña. Implementar checkbox para términos y condiciones. Integrar con AuthService para crear cuenta. Manejar estados de loading y errores.",
            "status": "pending",
            "testStrategy": "Unit tests para validadores de formulario y integration tests para registro completo"
          },
          {
            "id": 4,
            "title": "Crear cuestionario interactivo de perfil",
            "description": "Implementar cuestionario para recopilar datos de perfil del usuario: peso, altura, experiencia",
            "dependencies": [
              3
            ],
            "details": "Crear QuestionnaireScreen con preguntas progresivas: peso actual, altura, nivel de experiencia con ayuno, objetivos. Implementar widgets personalizados para entrada de datos numéricos y selección múltiple. Configurar validación de rangos realistas. Implementar indicador de progreso.",
            "status": "pending",
            "testStrategy": "Widget tests para componentes de entrada y validación de datos de perfil"
          },
          {
            "id": 5,
            "title": "Implementar navegación fluida con PageController",
            "description": "Configurar sistema de navegación entre pantallas del onboarding con animaciones suaves",
            "dependencies": [
              4
            ],
            "details": "Implementar OnboardingCoordinator con PageController para navegación fluida. Configurar transiciones animadas entre pantallas con curve personalizada. Implementar botones 'Anterior' y 'Siguiente' con estados habilitados/deshabilitados. Manejar navegación por gestos de swipe.",
            "status": "pending",
            "testStrategy": "Integration tests para flujo de navegación completo y animaciones"
          },
          {
            "id": 6,
            "title": "Integrar paywall en el flujo de onboarding",
            "description": "Implementar pantalla de suscripción premium integrada en el flujo de bienvenida",
            "dependencies": [
              5
            ],
            "details": "Crear PaywallScreen con planes de suscripción: mensual, anual. Implementar diseño atractivo con características premium destacadas. Configurar integración con sistema de pagos in-app. Implementar opción 'Continuar gratis' con funcionalidad limitada. Manejar estados de compra exitosa/fallida.",
            "status": "pending",
            "testStrategy": "Integration tests para flujo de suscripción y manejo de estados de pago"
          },
          {
            "id": 7,
            "title": "Configurar persistencia de respuestas del cuestionario",
            "description": "Implementar almacenamiento local y remoto de las respuestas del cuestionario de onboarding",
            "dependencies": [
              4
            ],
            "details": "Implementar UserProfileService para persistir datos del cuestionario en Isar local. Configurar sincronización automática con Supabase backend. Implementar modelo de datos UserProfile con validación. Manejar casos de offline y retry automático. Encriptar datos sensibles antes del almacenamiento.",
            "status": "pending",
            "testStrategy": "Integration tests para persistencia local y sincronización con backend"
          },
          {
            "id": 8,
            "title": "Testing end-to-end del flujo completo de onboarding",
            "description": "Crear suite de tests automatizados para verificar el flujo completo de onboarding",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Implementar integration tests que cubran el flujo completo: splash → intro → registro → cuestionario → paywall → finalización. Verificar persistencia de datos entre sesiones. Probar manejo de errores de red y estados offline. Configurar tests en múltiples dispositivos y orientaciones.",
            "status": "pending",
            "testStrategy": "E2E tests automatizados usando flutter_driver para flujo completo de onboarding"
          }
        ]
      },
      {
        "id": 11,
        "title": "Implementar pantalla de detox de 48 horas",
        "description": "Crear protocolo de preparación carnívora opcional para principiantes",
        "details": "Diseñar DetoxScreen con timer de 48 horas. Mostrar lista de alimentos permitidos (carne, huevos, pescado, caldo de hueso). Implementar checklist diario (mañana/noche). Crear progress ring visual para las 48 horas. Permitir saltar con advertencia. Guardar estado de completion en perfil de usuario.",
        "testStrategy": "Verificar precisión del timer de 48h. Probar persistencia del estado de detox. Confirmar flujo de skip con advertencia.",
        "priority": "medium",
        "dependencies": [
          10,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar timer de 48 horas con precisión",
            "description": "Crear lógica del timer principal para el detox de 48 horas con cálculos precisos de tiempo",
            "dependencies": [],
            "details": "Implementar DetoxTimer usando DateTime para cálculos precisos. Crear métodos startDetox(), pauseDetox(), y getElapsedTime(). Configurar conteo regresivo desde 48 horas con updates cada segundo. Manejar persistencia del estado del timer entre cierres de app.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar precisión temporal. Probar persistencia tras cierre y reapertura de app. Verificar cálculos correctos de tiempo restante."
          },
          {
            "id": 2,
            "title": "Crear interfaz de lista de alimentos permitidos",
            "description": "Diseñar y desarrollar la lista visual de alimentos carnívoros permitidos durante el detox",
            "dependencies": [],
            "details": "Crear AllowedFoodsList widget mostrando carne, huevos, pescado, caldo de hueso con íconos. Implementar diseño de cards con descripción breve. Permitir expandir detalles de cada categoría. Usar UI responsiva adaptada a diferentes tamaños de pantalla.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar renderizado correcto. Probar responsive design en diferentes tamaños. Verificar interacciones de expansión de detalles."
          },
          {
            "id": 3,
            "title": "Implementar checklist diario interactivo",
            "description": "Crear sistema de checklist con opciones mañana/noche para seguimiento diario del detox",
            "dependencies": [
              1
            ],
            "details": "Implementar DailyChecklist con checkboxes para rutinas mañana/noche. Configurar almacenamiento local del progreso diario. Resetear checklist cada 24 horas automáticamente. Mostrar progreso visual del día actual con animaciones de check.",
            "status": "pending",
            "testStrategy": "Verificar persistencia del estado del checklist. Probar reset automático diario. Confirmar animaciones y feedback visual correcto."
          },
          {
            "id": 4,
            "title": "Crear progress ring visual para las 48 horas",
            "description": "Desarrollar componente visual circular que muestre el progreso del detox de 48 horas",
            "dependencies": [
              1
            ],
            "details": "Implementar DetoxProgressRing usando CustomPainter para dibujo circular. Configurar animaciones fluidas de progreso basadas en tiempo transcurrido. Mostrar porcentaje y tiempo restante en el centro. Usar colores gradientes para indicar progreso visual.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar renderizado del ring. Probar animaciones y actualizaciones en tiempo real. Verificar cálculos correctos de porcentaje."
          },
          {
            "id": 5,
            "title": "Implementar flujo de skip con advertencia",
            "description": "Crear funcionalidad para permitir saltar el detox con diálogo de advertencia apropiado",
            "dependencies": [
              1,
              3
            ],
            "details": "Implementar SkipDetoxDialog con advertencias sobre beneficios perdidos. Configurar confirmación doble para evitar skip accidental. Registrar razón del skip en analytics. Permitir continuar más tarde desde donde se dejó como opción alternativa.",
            "status": "pending",
            "testStrategy": "Probar flujo completo de skip con confirmaciones. Verificar registro correcto en analytics. Confirmar opciones de continuación posterior."
          },
          {
            "id": 6,
            "title": "Implementar persistencia de estado de completion",
            "description": "Crear sistema de guardado del estado de completion del detox en el perfil del usuario",
            "dependencies": [
              1,
              3,
              4,
              5
            ],
            "details": "Implementar DetoxStateManager para guardar progreso en Isar y SharedPreferences. Crear modelo DetoxCompletion con timestamps, progreso y estado final. Sincronizar estado con Supabase para backup en nube. Implementar recovery del estado al abrir la app.",
            "status": "pending",
            "testStrategy": "Integration tests para persistencia local y remota. Verificar recovery correcto del estado. Probar sincronización con backend y manejo de conflictos."
          }
        ]
      },
      {
        "id": 12,
        "title": "Crear modelos para planes de ayuno predefinidos",
        "description": "Implementar estructura de datos para planes de ayuno (12/12, 14/10, 16/8, 18/6, 24h, 48h)",
        "details": "Crear clase FastingPlan con campos: id, planName, fastingHours, eatingHours, description, difficultyLevel, recommendedFor. Poblar datos seed para 6 planes predefinidos. Implementar lógica de cálculo de ventanas de ayuno/alimentación. Configurar storage en Supabase y cache local.",
        "testStrategy": "Unit tests para cálculos de ventanas temporales. Verificar datos seed correctos. Probar sincronización con backend.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir clase FastingPlan con campos específicos",
            "description": "Crear la estructura de datos base para FastingPlan con todos los campos requeridos: id, planName, fastingHours, eatingHours, description, difficultyLevel, recommendedFor",
            "dependencies": [],
            "details": "Implementar clase FastingPlan en Dart con campos tipados. Incluir constructores, métodos toString(), copyWith() y equals(). Definir enums para difficultyLevel (beginner, intermediate, advanced) y recommendedFor (weight_loss, health, lifestyle). Añadir validaciones para horas de ayuno/alimentación que sumen 24h.",
            "status": "pending",
            "testStrategy": "Unit tests para validar constructores, campos obligatorios y validaciones de horas"
          },
          {
            "id": 2,
            "title": "Implementar datos seed para 6 planes predefinidos",
            "description": "Poblar datos iniciales para los 6 planes de ayuno estándar: 12/12, 14/10, 16/8, 18/6, 24h, 48h con sus características específicas",
            "dependencies": [
              1
            ],
            "details": "Crear archivo de datos seed con los 6 planes: Plan 12/12 (principiante), 14/10 (principiante), 16/8 (intermedio), 18/6 (avanzado), 24h (avanzado), 48h (experto). Incluir descripciones detalladas, niveles de dificultad apropiados y recomendaciones de uso para cada plan.",
            "status": "pending",
            "testStrategy": "Verificar que todos los planes tengan datos completos y válidos, y que las horas sumen correctamente"
          },
          {
            "id": 3,
            "title": "Desarrollar lógica de cálculo de ventanas temporales",
            "description": "Implementar algoritmos para calcular ventanas de ayuno y alimentación basadas en hora de inicio y plan seleccionado",
            "dependencies": [
              1
            ],
            "details": "Crear métodos calculateFastingWindow() y calculateEatingWindow() que tomen hora de inicio y retornen DateTime de inicio/fin. Manejar transiciones entre días, zonas horarias y casos edge como planes de 24h/48h. Implementar lógica para calcular próxima ventana de alimentación/ayuno.",
            "status": "pending",
            "testStrategy": "Unit tests exhaustivos para diferentes horas de inicio, transiciones de día y casos límite de 24h/48h"
          },
          {
            "id": 4,
            "title": "Configurar storage en Supabase",
            "description": "Implementar persistencia de planes de ayuno en base de datos Supabase con esquema apropiado y operaciones CRUD",
            "dependencies": [
              2
            ],
            "details": "Crear tabla fasting_plans en Supabase con campos correspondientes al modelo. Implementar FastingPlanRepository con métodos getAllPlans(), getPlanById(), createCustomPlan(). Configurar mapeo entre modelo Dart y esquema SQL. Manejar errores de conexión y timeouts.",
            "status": "pending",
            "testStrategy": "Integration tests para operaciones CRUD, manejo de errores de red y validación de datos"
          },
          {
            "id": 5,
            "title": "Implementar cache local con Isar",
            "description": "Configurar almacenamiento local de planes usando Isar para acceso offline y mejor rendimiento",
            "dependencies": [
              4
            ],
            "details": "Configurar esquema Isar para FastingPlan con índices apropiados. Implementar LocalFastingPlanRepository con sync automático desde Supabase. Configurar estrategia cache-first con fallback a red. Implementar lógica de invalidación y refresh de cache.",
            "status": "pending",
            "testStrategy": "Tests de sincronización online/offline, verificar estrategia de cache y performance de consultas"
          },
          {
            "id": 6,
            "title": "Testing de cálculos temporales y validación integral",
            "description": "Crear suite completa de tests para validar todos los cálculos temporales y la integridad del sistema de planes",
            "dependencies": [
              3,
              5
            ],
            "details": "Implementar tests de integración que validen flujo completo desde carga de datos hasta cálculos temporales. Incluir tests de edge cases como cambios de horario, días bisiestos, diferentes zonas horarias. Crear tests de performance para cálculos complejos y acceso a cache.",
            "status": "pending",
            "testStrategy": "Suite de integration tests, performance tests y tests de edge cases temporales"
          }
        ]
      },
      {
        "id": 13,
        "title": "Diseñar pantalla de selección de planes",
        "description": "Crear interfaz para que usuarios elijan su plan de ayuno preferido",
        "details": "Implementar PlanSelectionScreen con cards visuales para cada plan. Mostrar información de dificultad y beneficios. Implementar filtrado por nivel de experiencia. Crear preview de horarios personalizados. Añadir opción de plan personalizado para usuarios premium.",
        "testStrategy": "UI tests para selección de planes. Verificar filtrado por dificultad. Probar navegación a pantalla principal tras selección.",
        "priority": "medium",
        "dependencies": [
          2,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar cards visuales para planes de ayuno",
            "description": "Crear componentes de tarjetas que muestren cada plan de ayuno con información visual atractiva",
            "dependencies": [],
            "details": "Diseñar y desarrollar PlanCard widget con diseño visual atractivo. Incluir título del plan, horarios de ayuno/alimentación, nivel de dificultad con iconos, beneficios principales, y diseño responsive. Usar colores diferenciados por dificultad y añadir animaciones sutiles.",
            "status": "pending",
            "testStrategy": "Widget tests para renderizado correcto de cards. Verificar responsive design en diferentes tamaños de pantalla."
          },
          {
            "id": 2,
            "title": "Crear sistema de filtrado por nivel de experiencia",
            "description": "Implementar funcionalidad para filtrar planes según el nivel de experiencia del usuario",
            "dependencies": [
              1
            ],
            "details": "Desarrollar FilterWidget con opciones: Principiante, Intermedio, Avanzado. Implementar lógica de filtrado que oculte/muestre cards según selección. Añadir chips visuales para filtros activos y opción de limpiar filtros. Persistir preferencias de filtro.",
            "status": "pending",
            "testStrategy": "Unit tests para lógica de filtrado. Verificar persistencia de preferencias. Probar combinaciones de filtros."
          },
          {
            "id": 3,
            "title": "Implementar preview de horarios personalizados",
            "description": "Crear visualización previa de cómo se verían los horarios de ayuno en el calendario del usuario",
            "dependencies": [
              1
            ],
            "details": "Desarrollar SchedulePreviewWidget que muestre timeline visual del plan seleccionado. Mostrar ventanas de ayuno y alimentación en formato de 24 horas. Incluir indicadores visuales claros y permitir ajuste de hora de inicio. Mostrar ejemplo de 3 días.",
            "status": "pending",
            "testStrategy": "Widget tests para renderizado de timeline. Verificar cálculos de horarios. Probar diferentes zonas horarias."
          },
          {
            "id": 4,
            "title": "Integrar opción de plan personalizado premium",
            "description": "Añadir funcionalidad para usuarios premium de crear planes de ayuno personalizados",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar CustomPlanCard solo visible para usuarios premium. Crear flujo de configuración personalizada con selección de horas de ayuno/alimentación flexibles. Añadir validaciones para combinaciones seguras y guardar en perfil de usuario premium.",
            "status": "pending",
            "testStrategy": "Integration tests para verificación de estado premium. Probar validaciones de horarios personalizados. Verificar persistencia de planes custom."
          },
          {
            "id": 5,
            "title": "Configurar navegación tras selección de plan",
            "description": "Implementar flujo de navegación después de que el usuario seleccione un plan",
            "dependencies": [
              4
            ],
            "details": "Configurar navigation routes hacia FastingTimerScreen tras selección. Pasar datos del plan seleccionado como parámetros. Implementar confirmación de selección con dialog y guardar plan activo en storage local y remoto.",
            "status": "pending",
            "testStrategy": "Integration tests para flujo completo de navegación. Verificar paso correcto de parámetros. Probar persistencia de plan seleccionado."
          },
          {
            "id": 6,
            "title": "Testing completo de interfaz de usuario",
            "description": "Realizar testing exhaustivo de toda la pantalla de selección de planes",
            "dependencies": [
              5
            ],
            "details": "Ejecutar suite completa de tests: widget tests individuales, integration tests del flujo completo, tests de accesibilidad, tests de rendimiento con múltiples cards, y tests de usabilidad en diferentes dispositivos. Verificar estados de carga y error.",
            "status": "pending",
            "testStrategy": "Test suite completa incluyendo unit, widget, integration y accessibility tests. Probar en múltiples dispositivos y orientaciones."
          }
        ]
      },
      {
        "id": 14,
        "title": "Implementar núcleo del TimerService",
        "description": "Crear lógica central del timer de ayuno con persistencia y precisión",
        "details": "Implementar TimerService con métodos: startFast, pauseFast, stopFast, getCurrentState. Usar DateTime para cálculos precisos en lugar de cronómetros. Implementar persistencia en SharedPreferences y Isar. Manejar transiciones entre fases (ayuno/alimentación). Configurar callbacks para UI updates.",
        "testStrategy": "Unit tests para precisión temporal. Verificar persistencia tras restart de app. Probar cálculos de elapsed/remaining time.",
        "priority": "high",
        "dependencies": [
          5,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar métodos core del TimerService",
            "description": "Crear la estructura básica del TimerService con los métodos principales startFast, pauseFast, stopFast y getCurrentState",
            "dependencies": [],
            "details": "Definir la clase TimerService con los métodos principales. Implementar la lógica básica de cada método sin persistencia ni callbacks. Establecer el estado interno del timer y las transiciones básicas entre estados.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar correcta transición entre estados del timer"
          },
          {
            "id": 2,
            "title": "Configurar cálculos precisos con DateTime",
            "description": "Implementar sistema de cálculo temporal preciso usando DateTime en lugar de cronómetros tradicionales",
            "dependencies": [
              1
            ],
            "details": "Reemplazar cualquier uso de cronómetros por cálculos basados en DateTime. Implementar métodos para calcular tiempo transcurrido y tiempo restante. Manejar cambios de zona horaria y ajustes de reloj del sistema.",
            "status": "pending",
            "testStrategy": "Tests de precisión temporal y manejo de edge cases como cambios de zona horaria"
          },
          {
            "id": 3,
            "title": "Implementar persistencia en SharedPreferences",
            "description": "Crear sistema de persistencia básica del estado del timer usando SharedPreferences para datos críticos",
            "dependencies": [
              2
            ],
            "details": "Guardar estado actual del timer, timestamps de inicio/pausa, y configuración de ayuno en SharedPreferences. Implementar métodos de save/load del estado. Manejar casos de corrupción de datos.",
            "status": "pending",
            "testStrategy": "Verificar persistencia correcta del estado tras restart de la aplicación"
          },
          {
            "id": 4,
            "title": "Implementar persistencia en Isar",
            "description": "Configurar persistencia avanzada usando Isar para datos históricos y detalles del timer",
            "dependencies": [
              3
            ],
            "details": "Crear modelos Isar para sesiones de ayuno, historial de pausas, y estadísticas. Implementar CRUD operations para datos del timer. Configurar índices para consultas eficientes.",
            "status": "pending",
            "testStrategy": "Integration tests para operaciones CRUD con Isar y verificación de integridad de datos"
          },
          {
            "id": 5,
            "title": "Manejar transiciones entre fases de ayuno y alimentación",
            "description": "Implementar lógica para detectar y manejar automáticamente las transiciones entre fases de ayuno y ventanas de alimentación",
            "dependencies": [
              2
            ],
            "details": "Detectar automáticamente cuando termina período de ayuno e inicia ventana de alimentación. Manejar notificaciones de transición. Actualizar estado del timer según la fase actual. Configurar diferentes comportamientos por fase.",
            "status": "pending",
            "testStrategy": "Tests para verificar detección correcta de transiciones y comportamiento en cada fase"
          },
          {
            "id": 6,
            "title": "Configurar callbacks para actualizaciones de UI",
            "description": "Implementar sistema de callbacks para notificar cambios de estado del timer a la interfaz de usuario",
            "dependencies": [
              5
            ],
            "details": "Crear sistema de listeners para cambios de estado del timer. Implementar callbacks para updates periódicos de tiempo restante. Configurar notificaciones para eventos importantes como inicio/fin de ayuno.",
            "status": "pending",
            "testStrategy": "Verificar que los callbacks se ejecuten correctamente y la UI se actualice en tiempo real"
          },
          {
            "id": 7,
            "title": "Implementar recovery tras reinicio de aplicación",
            "description": "Crear sistema robusto para recuperar estado del timer cuando la aplicación se reinicia",
            "dependencies": [
              4,
              6
            ],
            "details": "Detectar reinicio de aplicación y recuperar estado desde persistencia. Recalcular tiempo transcurrido basado en timestamps guardados. Restaurar callbacks y listeners. Manejar casos donde datos están corruptos o incompletos.",
            "status": "pending",
            "testStrategy": "Probar recovery después de force kill de la app y verificar continuidad del timer"
          },
          {
            "id": 8,
            "title": "Optimizar manejo de precisión temporal",
            "description": "Implementar optimizaciones para mantener precisión temporal máxima y minimizar drift del timer",
            "dependencies": [
              7
            ],
            "details": "Implementar corrección de drift temporal. Optimizar frecuencia de updates para balance entre precisión y batería. Manejar suspensión del dispositivo y background execution. Configurar watchdog para detectar inconsistencias temporales.",
            "status": "pending",
            "testStrategy": "Tests de precisión a largo plazo y verificación de performance en background"
          },
          {
            "id": 9,
            "title": "Testing de edge cases y optimización final",
            "description": "Realizar testing exhaustivo de casos extremos y optimizar performance general del TimerService",
            "dependencies": [
              8
            ],
            "details": "Probar casos como cambios de zona horaria, ajustes de reloj del sistema, low memory conditions. Optimizar consumo de batería y CPU. Realizar stress testing con múltiples sesiones. Documentar limitaciones conocidas y workarounds.",
            "status": "pending",
            "testStrategy": "Suite completa de integration tests y stress tests para validar robustez del sistema"
          }
        ]
      },
      {
        "id": 15,
        "title": "Crear FastingHomeScreen principal",
        "description": "Implementar pantalla principal con timer visual y controles de ayuno",
        "details": "Diseñar layout con timer central (48px font, bold). Implementar progress ring o barra lineal. Añadir botones Start/Stop con estados visuales claros. Mostrar información del plan actual y próxima ventana. Implementar actualizaciones en tiempo real cada segundo. Configurar transiciones suaves entre estados.",
        "testStrategy": "Widget tests para componentes de UI. Verificar actualización en tiempo real del timer. Probar transiciones visuales.",
        "priority": "high",
        "dependencies": [
          2,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar layout principal con timer central",
            "description": "Crear estructura del layout principal con timer prominente en el centro",
            "dependencies": [],
            "details": "Implementar Container principal con timer central usando font de 48px y peso bold. Estructurar el layout con Column/Stack para posicionar elementos. Configurar espaciado y padding apropiados. Asegurar que el timer sea el elemento visual dominante de la pantalla.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar layout correcto y tamaño de fuente del timer"
          },
          {
            "id": 2,
            "title": "Implementar progress ring o barra lineal",
            "description": "Crear indicador visual de progreso del ayuno con animaciones",
            "dependencies": [
              1
            ],
            "details": "Implementar CustomPainter para progress ring circular o LinearProgressIndicator personalizado. Configurar animaciones suaves para transiciones de progreso. Calcular porcentaje basado en tiempo transcurrido vs tiempo total. Aplicar colores del tema y efectos visuales apropiados.",
            "status": "pending",
            "testStrategy": "Tests de animación y cálculo correcto de porcentajes de progreso"
          },
          {
            "id": 3,
            "title": "Crear botones Start/Stop con estados visuales",
            "description": "Implementar controles principales con feedback visual claro",
            "dependencies": [
              1
            ],
            "details": "Crear ElevatedButton personalizado para Start/Stop con estados visuales distintos. Implementar colores diferentes para cada estado (verde para start, rojo para stop). Añadir iconos apropiados y efectos de hover/tap. Configurar deshabilitado cuando sea necesario.",
            "status": "pending",
            "testStrategy": "Tests de interacción y verificación de estados visuales correctos"
          },
          {
            "id": 4,
            "title": "Mostrar información del plan actual y próxima ventana",
            "description": "Implementar widgets informativos sobre el estado del ayuno",
            "dependencies": [
              1
            ],
            "details": "Crear widgets para mostrar plan de ayuno activo, tiempo restante, y próxima ventana de alimentación. Formatear información de manera clara y legible. Implementar lógica para calcular y mostrar tiempos dinámicamente. Usar Cards o Containers apropiados para organizar información.",
            "status": "pending",
            "testStrategy": "Tests unitarios para cálculos de tiempo y formatting de información"
          },
          {
            "id": 5,
            "title": "Configurar actualizaciones en tiempo real cada segundo",
            "description": "Implementar sistema de actualización automática del timer",
            "dependencies": [
              2,
              4
            ],
            "details": "Implementar Timer.periodic con intervalo de 1 segundo para actualizar UI. Configurar Stream o ValueNotifier para propagar cambios. Optimizar rebuilds usando ValueListenableBuilder o StreamBuilder. Asegurar que timer se cancele correctamente al dispose.",
            "status": "pending",
            "testStrategy": "Tests de performance y verificación de cancelación correcta del timer"
          },
          {
            "id": 6,
            "title": "Implementar transiciones visuales suaves",
            "description": "Añadir animaciones entre diferentes estados de la pantalla",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar AnimatedContainer, AnimatedOpacity y otras transiciones para cambios de estado. Configurar duraciones apropiadas (200-300ms) y curves suaves. Añadir transiciones para cambios de botones, progress ring, y información mostrada. Usar AnimationController donde sea necesario.",
            "status": "pending",
            "testStrategy": "Tests de animación y verificación de duraciones correctas"
          },
          {
            "id": 7,
            "title": "Optimizar performance de UI para actualizaciones frecuentes",
            "description": "Implementar optimizaciones para rendering eficiente",
            "dependencies": [
              5,
              6
            ],
            "details": "Usar const constructors donde sea posible. Implementar RepaintBoundary para aislar repaints. Optimizar rebuild scope usando ValueListenableBuilder específicos. Implementar shouldRebuild logic donde apropiado. Perfilar performance y eliminar rebuilds innecesarios.",
            "status": "pending",
            "testStrategy": "Performance tests y profiling para verificar frame rate estable"
          },
          {
            "id": 8,
            "title": "Testing integral de componentes de FastingHomeScreen",
            "description": "Crear suite completa de tests para toda la funcionalidad",
            "dependencies": [
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Implementar widget tests para interacciones completas. Tests de integración para flujo start/stop. Verificar actualización correcta de todos los elementos UI. Tests de estado para diferentes escenarios de ayuno. Mock de dependencias y verificación de comportamiento esperado.",
            "status": "pending",
            "testStrategy": "Suite completa de widget tests, integration tests y golden tests para UI"
          }
        ]
      },
      {
        "id": 16,
        "title": "Implementar botón de pánico (Panic Button)",
        "description": "Crear FloatingActionButton de emergencia para momentos de antojos durante el ayuno",
        "details": "Diseñar PanicButton como FloatingActionButton 64×64 naranja con elevación alta. Mostrar solo durante fase de ayuno activo. Implementar animación de pulso sutil. Configurar haptic feedback al tocar. Trackear eventos de uso para analytics. Posicionar estratégicamente en pantalla principal.",
        "testStrategy": "Verificar visibilidad solo durante ayuno. Probar haptic feedback en iOS/Android. Confirmar tracking de eventos.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear FloatingActionButton base con diseño específico",
            "description": "Implementar el componente FloatingActionButton con las especificaciones de diseño: 64×64 píxeles, color naranja, elevación alta",
            "dependencies": [],
            "details": "Crear widget PanicButton que extienda FloatingActionButton. Configurar tamaño 64×64 píxeles. Aplicar color naranja (#FF6B35 o similar). Configurar elevación alta (8.0). Agregar ícono de emergencia apropiado. Posicionar en la esquina inferior derecha de la pantalla principal.",
            "status": "pending",
            "testStrategy": "Verificar tamaño correcto del botón. Confirmar color naranja exacto. Probar elevación visual en diferentes dispositivos."
          },
          {
            "id": 2,
            "title": "Configurar visibilidad basada en estado de ayuno",
            "description": "Implementar lógica para mostrar el botón únicamente durante la fase activa de ayuno",
            "dependencies": [
              1
            ],
            "details": "Conectar PanicButton con el estado del timer de ayuno. Usar Consumer/Selector de Riverpod para escuchar cambios en el estado de ayuno. Mostrar botón solo cuando fastingState == 'active'. Ocultar durante ventanas de alimentación y cuando no hay ayuno activo. Implementar transiciones suaves de aparición/desaparición.",
            "status": "pending",
            "testStrategy": "Verificar visibilidad solo durante ayuno activo. Confirmar ocultación durante ventanas de alimentación. Probar transiciones suaves."
          },
          {
            "id": 3,
            "title": "Implementar animación de pulso sutil",
            "description": "Crear animación continua de pulso para hacer el botón más prominente durante momentos de tentación",
            "dependencies": [
              1
            ],
            "details": "Implementar AnimationController para controlar la animación de pulso. Usar Tween con ScaleTransition para efecto de escala sutil (0.95 a 1.05). Configurar duración de 2 segundos con repetición infinita. Usar Curves.easeInOut para transición suave. Optimizar rendimiento para evitar consumo excesivo de batería.",
            "status": "pending",
            "testStrategy": "Verificar animación continua y suave. Confirmar que no afecta el rendimiento. Probar en dispositivos de gama baja."
          },
          {
            "id": 4,
            "title": "Configurar haptic feedback al tocar",
            "description": "Implementar retroalimentación háptica multiplataforma para mejorar la experiencia de usuario",
            "dependencies": [
              1
            ],
            "details": "Integrar paquete flutter/services para HapticFeedback. Implementar vibración táctil al presionar el botón usando HapticFeedback.heavyImpact(). Configurar fallbacks para dispositivos sin capacidad háptica. Respetar configuraciones del sistema para vibración. Probar compatibilidad iOS y Android.",
            "status": "pending",
            "testStrategy": "Verificar haptic feedback en iOS y Android. Probar en dispositivos sin vibración. Confirmar respeto a configuraciones del sistema."
          },
          {
            "id": 5,
            "title": "Implementar tracking de eventos para analytics",
            "description": "Configurar sistema de seguimiento de uso del botón de pánico para análisis posterior",
            "dependencies": [
              4
            ],
            "details": "Crear PanicButtonAnalytics service para trackear eventos. Registrar: timestamp de uso, duración del ayuno al momento del clic, contexto de la sesión. Implementar almacenamiento local en Isar para datos offline. Configurar envío batch a analytics backend. Asegurar privacidad y anonimización de datos sensibles.",
            "status": "pending",
            "testStrategy": "Verificar captura correcta de eventos. Probar almacenamiento offline. Confirmar envío batch a servidor."
          }
        ]
      },
      {
        "id": 17,
        "title": "Crear modal de pánico con contenido motivacional",
        "description": "Implementar overlay modal que aparece al tocar el botón de pánico",
        "details": "Diseñar PanicModal con background semi-transparente. Mostrar frase motivacional aleatoria de base de datos. Incluir opciones: 'Continuar ayuno', 'Meditar', 'No puedo continuar'. Implementar diseño calmante con colores zen. Añadir animaciones suaves de entrada/salida.",
        "testStrategy": "UI tests para modal overlay. Verificar selección aleatoria de frases. Probar opciones de navegación.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar overlay modal con diseño base",
            "description": "Crear componente PanicModal con overlay semi-transparente y estructura base del modal",
            "dependencies": [],
            "details": "Implementar PanicModal widget con background semi-transparente que cubra toda la pantalla. Crear estructura de modal centrado con diseño responsivo. Configurar dismissible behavior y navegación de retorno. Implementar SafeArea y padding apropiados.",
            "status": "pending",
            "testStrategy": "UI tests para verificar overlay correcto y modal centrado en diferentes tamaños de pantalla"
          },
          {
            "id": 2,
            "title": "Integrar selección aleatoria de frases motivacionales",
            "description": "Implementar sistema de selección y muestra de frases motivacionales aleatorias desde base de datos",
            "dependencies": [
              1
            ],
            "details": "Crear servicio MotivationalQuoteService que obtenga frases aleatorias de Supabase. Implementar cache local de frases para uso offline. Configurar display de frase en modal con texto formateado y centrado. Manejar estados de loading y error.",
            "status": "pending",
            "testStrategy": "Unit tests para selección aleatoria. Verificar funcionamiento offline con cache local"
          },
          {
            "id": 3,
            "title": "Crear opciones de navegación del modal",
            "description": "Implementar botones de acción: 'Continuar ayuno', 'Meditar', 'No puedo continuar' con navegación",
            "dependencies": [
              1
            ],
            "details": "Crear tres botones estilizados con acciones específicas: continuar (cierra modal), meditar (navega a MeditationScreen), no puedo (navega a SupportScreen). Implementar callbacks apropiados y manejo de estado del timer según la opción seleccionada.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar navegación correcta desde cada botón. Probar efectos en estado del timer"
          },
          {
            "id": 4,
            "title": "Implementar animaciones de entrada y salida",
            "description": "Añadir animaciones suaves para mostrar y ocultar el modal de pánico",
            "dependencies": [
              1
            ],
            "details": "Implementar AnimatedContainer o AnimationController para fade-in del overlay. Configurar slide-up animation para el modal desde bottom. Implementar reverse animations para cierre. Configurar duración de 300ms para suavidad optimal.",
            "status": "pending",
            "testStrategy": "UI tests para verificar animations correctas. Probar performance en dispositivos de gama baja"
          },
          {
            "id": 5,
            "title": "Configurar colores zen y diseño calmante",
            "description": "Aplicar paleta de colores zen y elementos de diseño que transmitan calma y tranquilidad",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar color scheme con tonos suaves: azules claros, verdes menta, y blancos. Configurar bordes redondeados, sombras suaves. Seleccionar tipografía calmante con tamaños apropiados. Añadir gradientes sutiles y spacing generoso para reducir ansiedad visual.",
            "status": "pending",
            "testStrategy": "Visual regression tests para consistencia de diseño. User testing para validar efecto calmante"
          },
          {
            "id": 6,
            "title": "Testing de flujos de navegación completos",
            "description": "Realizar testing integral de todos los flujos de navegación y interacciones del modal",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Crear integration tests que cubran: apertura desde botón pánico, selección aleatoria de frases, navegación desde cada botón, animaciones completas, comportamiento en diferentes estados del timer. Verificar accesibilidad y compatibilidad con screen readers.",
            "status": "pending",
            "testStrategy": "End-to-end tests para flujos completos. Accessibility tests para compliance. Performance tests para animaciones"
          }
        ]
      },
      {
        "id": 18,
        "title": "Integrar animación Lottie para meditación",
        "description": "Implementar animación de respiración 4-4-8 para calmar antojos",
        "details": "Integrar lottie package y crear MeditationScreen. Implementar animación de respiración: 4s inhalar → 4s mantener → 8s exhalar. Crear controles de start/stop meditación. Añadir contador de ciclos completados. Optimizar rendimiento <100KB, 60fps en dispositivos de gama media.",
        "testStrategy": "Performance tests para 60fps. Verificar timing preciso de ciclos respiratorios. Probar en dispositivos Android de gama baja.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar lottie package en el proyecto",
            "description": "Instalar y configurar el paquete lottie en Flutter para animaciones vectoriales",
            "dependencies": [],
            "details": "Añadir lottie: ^2.7.0 al pubspec.yaml. Configurar importaciones necesarias. Verificar compatibilidad con la versión de Flutter del proyecto. Descargar archivo de animación de respiración desde LottieFiles o crear uno personalizado.",
            "status": "pending",
            "testStrategy": "Verificar que el package se instale correctamente y que las animaciones lottie puedan reproducirse sin errores"
          },
          {
            "id": 2,
            "title": "Crear MeditationScreen base",
            "description": "Implementar la pantalla principal para la funcionalidad de meditación",
            "dependencies": [
              1
            ],
            "details": "Crear MeditationScreen widget con StatefulWidget. Implementar estructura básica de UI con contenedor para animación. Añadir navegación desde pantalla principal. Configurar SafeArea y diseño responsive para diferentes tamaños de pantalla.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar que la pantalla se renderice correctamente en diferentes dispositivos"
          },
          {
            "id": 3,
            "title": "Implementar animación de respiración 4-4-8",
            "description": "Configurar la animación Lottie con timing preciso para el patrón de respiración",
            "dependencies": [
              2
            ],
            "details": "Integrar LottieBuilder widget en MeditationScreen. Implementar controlador de animación con timing exacto: 4 segundos inhalar, 4 segundos mantener, 8 segundos exhalar. Sincronizar animación visual con duración de ciclo de 16 segundos total. Añadir indicadores visuales de cada fase.",
            "status": "pending",
            "testStrategy": "Probar precisión del timing con cronómetro. Verificar que la animación se reproduce suavemente sin interrupciones"
          },
          {
            "id": 4,
            "title": "Crear controles de start/stop meditación",
            "description": "Implementar botones y lógica para iniciar y detener la sesión de meditación",
            "dependencies": [
              3
            ],
            "details": "Añadir FloatingActionButton para start/stop. Implementar estado de meditación (idle, active, paused). Manejar inicio y pausa de la animación. Añadir feedback visual del estado actual (botón play/pause). Implementar reset de sesión al detener.",
            "status": "pending",
            "testStrategy": "Probar que los controles respondan correctamente y que el estado se mantenga consistente"
          },
          {
            "id": 5,
            "title": "Implementar contador de ciclos completados",
            "description": "Añadir sistema de conteo y visualización de ciclos de respiración completados",
            "dependencies": [
              4
            ],
            "details": "Crear variable de estado para contar ciclos completados. Incrementar contador cada 16 segundos (un ciclo completo). Mostrar contador en UI con diseño atractivo. Implementar persistencia del progreso de sesión. Añadir meta de ciclos recomendados.",
            "status": "pending",
            "testStrategy": "Verificar que el contador incremente correctamente cada 16 segundos. Probar persistencia durante pausas"
          },
          {
            "id": 6,
            "title": "Optimizar performance para 60fps",
            "description": "Optimizar la animación y rendering para mantener 60fps en dispositivos de gama media",
            "dependencies": [
              5
            ],
            "details": "Optimizar tamaño del archivo Lottie a menos de 100KB. Implementar cached_network_image para cargar animación. Usar RepaintBoundary para aislar animación. Configurar frame rate objetivo. Implementar monitoreo de performance con Flutter Performance widget.",
            "status": "pending",
            "testStrategy": "Performance tests en dispositivos de gama media. Verificar que se mantengan 60fps constantes durante sesión completa"
          },
          {
            "id": 7,
            "title": "Testing en dispositivos de gama baja",
            "description": "Realizar pruebas exhaustivas en dispositivos Android de gama baja para validar performance",
            "dependencies": [
              6
            ],
            "details": "Probar en dispositivos con Android 7.0+, RAM mínima 2GB. Verificar timing preciso de ciclos respiratorios ±200ms. Monitorear uso de CPU y memoria durante sesiones largas. Implementar fallbacks para dispositivos con performance limitada. Documentar requisitos mínimos del sistema.",
            "status": "pending",
            "testStrategy": "Integration tests en dispositivos físicos de gama baja. Verificar que la app no crashee y mantenga precisión de timing"
          }
        ]
      },
      {
        "id": 19,
        "title": "Crear sistema de frases motivacionales",
        "description": "Implementar biblioteca de contenido motivacional para el botón de pánico",
        "details": "Crear tabla motivational_phrases en Supabase con categorías: motivation, anti_binge, calm. Poblar con 24 frases en español optimizadas para antojos. Implementar MotivationalService para selección aleatoria y cache local. Configurar actualización periódica de contenido desde servidor.",
        "testStrategy": "Verificar selección aleatoria sin repetición inmediata. Probar cache offline. Confirmar contenido en español apropiado.",
        "priority": "medium",
        "dependencies": [
          4,
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear tabla motivational_phrases en Supabase",
            "description": "Diseñar y crear la tabla de frases motivacionales en la base de datos con estructura y categorías apropiadas",
            "dependencies": [
              4
            ],
            "details": "Crear migración SQL para tabla motivational_phrases con campos: id (uuid), content (text), category (enum: motivation, anti_binge, calm), language (text), created_at, updated_at. Configurar índices para búsqueda eficiente por categoría. Establecer políticas RLS para acceso público de lectura.",
            "status": "pending",
            "testStrategy": "Verificar creación correcta de tabla y índices. Probar políticas RLS para acceso de lectura pública."
          },
          {
            "id": 2,
            "title": "Poblar base de datos con 24 frases motivacionales en español",
            "description": "Insertar contenido inicial de frases motivacionales optimizadas para situaciones de antojo y pánico",
            "dependencies": [
              1
            ],
            "details": "Crear script de inserción con 8 frases por categoría (motivation, anti_binge, calm). Frases optimizadas para contexto de ayuno y control de antojos. Contenido en español natural y motivador. Validar longitud apropiada para UI móvil (máximo 150 caracteres).",
            "status": "pending",
            "testStrategy": "Verificar inserción correcta de 24 frases distribuidas equitativamente. Confirmar contenido apropiado en español."
          },
          {
            "id": 3,
            "title": "Implementar MotivationalService para gestión de frases",
            "description": "Crear servicio principal para manejar la lógica de negocio de frases motivacionales",
            "dependencies": [
              2
            ],
            "details": "Implementar MotivationalService con métodos: getRandomPhrase(category), getAllPhrases(), syncFromServer(). Integrar con cliente Supabase para queries. Manejar errores de conexión gracefully. Implementar logging para debugging.",
            "status": "pending",
            "testStrategy": "Unit tests para todos los métodos del servicio. Probar manejo de errores de red y base de datos."
          },
          {
            "id": 4,
            "title": "Configurar selección aleatoria sin repetición inmediata",
            "description": "Implementar algoritmo que evite mostrar la misma frase consecutivamente",
            "dependencies": [
              3
            ],
            "details": "Implementar RandomPhraseSelector que mantenga historial de últimas frases mostradas (buffer de 3-5 frases). Usar algoritmo de shuffle para distribución equitativa. Reiniciar buffer cuando se agoten opciones únicas. Persistir estado entre sesiones de app.",
            "status": "pending",
            "testStrategy": "Verificar que no se repitan frases inmediatamente. Probar distribución equitativa de selección aleatoria."
          },
          {
            "id": 5,
            "title": "Implementar sistema de cache local",
            "description": "Crear cache persistente para funcionamiento offline de frases motivacionales",
            "dependencies": [
              3
            ],
            "details": "Implementar PhraseCache usando SharedPreferences o Hive para persistencia local. Cache todas las frases al inicializar app. Implementar estrategia cache-first con fallback a servidor. Manejar invalidación de cache con timestamps. Límite de storage y limpieza automática.",
            "status": "pending",
            "testStrategy": "Probar funcionamiento offline completo. Verificar sincronización correcta entre cache y servidor."
          },
          {
            "id": 6,
            "title": "Configurar actualización periódica de contenido",
            "description": "Implementar sincronización automática de nuevas frases desde el servidor",
            "dependencies": [
              4,
              5
            ],
            "details": "Implementar ContentSyncService que verifique actualizaciones cada 24h usando background tasks. Comparar timestamps para detectar nuevo contenido. Actualizar cache local incrementalmente. Configurar retry logic para fallos de red. Notificar UI de nuevas frases disponibles.",
            "status": "pending",
            "testStrategy": "Verificar sincronización automática en background. Probar manejo de actualizaciones incrementales y fallos de red."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implementar flujo de interrupción de ayuno",
        "description": "Manejar cuando usuario decide romper el ayuno antes del tiempo planeado",
        "details": "Añadir lógica para marcar sesión como 'interrupted' en lugar de 'completed'. Implementar confirmación con advertencia sobre pérdida de progreso. Guardar tiempo parcial para métricas. Actualizar streaks apropiadamente. Ofrecer opción de continuar después de comer algo pequeño.",
        "testStrategy": "Verificar cálculo correcto de métricas con ayunos interrumpidos. Probar flujo de confirmación. Validar impacto en streaks.",
        "priority": "medium",
        "dependencies": [
          14,
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar lógica para marcar sesión como 'interrupted'",
            "description": "Añadir estado 'interrupted' al modelo de sesión y lógica para transicionar desde estado activo a interrumpido",
            "dependencies": [],
            "details": "Modificar el enum SessionStatus para incluir 'interrupted'. Actualizar TimerService para manejar la transición de 'active' a 'interrupted'. Asegurar que el tiempo transcurrido se calcule correctamente hasta el momento de interrupción.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar transición correcta de estados y cálculo preciso del tiempo transcurrido"
          },
          {
            "id": 2,
            "title": "Crear diálogo de confirmación con advertencia",
            "description": "Implementar UI de confirmación que advierte sobre pérdida de progreso al interrumpir ayuno",
            "dependencies": [
              1
            ],
            "details": "Crear InterruptFastDialog con mensaje de advertencia sobre pérdida de progreso del streak. Incluir botones de confirmación y cancelación. Mostrar tiempo transcurrido y tiempo restante. Implementar diseño responsive siguiendo guías de Material Design.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar correcta visualización del diálogo y manejo de interacciones del usuario"
          },
          {
            "id": 3,
            "title": "Implementar cálculo de tiempo parcial para métricas",
            "description": "Desarrollar lógica para calcular y almacenar métricas de tiempo parcial en ayunos interrumpidos",
            "dependencies": [
              1
            ],
            "details": "Crear método calculatePartialMetrics que compute tiempo ayunado, porcentaje completado, y calorías estimadas quemadas. Almacenar estos datos en el modelo FastingSession. Asegurar compatibilidad con sistema de métricas existente.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar cálculos precisos de métricas parciales y correcta persistencia en base de datos"
          },
          {
            "id": 4,
            "title": "Configurar actualización de streaks para interrupciones",
            "description": "Implementar lógica para actualizar streaks cuando un ayuno es interrumpido antes de completarse",
            "dependencies": [
              1,
              3
            ],
            "details": "Modificar StreakService para manejar ayunos interrumpidos. Implementar reglas de negocio: streak se mantiene si >50% completado, se rompe si <50%. Actualizar contadores de días consecutivos y estadísticas generales apropiadamente.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar reglas de streak con diferentes porcentajes de compleción y edge cases"
          },
          {
            "id": 5,
            "title": "Implementar opción de continuar ayuno",
            "description": "Crear funcionalidad para permitir al usuario continuar el ayuno después de una pequeña ingesta",
            "dependencies": [
              2
            ],
            "details": "Añadir botón 'Continuar Ayuno' en diálogo de confirmación. Implementar lógica para marcar sesión como 'resumed' y continuar conteo desde donde se interrumpió. Registrar evento de reanudación para análisis posterior.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar flujo completo de interrupción y reanudación, incluyendo persistencia de estado"
          },
          {
            "id": 6,
            "title": "Testing de edge cases del flujo de interrupción",
            "description": "Probar casos extremos y escenarios poco comunes en el flujo de interrupción de ayuno",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Crear tests para escenarios: interrupción inmediatamente después de iniciar, interrupción al 99% completado, múltiples interrupciones consecutivas, interrupción sin conectividad, corrupción de datos durante interrupción.",
            "status": "pending",
            "testStrategy": "Comprehensive test suite cubriendo edge cases, error handling, y recovery scenarios"
          },
          {
            "id": 7,
            "title": "Validar impacto en métricas y analytics",
            "description": "Verificar que las interrupciones se reflejen correctamente en todas las métricas y reportes de la aplicación",
            "dependencies": [
              3,
              4,
              6
            ],
            "details": "Auditar impacto en dashboard de métricas, reportes semanales/mensuales, gráficos de progreso, y exportación de datos. Asegurar que ayunos interrumpidos se distingan claramente de completados en todas las vistas analíticas.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar consistencia de datos across toda la app y correcta visualización en reportes"
          }
        ]
      },
      {
        "id": 21,
        "title": "Crear modelo y servicio de hidratación",
        "description": "Implementar tracking de ingesta de agua con cálculo automático de objetivos",
        "details": "Crear HydrationLog model con campos: userId, date, totalMl, glassSizeMl, logsCount. Implementar HydrationService con cálculo automático: peso_kg × 32ml = objetivo diario. Añadir configuración de tamaño de vaso personalizable. Implementar reset automático diario a medianoche.",
        "testStrategy": "Unit tests para cálculo de objetivos. Verificar reset automático diario. Probar persistencia de configuración de vaso.",
        "priority": "medium",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo HydrationLog con campos requeridos",
            "description": "Implementar la clase HydrationLog con todos los campos necesarios para el tracking de hidratación",
            "dependencies": [],
            "details": "Crear modelo HydrationLog con campos: userId (String), date (DateTime), totalMl (int), glassSizeMl (int), logsCount (int). Configurar anotaciones Isar y validaciones básicas. Implementar métodos toJson/fromJson para serialización.",
            "status": "pending",
            "testStrategy": "Unit tests para validación de campos obligatorios y serialización JSON"
          },
          {
            "id": 2,
            "title": "Implementar HydrationService con cálculo automático de objetivos",
            "description": "Crear servicio para gestionar la lógica de hidratación y cálculo automático del objetivo diario",
            "dependencies": [
              1
            ],
            "details": "Implementar HydrationService con método calculateDailyGoal(peso_kg) que aplique la fórmula peso_kg × 32ml. Añadir métodos para agregar ingesta de agua, obtener progreso diario, y validar que el objetivo se mantenga actualizado según el peso del usuario.",
            "status": "pending",
            "testStrategy": "Unit tests para cálculo de objetivos con diferentes pesos. Verificar actualización automática de objetivos."
          },
          {
            "id": 3,
            "title": "Configurar tamaño de vaso personalizable",
            "description": "Implementar sistema de configuración para permitir personalizar el tamaño del vaso de agua",
            "dependencies": [
              1
            ],
            "details": "Añadir configuración de glassSizeMl personalizable en UserProfile o configuración separada. Implementar validaciones (rango 50ml-1000ml). Crear métodos para actualizar y persistir la configuración. Integrar con HydrationService para usar el tamaño configurado.",
            "status": "pending",
            "testStrategy": "Unit tests para validación de rangos. Verificar persistencia de configuración personalizada."
          },
          {
            "id": 4,
            "title": "Implementar reset automático diario a medianoche",
            "description": "Crear sistema de reset automático que reinicie los contadores de hidratación cada día",
            "dependencies": [
              2
            ],
            "details": "Implementar scheduler/timer que se ejecute a medianoche para resetear totalMl y logsCount del día actual. Usar WorkManager o similar para garantizar ejecución en background. Crear método resetDailyProgress() que mantenga el historial pero reinicie contadores actuales.",
            "status": "pending",
            "testStrategy": "Unit tests para lógica de reset. Integration tests para verificar ejecución programada a medianoche."
          },
          {
            "id": 5,
            "title": "Configurar persistencia con Isar database",
            "description": "Establecer la configuración de base de datos Isar para el modelo HydrationLog",
            "dependencies": [
              1
            ],
            "details": "Configurar Isar collection para HydrationLog con índices en userId y date. Implementar métodos CRUD: save, findByUserAndDate, getHistoryByUser, deleteOldRecords. Configurar relaciones con UserProfile si es necesario. Añadir migración de schema si aplica.",
            "status": "pending",
            "testStrategy": "Integration tests para operaciones CRUD. Verificar performance de queries con grandes volúmenes de datos."
          },
          {
            "id": 6,
            "title": "Testing integral de cálculos y reset automático",
            "description": "Crear suite completa de tests para validar todos los cálculos y funcionalidad de reset automático",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Crear integration tests que validen el flujo completo: cálculo de objetivos basado en peso, registro de ingesta, actualización de progreso, y reset automático. Incluir tests para edge cases: cambio de peso, múltiples registros por día, reset en diferentes zonas horarias.",
            "status": "pending",
            "testStrategy": "Integration tests end-to-end. Tests de performance para grandes volúmenes. Verificar comportamiento en diferentes timezones."
          }
        ]
      },
      {
        "id": 22,
        "title": "Implementar WaterButton para logging rápido",
        "description": "Crear botón flotante para registrar consumo de agua con un toque",
        "details": "Diseñar WaterButton como FAB 56×56 azul/teal en esquina inferior izquierda. Implementar logging de un vaso con un toque. Mostrar feedback visual (ripple + progreso actualizado). Añadir debouncing para toques rápidos múltiples. Implementar haptic feedback sutil.",
        "testStrategy": "Verificar debouncing funciona correctamente. Probar feedback visual inmediato. Confirmar haptic feedback en ambas plataformas.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar FloatingActionButton con diseño específico",
            "description": "Crear el componente WaterButton como FloatingActionButton con especificaciones de diseño establecidas",
            "dependencies": [],
            "details": "Implementar FloatingActionButton de 56×56 píxeles con colores azul/teal. Posicionar en esquina inferior izquierda de la pantalla. Configurar elevación y sombras apropiadas. Asegurar accesibilidad con semantic labels. Implementar estado visual hover/pressed.",
            "status": "pending",
            "testStrategy": "Verificar dimensiones exactas y posicionamiento. Probar estados visuales en diferentes dispositivos."
          },
          {
            "id": 2,
            "title": "Configurar logging de un vaso con un toque",
            "description": "Implementar la funcionalidad de registrar consumo de agua con un solo toque",
            "dependencies": [
              1
            ],
            "details": "Conectar el botón con el sistema de logging de agua. Configurar cantidad predeterminada de un vaso (250ml). Integrar con el servicio de datos existente para persistir el registro. Actualizar contadores y progreso del usuario inmediatamente.",
            "status": "pending",
            "testStrategy": "Verificar que un toque registre exactamente un vaso. Confirmar persistencia de datos y actualización inmediata de UI."
          },
          {
            "id": 3,
            "title": "Implementar feedback visual y haptic",
            "description": "Añadir retroalimentación visual y táctil al presionar el WaterButton",
            "dependencies": [
              2
            ],
            "details": "Implementar efecto ripple al tocar el botón. Mostrar actualización visual inmediata del progreso de hidratación. Configurar haptic feedback sutil usando HapticFeedback.lightImpact(). Añadir animación de confirmación (escala o color change) al completar el registro.",
            "status": "pending",
            "testStrategy": "Verificar haptic feedback en dispositivos físicos. Probar feedback visual en diferentes tamaños de pantalla."
          },
          {
            "id": 4,
            "title": "Configurar debouncing para toques múltiples",
            "description": "Implementar sistema de debouncing para prevenir registros accidentales múltiples",
            "dependencies": [
              3
            ],
            "details": "Implementar debouncing con ventana de tiempo de 500ms para prevenir toques múltiples accidentales. Configurar estado disabled temporal del botón durante debouncing. Mostrar indicador visual durante el período de debounce. Permitir toques intencionales múltiples después del período de espera.",
            "status": "pending",
            "testStrategy": "Verificar que toques rápidos múltiples no registren varios vasos. Probar que toques intencionales espaciados funcionen correctamente."
          },
          {
            "id": 5,
            "title": "Testing de funcionalidad en ambas plataformas",
            "description": "Realizar testing integral del WaterButton en iOS y Android",
            "dependencies": [
              4
            ],
            "details": "Ejecutar tests unitarios y de integración en ambas plataformas. Verificar comportamiento consistente del haptic feedback. Probar rendimiento y responsividad del botón. Validar accesibilidad y compatibilidad con screen readers. Realizar testing en diferentes tamaños de pantalla y densidades.",
            "status": "pending",
            "testStrategy": "Testing automatizado con flutter test. Testing manual en dispositivos físicos iOS y Android. Verificar accesibilidad con TalkBack y VoiceOver."
          }
        ]
      },
      {
        "id": 23,
        "title": "Crear indicador visual de progreso de hidratación",
        "description": "Implementar UI para mostrar progreso diario de ingesta de agua",
        "details": "Diseñar HydrationProgressWidget con barra de progreso o círculo. Mostrar ml consumidos / objetivo total. Añadir indicador de vasos bebidos vs. objetivo de vasos. Implementar colores progresivos (rojo → amarillo → verde). Incluir mensaje de felicitación al alcanzar objetivo.",
        "testStrategy": "Widget tests para diferentes estados de progreso. Verificar cálculos de porcentaje. Probar animaciones de progreso.",
        "priority": "medium",
        "dependencies": [
          22
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar componente HydrationProgressWidget base",
            "description": "Crear la estructura básica del widget de progreso de hidratación con layout y diseño inicial",
            "dependencies": [],
            "details": "Implementar HydrationProgressWidget como StatefulWidget con estructura básica. Definir propiedades necesarias: currentIntake, dailyGoal, glassesConsumed, glassesTarget. Crear layout responsivo con Container y Column. Configurar parámetros de personalización como tamaño y estilo. Establecer base para barra de progreso y texto informativo.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar renderizado correcto del componente base y propiedades iniciales"
          },
          {
            "id": 2,
            "title": "Implementar lógica de cálculos de progreso",
            "description": "Desarrollar métodos para calcular porcentajes y estados de progreso basados en ingesta actual vs objetivo",
            "dependencies": [
              1
            ],
            "details": "Crear métodos de cálculo: calculateProgressPercentage(), calculateGlassesProgress(), getProgressStatus(). Implementar validaciones para evitar división por cero y valores negativos. Manejar casos extremos como ingesta superior al objetivo. Calcular porcentajes tanto para ml como para vasos. Optimizar cálculos para performance en tiempo real.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar precisión de cálculos en diferentes escenarios y casos extremos"
          },
          {
            "id": 3,
            "title": "Configurar sistema de colores progresivos",
            "description": "Implementar lógica de cambio de colores basada en porcentaje de progreso (rojo → amarillo → verde)",
            "dependencies": [
              2
            ],
            "details": "Crear método getProgressColor() que retorne Color basado en porcentaje. Definir rangos: 0-33% rojo, 34-66% amarillo, 67-100% verde. Implementar interpolación suave entre colores para transiciones graduales. Configurar colores accesibles que cumplan contraste WCAG. Crear constantes de colores reutilizables en theme.",
            "status": "pending",
            "testStrategy": "Tests para verificar colores correctos en cada rango de progreso y transiciones suaves"
          },
          {
            "id": 4,
            "title": "Implementar animaciones de progreso y UI visual",
            "description": "Crear animaciones fluidas para barra/círculo de progreso y efectos visuales de transición",
            "dependencies": [
              3
            ],
            "details": "Implementar AnimationController para progreso suave de barra/círculo. Crear Tween para interpolar valores de progreso. Añadir animaciones de entrada y salida del widget. Implementar bounce effect al completar objetivo. Configurar duración de animaciones (300-500ms). Optimizar performance evitando rebuilds innecesarios.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar animaciones fluidas y performance en diferentes dispositivos"
          },
          {
            "id": 5,
            "title": "Implementar mensajes de felicitación y testing integral",
            "description": "Añadir sistema de mensajes motivacionales al completar objetivo y realizar testing completo del widget",
            "dependencies": [
              4
            ],
            "details": "Crear showCongratulationsMessage() que se active al 100% de progreso. Implementar diferentes mensajes aleatorios para variedad. Añadir animación de celebración con confetti o shimmer effect. Configurar persistencia para evitar spam de mensajes. Realizar testing integral con diferentes estados: vacío, parcial, completo, excedido.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar flujo completo del widget en todos los estados posibles y mensajes de felicitación"
          }
        ]
      },
      {
        "id": 24,
        "title": "Implementar recordatorios de hidratación",
        "description": "Crear sistema de notificaciones para recordar beber agua",
        "details": "Implementar HydrationReminderService con notificaciones cada 1-2 horas. Pausar recordatorios durante ventanas de sueño configurables. Personalizar frecuencia basada en objetivo de agua. Suprimir si objetivo ya alcanzado. Integrar con OneSignal para delivery confiable.",
        "testStrategy": "Verificar programación correcta de recordatorios. Probar supresión durante horas de sueño. Confirmar cancelación al alcanzar objetivo.",
        "priority": "low",
        "dependencies": [
          6,
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar HydrationReminderService base",
            "description": "Crear la clase base HydrationReminderService con la estructura fundamental y métodos principales",
            "dependencies": [],
            "details": "Crear HydrationReminderService con métodos startReminders(), stopReminders(), updateSchedule(). Implementar constructor con dependencias necesarias. Definir estructura de datos para configuración de recordatorios. Configurar logging básico para debugging.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar creación correcta del servicio y métodos públicos"
          },
          {
            "id": 2,
            "title": "Configurar sistema de notificaciones cada 1-2 horas",
            "description": "Implementar lógica de scheduling para notificaciones regulares de hidratación",
            "dependencies": [
              1
            ],
            "details": "Implementar calculateNextReminderTime() que genere intervalos de 1-2 horas. Usar WorkManager para scheduling persistente. Configurar datos personalizados en notificaciones. Implementar cancelación de recordatorios existentes antes de programar nuevos.",
            "status": "pending",
            "testStrategy": "Verificar cálculo correcto de intervalos y programación con WorkManager"
          },
          {
            "id": 3,
            "title": "Implementar pausa durante horas de sueño",
            "description": "Crear lógica para pausar recordatorios durante ventanas de sueño configurables",
            "dependencies": [
              2
            ],
            "details": "Implementar SleepWindowChecker con métodos isInSleepWindow(). Configurar preferencias de usuario para horas de sueño (bedtime, wakeup). Modificar scheduling para respetar ventanas de sueño. Implementar cálculo de próximo recordatorio post-sueño.",
            "status": "pending",
            "testStrategy": "Probar detección correcta de ventanas de sueño y suspensión de recordatorios"
          },
          {
            "id": 4,
            "title": "Personalizar frecuencia basada en objetivo de agua",
            "description": "Adaptar la frecuencia de recordatorios según el objetivo diario de hidratación del usuario",
            "dependencies": [
              3
            ],
            "details": "Implementar calculateOptimalFrequency() basado en objetivo diario y progreso actual. Ajustar intervalos dinámicamente: más frecuente si está retrasado, menos si va adelantado. Configurar límites mínimos y máximos de frecuencia. Persistir configuración personalizada.",
            "status": "pending",
            "testStrategy": "Verificar cálculo correcto de frecuencia adaptativa según diferentes escenarios"
          },
          {
            "id": 5,
            "title": "Implementar supresión al alcanzar objetivo",
            "description": "Configurar lógica para suprimir recordatorios cuando se alcance el objetivo diario",
            "dependencies": [
              4
            ],
            "details": "Implementar checkDailyGoalStatus() que consulte progreso actual. Cancelar recordatorios programados cuando objetivo sea alcanzado. Configurar mensaje de felicitación al usuario. Implementar reset automático para el día siguiente.",
            "status": "pending",
            "testStrategy": "Confirmar cancelación correcta al alcanzar objetivo y reset diario"
          },
          {
            "id": 6,
            "title": "Integrar con OneSignal para delivery confiable",
            "description": "Configurar integración con OneSignal para garantizar entrega confiable de notificaciones",
            "dependencies": [
              5
            ],
            "details": "Implementar OneSignalNotificationProvider con métodos sendHydrationReminder(). Configurar templates de notificación en OneSignal. Implementar fallback a notificaciones locales si OneSignal falla. Manejar tokens de dispositivo y segmentación de usuarios.",
            "status": "pending",
            "testStrategy": "Verificar envío correcto vía OneSignal y fallback a notificaciones locales"
          },
          {
            "id": 7,
            "title": "Implementar testing de scheduling",
            "description": "Crear suite de tests comprehensiva para verificar el sistema de programación de recordatorios",
            "dependencies": [
              6
            ],
            "details": "Crear ReminderSchedulingTest con casos: programación inicial, reprogramación, cancelación. Mockear WorkManager y OneSignal. Probar edge cases: cambios de zona horaria, reinicio de app. Implementar tests de integración para flujo completo.",
            "status": "pending",
            "testStrategy": "Suite completa de unit e integration tests para scheduling"
          },
          {
            "id": 8,
            "title": "Validar lógica de supresión y edge cases",
            "description": "Probar y validar todos los escenarios de supresión y casos especiales del sistema",
            "dependencies": [
              7
            ],
            "details": "Implementar HydrationReminderValidationTest para casos: cambio de objetivo mid-day, múltiples usuarios, días sin registros. Probar comportamiento con cambios de configuración. Validar persistencia tras crashes de app. Crear tests de performance para scheduling masivo.",
            "status": "pending",
            "testStrategy": "Tests exhaustivos de edge cases y validación de comportamiento en escenarios complejos"
          }
        ]
      },
      {
        "id": 25,
        "title": "Crear servicio de cálculo de métricas",
        "description": "Implementar MetricsService para calcular estadísticas de progreso del usuario",
        "details": "Implementar cálculos: current streak (días consecutivos), total hours fasted, completion rate, longest fast. Crear UserMetrics model para cache de resultados. Implementar trigger automático tras completar sesión. Optimizar consultas Isar para rendimiento. Añadir Edge Function en Supabase para cálculos del servidor.",
        "testStrategy": "Unit tests para cálculos de streaks. Verificar precision de total hours. Probar performance con >100 sesiones históricas.",
        "priority": "medium",
        "dependencies": [
          8,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar cálculo de current streak (días consecutivos)",
            "description": "Desarrollar algoritmo para calcular la racha actual de días consecutivos de ayuno completado",
            "dependencies": [],
            "details": "Crear método calculateCurrentStreak() que consulte las sesiones de ayuno en orden cronológico descendente, verificando continuidad día a día hasta encontrar un gap. Manejar casos edge como ayunos que cruzan medianoche y diferentes zonas horarias.",
            "status": "pending",
            "testStrategy": "Unit tests con datasets de diferentes patrones de ayuno: rachas perfectas, gaps de 1 día, ayunos cross-midnight"
          },
          {
            "id": 2,
            "title": "Desarrollar cálculo de total hours fasted",
            "description": "Implementar suma acumulativa de todas las horas de ayuno completadas por el usuario",
            "dependencies": [
              1
            ],
            "details": "Crear método calculateTotalHoursFasted() que sume la duración de todas las sesiones completadas. Optimizar con agregación en lugar de iteración completa. Considerar precisión de milisegundos y redondeo apropiado.",
            "status": "pending",
            "testStrategy": "Verificar precisión con datasets grandes (>1000 sesiones). Probar performance vs implementación naive"
          },
          {
            "id": 3,
            "title": "Implementar cálculo de completion rate",
            "description": "Calcular porcentaje de ayunos completados exitosamente vs total iniciados",
            "dependencies": [
              2
            ],
            "details": "Crear método calculateCompletionRate() = (ayunos_completados / ayunos_totales) * 100. Manejar división por cero. Considerar diferentes períodos de tiempo (último mes, último año, total). Implementar filtros por tipo de ayuno.",
            "status": "pending",
            "testStrategy": "Unit tests con edge cases: sin ayunos, todos completados, todos cancelados. Verificar precisión decimal"
          },
          {
            "id": 4,
            "title": "Crear tracking de longest fast",
            "description": "Implementar cálculo del ayuno más largo completado por el usuario",
            "dependencies": [
              3
            ],
            "details": "Crear método calculateLongestFast() que encuentre la sesión con mayor duración completada. Optimizar con indexación por duración. Incluir metadatos: fecha del ayuno más largo, tipo de ayuno.",
            "status": "pending",
            "testStrategy": "Probar con datasets variados de duraciones. Verificar que solo considere ayunos completados, no cancelados"
          },
          {
            "id": 5,
            "title": "Configurar UserMetrics model para cache",
            "description": "Crear modelo de datos para cachear resultados de métricas calculadas",
            "dependencies": [
              4
            ],
            "details": "Diseñar UserMetrics con campos: userId, currentStreak, totalHoursFasted, completionRate, longestFastDuration, lastCalculated, isStale. Implementar en Isar con índices apropiados. Configurar TTL para invalidación automática.",
            "status": "pending",
            "testStrategy": "Unit tests para serialización/deserialización. Verificar integridad de índices y constraints"
          },
          {
            "id": 6,
            "title": "Implementar triggers automáticos",
            "description": "Configurar recálculo automático de métricas tras eventos específicos",
            "dependencies": [
              5
            ],
            "details": "Implementar listeners para: sesión completada, sesión cancelada, datos sincronizados. Usar debouncing para evitar cálculos excesivos. Implementar background refresh con WorkManager para Android.",
            "status": "pending",
            "testStrategy": "Integration tests para triggers. Verificar debouncing funciona correctamente. Probar background refresh"
          },
          {
            "id": 7,
            "title": "Optimizar consultas Isar para rendimiento",
            "description": "Mejorar performance de consultas de base de datos para cálculos de métricas",
            "dependencies": [
              6
            ],
            "details": "Implementar índices compuestos para consultas frecuentes. Usar agregaciones nativas de Isar donde sea posible. Implementar paginación para datasets grandes. Configurar lazy loading para datos no críticos.",
            "status": "pending",
            "testStrategy": "Benchmark tests con datasets de 1K, 10K, 100K registros. Verificar mejora de performance vs implementación baseline"
          },
          {
            "id": 8,
            "title": "Crear Edge Function en Supabase para cálculos del servidor",
            "description": "Implementar función serverless para cálculos de métricas complejas y sincronización",
            "dependencies": [
              7
            ],
            "details": "Desarrollar Edge Function que replique lógica de cálculos locales. Implementar endpoint /calculate-metrics con autenticación JWT. Configurar CORS y rate limiting. Optimizar para múltiples usuarios concurrentes.",
            "status": "pending",
            "testStrategy": "Integration tests para Edge Function. Load testing con 100+ usuarios concurrentes. Verificar consistencia con cálculos locales"
          },
          {
            "id": 9,
            "title": "Testing con datasets grandes y validación final",
            "description": "Realizar testing integral del sistema de métricas con volúmenes reales de datos",
            "dependencies": [
              8
            ],
            "details": "Generar datasets de prueba con 1000+ sesiones por usuario. Ejecutar stress tests de performance. Validar consistencia entre cálculos locales y servidor. Implementar monitoring y alertas para discrepancias.",
            "status": "pending",
            "testStrategy": "End-to-end tests con datos reales simulados. Verificar performance bajo carga. Probar recovery después de corrupción de cache"
          }
        ]
      },
      {
        "id": 26,
        "title": "Implementar dashboard de métricas",
        "description": "Crear pantalla principal de estadísticas y progreso del usuario",
        "details": "Diseñar MetricsDashboardScreen con widgets para streak actual, total de horas, tasa de completación. Implementar gráficos simples con FL Chart. Mostrar mejor racha personal y ayuno más largo. Añadir cards visuales con iconografía motivacional. Configurar refresh automático de datos.",
        "testStrategy": "Widget tests para componentes de métricas. Verificar actualización automática de datos. Probar rendimiento de gráficos.",
        "priority": "medium",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar estructura de MetricsDashboardScreen",
            "description": "Crear el layout principal de la pantalla de dashboard con scaffold y estructura de widgets",
            "dependencies": [],
            "details": "Implementar MetricsDashboardScreen con Scaffold, AppBar personalizada, body con SafeArea y estructura de columnas/filas para organizar los widgets de métricas. Definir responsive design para diferentes tamaños de pantalla.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar estructura del scaffold y responsive design"
          },
          {
            "id": 2,
            "title": "Implementar widgets de métricas básicas",
            "description": "Crear widgets para mostrar streak actual, total de horas de ayuno y tasa de completación",
            "dependencies": [
              1
            ],
            "details": "Desarrollar MetricCardWidget reutilizable con diseño consistente. Implementar widgets específicos: CurrentStreakWidget, TotalHoursWidget, CompletionRateWidget. Incluir iconografía motivacional y formateo de números apropiado.",
            "status": "pending",
            "testStrategy": "Unit tests para cálculos de métricas y widget tests para rendering correcto"
          },
          {
            "id": 3,
            "title": "Integrar FL Chart para gráficos",
            "description": "Implementar gráficos visuales usando la librería FL Chart para mostrar progreso temporal",
            "dependencies": [
              2
            ],
            "details": "Configurar FL Chart dependency en pubspec.yaml. Implementar LineChart para mostrar progreso de ayunos en últimos 7/30 días. Crear BarChart para comparar objetivos vs resultados. Personalizar colores y estilos según diseño de la app.",
            "status": "pending",
            "testStrategy": "Widget tests para gráficos y verificar datos de entrada correctos"
          },
          {
            "id": 4,
            "title": "Crear cards visuales con iconografía motivacional",
            "description": "Desarrollar tarjetas visuales que muestren logros y estadísticas destacadas",
            "dependencies": [
              2
            ],
            "details": "Implementar AchievementCard para mostrar mejor racha personal y ayuno más largo. Añadir iconos motivacionales usando Flutter Icons o assets personalizados. Crear animaciones sutiles para feedback visual. Implementar gradientes y sombras para mejor apariencia.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar rendering de cards y animaciones básicas"
          },
          {
            "id": 5,
            "title": "Configurar refresh automático de datos",
            "description": "Implementar sistema de actualización automática de métricas en tiempo real",
            "dependencies": [
              3,
              4
            ],
            "details": "Usar StreamBuilder o Riverpod para escuchar cambios en datos de métricas. Implementar RefreshIndicator para pull-to-refresh manual. Configurar Timer periódico para updates automáticos cada 30 segundos. Manejar estados de loading y error apropiadamente.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar updates automáticos y manual refresh"
          },
          {
            "id": 6,
            "title": "Optimizar performance de gráficos",
            "description": "Implementar optimizaciones para mejorar rendimiento de FL Chart y widgets complejos",
            "dependencies": [
              3,
              5
            ],
            "details": "Implementar lazy loading para gráficos complejos. Usar RepaintBoundary para aislar repaints. Configurar caching de datos calculados. Optimizar actualizaciones usando shouldRebuild y memo en Riverpod. Implementar debouncing para updates frecuentes.",
            "status": "pending",
            "testStrategy": "Performance tests para medir frame rate y memory usage durante scrolling"
          },
          {
            "id": 7,
            "title": "Testing integral de componentes del dashboard",
            "description": "Crear suite completa de tests para validar funcionalidad del dashboard de métricas",
            "dependencies": [
              6
            ],
            "details": "Implementar integration tests que verifiquen flujo completo desde carga de datos hasta rendering. Crear golden tests para verificar UI consistency. Probar edge cases como datos vacíos, errores de red y estado offline. Validar accesibilidad con semantics.",
            "status": "pending",
            "testStrategy": "Integration tests completos, golden tests y tests de accesibilidad"
          }
        ]
      },
      {
        "id": 27,
        "title": "Crear calendario con heatmap de ayunos",
        "description": "Implementar vista de calendario visual mostrando historial de sesiones",
        "details": "Usar table_calendar package para base de calendario. Implementar colores: verde = completado, naranja = interrumpido, gris = sin sesión. Añadir detalles al tocar día específico. Implementar navegación por meses. Mostrar estadísticas del mes actual.",
        "testStrategy": "UI tests para navegación de calendario. Verificar colores correctos por tipo de sesión. Probar detalles al tocar días.",
        "priority": "low",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrar table_calendar package",
            "description": "Instalar y configurar el paquete table_calendar como base del widget de calendario",
            "dependencies": [],
            "details": "Añadir table_calendar a pubspec.yaml. Crear widget CalendarPage básico con TableCalendar. Configurar formato de fechas en español. Establecer rango de fechas válidas. Implementar controlador de calendario inicial.",
            "status": "pending",
            "testStrategy": "Verificar renderizado correcto del calendario. Probar navegación básica entre meses."
          },
          {
            "id": 2,
            "title": "Implementar sistema de colores por estado",
            "description": "Crear mapeo de colores según el estado de las sesiones de ayuno",
            "dependencies": [
              1
            ],
            "details": "Definir enum FastingSessionStatus. Crear mapa de colores: verde para completado, naranja para interrumpido, gris para sin sesión. Implementar función getColorForDay que consulte historial de sesiones. Aplicar colores en calendarBuilders de table_calendar.",
            "status": "pending",
            "testStrategy": "Verificar colores correctos para cada tipo de estado. Probar días sin datos."
          },
          {
            "id": 3,
            "title": "Configurar detalles al tocar días",
            "description": "Implementar funcionalidad para mostrar información detallada al seleccionar un día específico",
            "dependencies": [
              2
            ],
            "details": "Implementar onDaySelected callback. Crear widget DayDetailDialog que muestre duración de ayuno, hora inicio/fin, estado de sesión. Consultar datos de Isar para día seleccionado. Manejar casos de días sin sesiones.",
            "status": "pending",
            "testStrategy": "Probar apertura de detalles al tocar días. Verificar datos correctos mostrados. Confirmar manejo de días vacíos."
          },
          {
            "id": 4,
            "title": "Implementar navegación por meses",
            "description": "Configurar navegación fluida entre diferentes meses del calendario",
            "dependencies": [
              1
            ],
            "details": "Configurar calendarController para navegación por meses. Implementar botones de navegación anterior/siguiente mes. Añadir indicador del mes actual. Optimizar carga de datos por mes visible. Implementar lazy loading de sesiones por rango de fechas.",
            "status": "pending",
            "testStrategy": "Verificar navegación suave entre meses. Probar carga correcta de datos por mes. Confirmar indicadores visuales."
          },
          {
            "id": 5,
            "title": "Calcular estadísticas mensuales",
            "description": "Implementar cálculo y visualización de estadísticas del mes actual",
            "dependencies": [
              2,
              4
            ],
            "details": "Crear FastingStatsService para calcular estadísticas mensuales. Calcular total de días de ayuno, promedio de duración, streak actual, días completados vs interrumpidos. Mostrar estadísticas en header del calendario. Actualizar estadísticas al cambiar de mes.",
            "status": "pending",
            "testStrategy": "Verificar cálculos correctos de estadísticas. Probar actualización al cambiar mes. Confirmar manejo de meses sin datos."
          },
          {
            "id": 6,
            "title": "Optimizar performance para datasets grandes",
            "description": "Implementar optimizaciones para manejar eficientemente grandes volúmenes de datos históricos",
            "dependencies": [
              3,
              5
            ],
            "details": "Implementar paginación de datos por mes. Crear cache en memoria para meses frecuentemente visitados. Optimizar queries de Isar con índices por fecha. Implementar debouncing para navegación rápida. Configurar lazy loading de detalles de sesiones.",
            "status": "pending",
            "testStrategy": "Probar performance con datasets grandes. Verificar uso eficiente de memoria. Confirmar respuesta fluida en navegación."
          },
          {
            "id": 7,
            "title": "Testing de navegación y funcionalidad",
            "description": "Crear suite completa de tests para validar toda la funcionalidad del calendario",
            "dependencies": [
              6
            ],
            "details": "Crear widget tests para CalendarPage. Probar navegación entre meses. Verificar colores correctos por estado. Testear apertura de detalles al tocar días. Probar cálculo de estadísticas. Crear tests de integración con FastingSessionRepository.",
            "status": "pending",
            "testStrategy": "Suite completa de widget tests. Integration tests con repositorio. Performance tests con datos simulados grandes."
          }
        ]
      },
      {
        "id": 28,
        "title": "Implementar análisis de patrones de usuario",
        "description": "Crear insights automáticos sobre mejores días/horarios para ayunar",
        "details": "Implementar PatternAnalysisService que analice datos históricos. Identificar días de semana con mayor tasa de éxito. Detectar horarios de inicio más exitosos. Generar insights como 'Completas 80% de ayunos que empiezas lunes por la mañana'. Mostrar sugerencias personalizadas.",
        "testStrategy": "Unit tests para algoritmos de análisis. Verificar insights con datos de muestra. Probar precisión de recomendaciones.",
        "priority": "low",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar PatternAnalysisService base",
            "description": "Crear la estructura base del servicio de análisis de patrones con métodos principales y configuración inicial",
            "dependencies": [],
            "details": "Crear clase PatternAnalysisService con métodos analyzeWeeklyPatterns, analyzeTimePatterns, generateInsights. Configurar inyección de dependencias con repositorios de ayuno. Implementar estructura de datos para almacenar insights calculados.",
            "status": "pending",
            "testStrategy": "Unit tests para estructura base del servicio y métodos de inicialización"
          },
          {
            "id": 2,
            "title": "Desarrollar algoritmo de análisis de días exitosos",
            "description": "Implementar lógica para identificar qué días de la semana tienen mayor tasa de éxito en ayunos",
            "dependencies": [
              1
            ],
            "details": "Crear algoritmo que analice datos históricos agrupados por día de la semana. Calcular tasas de éxito, duración promedio y consistencia. Implementar umbral mínimo de datos para insights confiables (ej: mínimo 5 ayunos por día).",
            "status": "pending",
            "testStrategy": "Unit tests con datasets de muestra para verificar cálculo correcto de tasas de éxito por día"
          },
          {
            "id": 3,
            "title": "Crear análisis de horarios óptimos de inicio",
            "description": "Desarrollar algoritmo para detectar las horas de inicio más exitosas para comenzar ayunos",
            "dependencies": [
              1
            ],
            "details": "Implementar análisis temporal que agrupe ayunos por hora de inicio (franjas de 2-3 horas). Calcular métricas de éxito y duración promedio por franja horaria. Considerar contexto de días laborables vs fines de semana.",
            "status": "pending",
            "testStrategy": "Verificar agrupación correcta por franjas horarias y cálculo de métricas de éxito"
          },
          {
            "id": 4,
            "title": "Implementar generador de insights personalizados",
            "description": "Crear sistema que genere mensajes de insights automáticos basados en patrones detectados",
            "dependencies": [
              2,
              3
            ],
            "details": "Desarrollar templates de mensajes personalizados como 'Completas 80% de ayunos que empiezas lunes por la mañana'. Implementar lógica de priorización de insights más relevantes. Configurar umbrales mínimos para mostrar insights (ej: >70% tasa éxito).",
            "status": "pending",
            "testStrategy": "Validar generación correcta de mensajes y filtrado por relevancia estadística"
          },
          {
            "id": 5,
            "title": "Configurar machine learning básico para detección de patrones",
            "description": "Implementar algoritmos ML simples para identificar patrones complejos en comportamiento de ayuno",
            "dependencies": [
              1
            ],
            "details": "Integrar biblioteca ML (como ML Kit o TensorFlow Lite). Implementar clustering simple para identificar perfiles de usuario. Crear modelo predictivo básico para recomendar mejores momentos para ayunar basado en historial personal.",
            "status": "pending",
            "testStrategy": "Probar algoritmos con datasets diversos y validar precisión de predicciones"
          },
          {
            "id": 6,
            "title": "Optimizar consultas de base de datos para análisis",
            "description": "Crear consultas eficientes para recuperar y analizar grandes volúmenes de datos históricos",
            "dependencies": [
              1
            ],
            "details": "Implementar queries optimizadas en Isar para agregaciones por período temporal. Crear índices específicos para consultas de análisis. Implementar paginación para datasets grandes y lazy loading de datos históricos.",
            "status": "pending",
            "testStrategy": "Performance tests para verificar tiempo de respuesta con grandes volúmenes de datos"
          },
          {
            "id": 7,
            "title": "Implementar sistema de cache para insights",
            "description": "Crear cache inteligente para almacenar insights calculados y reducir carga computacional",
            "dependencies": [
              4
            ],
            "details": "Implementar cache en memoria con TTL configurable para insights. Crear sistema de invalidación cuando se agregan nuevos datos de ayuno. Implementar persistencia de cache para acceso offline y startup más rápido.",
            "status": "pending",
            "testStrategy": "Verificar invalidación correcta de cache y persistencia entre sesiones de app"
          },
          {
            "id": 8,
            "title": "Testing exhaustivo de algoritmos con datos diversos",
            "description": "Crear suite de tests completa con datasets variados para validar robustez de algoritmos",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Generar datasets de prueba con diferentes patrones: usuarios consistentes, inconsistentes, nuevos usuarios. Probar edge cases como pocos datos, cambios de hábitos, diferentes zonas horarias. Implementar tests de regresión para algoritmos.",
            "status": "pending",
            "testStrategy": "Integration tests con múltiples perfiles de usuario y validación de edge cases"
          },
          {
            "id": 9,
            "title": "Validar precisión de recomendaciones generadas",
            "description": "Implementar sistema de validación y métricas para medir precisión de insights y recomendaciones",
            "dependencies": [
              4,
              8
            ],
            "details": "Crear métricas de precisión para insights generados (ej: porcentaje de predicciones correctas). Implementar sistema de feedback del usuario para validar utilidad de recomendaciones. Configurar logging para análisis de precisión en producción.",
            "status": "pending",
            "testStrategy": "Verificar cálculo correcto de métricas de precisión y sistema de feedback"
          },
          {
            "id": 10,
            "title": "Configurar updates periódicos automáticos",
            "description": "Implementar sistema de actualización automática de análisis y regeneración de insights",
            "dependencies": [
              7,
              9
            ],
            "details": "Configurar cron jobs o WorkManager para recálculo periódico de insights (diario/semanal). Implementar estrategia incremental para procesar solo datos nuevos. Configurar notificaciones cuando hay nuevos insights relevantes disponibles.",
            "status": "pending",
            "testStrategy": "Verificar ejecución correcta de updates periódicos y estrategia incremental"
          }
        ]
      },
      {
        "id": 29,
        "title": "Crear modelos para contenido educativo",
        "description": "Implementar estructura de datos para artículos, videos y estudios",
        "details": "Crear ContentItem model con campos: id, title, contentType, category, contentUrl, thumbnailUrl, description, isPremium. Configurar categorías: basics, science, tips, success_stories. Implementar sistema de favoritos. Configurar sincronización con Supabase y cache local para offline.",
        "testStrategy": "Unit tests para model serialization. Verificar cache offline. Probar sistema de favoritos con persistencia.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir modelo ContentItem con campos específicos",
            "description": "Crear la clase ContentItem con todos los campos requeridos: id, title, contentType, category, contentUrl, thumbnailUrl, description, isPremium",
            "dependencies": [],
            "details": "Implementar clase ContentItem en Dart con validaciones apropiadas para cada campo. Incluir serialización JSON y mapeo a base de datos local. Definir tipos de datos correctos y restricciones de validación.",
            "status": "pending",
            "testStrategy": "Unit tests para validación de campos y serialización JSON"
          },
          {
            "id": 2,
            "title": "Configurar categorías y tipos de contenido",
            "description": "Implementar sistema de categorización con las categorías definidas: basics, science, tips, success_stories",
            "dependencies": [
              1
            ],
            "details": "Crear enum para ContentCategory con valores: basics, science, tips, success_stories. Implementar enum para ContentType (artículo, video, estudio). Añadir validaciones y métodos helper para categorización.",
            "status": "pending",
            "testStrategy": "Unit tests para validación de categorías y conversión de tipos"
          },
          {
            "id": 3,
            "title": "Implementar sistema de favoritos",
            "description": "Crear funcionalidad para que usuarios puedan marcar contenido como favorito",
            "dependencies": [
              1
            ],
            "details": "Implementar FavoriteContent model con relación a ContentItem. Crear métodos para añadir/quitar favoritos. Implementar persistencia local y sincronización con backend. Incluir validaciones de duplicados.",
            "status": "pending",
            "testStrategy": "Unit tests para operaciones de favoritos y verificar persistencia"
          },
          {
            "id": 4,
            "title": "Configurar sincronización con Supabase",
            "description": "Establecer conexión y sincronización bidireccional con la base de datos Supabase",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar SupabaseContentRepository con métodos CRUD. Configurar tablas en Supabase para content_items y favorites. Implementar sincronización automática y manejo de conflictos. Añadir autenticación requerida.",
            "status": "pending",
            "testStrategy": "Integration tests para operaciones CRUD y sincronización"
          },
          {
            "id": 5,
            "title": "Implementar cache local para funcionamiento offline",
            "description": "Crear sistema de cache que permita acceso al contenido sin conexión a internet",
            "dependencies": [
              1,
              4
            ],
            "details": "Implementar LocalContentCache usando Isar para almacenamiento local. Crear estrategia de cache con TTL. Implementar sincronización automática cuando hay conectividad. Manejar estado offline/online.",
            "status": "pending",
            "testStrategy": "Unit tests para cache offline y verificar sincronización automática"
          },
          {
            "id": 6,
            "title": "Testing integral de serialización y favoritos",
            "description": "Crear suite completa de tests para validar toda la funcionalidad del sistema de contenido educativo",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implementar tests de integración que verifiquen serialización JSON, persistencia de favoritos, sincronización con Supabase, y funcionamiento offline. Incluir tests de performance y manejo de errores.",
            "status": "pending",
            "testStrategy": "Integration tests completos y tests de performance para todo el sistema"
          }
        ]
      },
      {
        "id": 30,
        "title": "Implementar ContentService para manejo de biblioteca",
        "description": "Crear servicio para fetch, cache y gestión de contenido educativo",
        "details": "Implementar ContentService con métodos: fetchContent, cacheForOffline, toggleFavorite, searchContent. Configurar estrategia de cache: artículos completos offline, videos solo metadata. Implementar search local en título y descripción. Manejar refresh periódico de contenido.",
        "testStrategy": "Integration tests para fetch de contenido. Verificar cache offline funcional. Probar búsqueda local.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar métodos core de ContentService",
            "description": "Crear la clase ContentService con métodos fetchContent, cacheForOffline, toggleFavorite y searchContent",
            "dependencies": [],
            "details": "Implementar la estructura base de ContentService con métodos fetchContent para obtener contenido del servidor, cacheForOffline para almacenamiento local, toggleFavorite para gestión de favoritos y searchContent para búsquedas locales. Definir interfaces y tipos necesarios.",
            "status": "pending",
            "testStrategy": "Unit tests para cada método del servicio"
          },
          {
            "id": 2,
            "title": "Configurar estrategia de cache diferencial",
            "description": "Implementar cache inteligente con estrategias diferentes para videos y artículos",
            "dependencies": [
              1
            ],
            "details": "Configurar cache para almacenar artículos completos offline incluyendo texto e imágenes, mientras que para videos solo almacenar metadata (título, descripción, thumbnail). Implementar lógica de decisión basada en tipo de contenido y tamaño.",
            "status": "pending",
            "testStrategy": "Tests de almacenamiento para verificar estrategias por tipo de contenido"
          },
          {
            "id": 3,
            "title": "Implementar búsqueda local optimizada",
            "description": "Crear sistema de búsqueda en título y descripción con indexación local",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar algoritmo de búsqueda local que indexe títulos y descripciones del contenido cached. Configurar búsqueda fuzzy tolerante a errores tipográficos. Optimizar performance para respuesta instantánea en búsquedas.",
            "status": "pending",
            "testStrategy": "Tests de performance y precisión de búsqueda local"
          },
          {
            "id": 4,
            "title": "Configurar refresh periódico de contenido",
            "description": "Implementar sistema de actualización automática del contenido",
            "dependencies": [
              1
            ],
            "details": "Configurar refresh automático cada 24-48 horas para mantener contenido actualizado. Implementar checks de conectividad y actualización inteligente solo de contenido modificado. Configurar refresh manual por pull-to-refresh.",
            "status": "pending",
            "testStrategy": "Tests de programación de refresh y manejo de conectividad"
          },
          {
            "id": 5,
            "title": "Optimizar storage para videos vs artículos",
            "description": "Implementar gestión inteligente del espacio de almacenamiento",
            "dependencies": [
              2
            ],
            "details": "Crear sistema de gestión de storage que limite automáticamente el espacio usado. Implementar limpieza automática de contenido más antiguo cuando se alcancen límites. Priorizar artículos sobre videos para cache offline.",
            "status": "pending",
            "testStrategy": "Tests de límites de storage y limpieza automática"
          },
          {
            "id": 6,
            "title": "Implementar manejo robusto de errores",
            "description": "Crear sistema completo de manejo de errores para todas las operaciones",
            "dependencies": [
              1
            ],
            "details": "Implementar manejo de errores para fallas de red, timeouts, errores de servidor y problemas de almacenamiento. Configurar retry logic con exponential backoff. Implementar fallbacks a cache local cuando el servidor no esté disponible.",
            "status": "pending",
            "testStrategy": "Tests de manejo de errores y recovery scenarios"
          },
          {
            "id": 7,
            "title": "Testing de funcionalidad offline",
            "description": "Crear suite completa de tests para operaciones offline",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Implementar integration tests que simulen condiciones offline. Verificar que búsqueda funcione solo con contenido cached. Probar sincronización cuando se recupere conectividad. Validar integridad de datos offline.",
            "status": "pending",
            "testStrategy": "Integration tests simulando scenarios offline completos"
          },
          {
            "id": 8,
            "title": "Validar performance de búsqueda",
            "description": "Optimizar y validar performance del sistema de búsqueda",
            "dependencies": [
              3,
              7
            ],
            "details": "Realizar benchmarks de performance de búsqueda con datasets grandes. Optimizar índices y algoritmos para respuesta sub-100ms. Implementar lazy loading de resultados. Configurar métricas de performance en producción.",
            "status": "pending",
            "testStrategy": "Performance tests y benchmarks de búsqueda con datasets grandes"
          }
        ]
      },
      {
        "id": 31,
        "title": "Diseñar LearningHomeScreen",
        "description": "Crear interfaz principal para navegación de contenido educativo",
        "details": "Implementar LearningHomeScreen con tabs por categoría. Diseñar cards de contenido con thumbnail, título, duración. Añadir indicadores premium y favoritos. Implementar búsqueda y filtros. Configurar infinite scroll para contenido extenso.",
        "testStrategy": "UI tests para navegación por categorías. Verificar infinite scroll. Probar funcionalidad de búsqueda.",
        "priority": "medium",
        "dependencies": [
          30
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar tabs por categoría en LearningHomeScreen",
            "description": "Crear sistema de navegación por tabs para las diferentes categorías de contenido educativo",
            "dependencies": [],
            "details": "Implementar TabBar con categorías: basics, science, tips, success_stories. Configurar TabBarView para mostrar contenido filtrado por categoría. Añadir indicadores visuales de tab activo y transiciones suaves entre categorías.",
            "status": "pending",
            "testStrategy": "Widget tests para navegación por tabs. Verificar filtrado correcto de contenido por categoría."
          },
          {
            "id": 2,
            "title": "Diseñar cards de contenido con thumbnails",
            "description": "Crear componente de card para mostrar contenido educativo con imagen, título y duración",
            "dependencies": [
              1
            ],
            "details": "Implementar ContentCard widget con thumbnail (AspectRatio 16:9), título truncado, duración formateada, y categoría badge. Configurar diseño responsivo y sombras elevation. Añadir gesture detection para navegación al detalle.",
            "status": "pending",
            "testStrategy": "Widget tests para renderizado de cards. Verificar responsive design en diferentes tamaños de pantalla."
          },
          {
            "id": 3,
            "title": "Implementar indicadores premium y favoritos",
            "description": "Añadir marcadores visuales para contenido premium y sistema de favoritos",
            "dependencies": [
              2
            ],
            "details": "Crear indicadores premium con iconos crown y gradientes dorados. Implementar botón de favoritos con animación heart. Configurar persistencia local de favoritos usando SharedPreferences. Añadir filtro para mostrar solo favoritos.",
            "status": "pending",
            "testStrategy": "Unit tests para persistencia de favoritos. Widget tests para indicadores visuales premium."
          },
          {
            "id": 4,
            "title": "Configurar búsqueda y filtros de contenido",
            "description": "Implementar barra de búsqueda y sistema de filtros para contenido educativo",
            "dependencies": [
              1
            ],
            "details": "Crear SearchBar con debounce de 300ms. Implementar filtros por tipo de contenido (artículo/video), duración, y nivel de dificultad. Configurar search delegate para resultados en tiempo real. Añadir historial de búsquedas recientes.",
            "status": "pending",
            "testStrategy": "Unit tests para lógica de búsqueda y filtrado. Widget tests para interacción de SearchBar."
          },
          {
            "id": 5,
            "title": "Implementar infinite scroll para contenido extenso",
            "description": "Configurar carga paginada de contenido con scroll infinito",
            "dependencies": [
              2,
              4
            ],
            "details": "Implementar ListView.builder con pagination. Configurar carga de 20 items por página con loading indicator. Añadir pull-to-refresh functionality. Implementar cache de imágenes y manejo de errores de carga.",
            "status": "pending",
            "testStrategy": "Integration tests para infinite scroll. Performance tests para carga de listas grandes."
          },
          {
            "id": 6,
            "title": "Optimizar performance para listas grandes",
            "description": "Implementar optimizaciones de rendimiento para manejo eficiente de contenido extenso",
            "dependencies": [
              5
            ],
            "details": "Configurar AutomaticKeepAliveClientMixin para tabs. Implementar lazy loading de thumbnails con cached_network_image. Optimizar rebuild con const constructors y RepaintBoundary. Añadir memory management para evitar leaks.",
            "status": "pending",
            "testStrategy": "Performance tests para memory usage. Verificar smooth scrolling en dispositivos de gama baja."
          },
          {
            "id": 7,
            "title": "Testing de navegación y búsqueda completa",
            "description": "Realizar testing integral de funcionalidades de navegación y búsqueda",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Crear integration tests para flujo completo de navegación por categorías, búsqueda, filtrado y selección de contenido. Verificar funcionamiento offline con cache. Probar accessibility features y navigation semantics.",
            "status": "pending",
            "testStrategy": "Integration tests end-to-end. Accessibility tests para screen readers. Performance tests en diferentes dispositivos."
          }
        ]
      },
      {
        "id": 32,
        "title": "Integrar reproductor de YouTube",
        "description": "Implementar reproducción de videos educativos con youtube_player_flutter",
        "details": "Configurar youtube_player_flutter package. Crear VideoPlayerScreen para reproducción in-app. Implementar fallback a browser para casos de error. Añadir controles de video y fullscreen. Manejar orientación automática para videos.",
        "testStrategy": "Integration tests para reproducción de video. Verificar fallback a browser. Probar controles y fullscreen en iOS/Android.",
        "priority": "low",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar youtube_player_flutter package",
            "description": "Añadir youtube_player_flutter al pubspec.yaml y configurar las dependencias necesarias",
            "dependencies": [],
            "details": "Instalar youtube_player_flutter package versión más reciente. Configurar permisos en AndroidManifest.xml e Info.plist para iOS. Verificar compatibilidad con la versión actual de Flutter del proyecto.",
            "status": "pending",
            "testStrategy": "Verificar que flutter pub get ejecute sin errores y que las importaciones del package funcionen correctamente"
          },
          {
            "id": 2,
            "title": "Crear VideoPlayerScreen básica",
            "description": "Implementar la pantalla principal para reproducción de videos de YouTube",
            "dependencies": [
              1
            ],
            "details": "Crear VideoPlayerScreen con YoutubePlayer widget. Implementar inicialización del controlador con video ID. Configurar estructura básica de la UI con contenedor para el reproductor.",
            "status": "pending",
            "testStrategy": "Widget tests para verificar que la pantalla se renderice correctamente y que el reproductor se inicialice sin errores"
          },
          {
            "id": 3,
            "title": "Implementar fallback a browser",
            "description": "Crear sistema de fallback que abra videos en el navegador cuando el reproductor in-app falle",
            "dependencies": [
              2
            ],
            "details": "Implementar manejo de errores del YoutubePlayer. Crear función para abrir URLs de YouTube en el navegador del sistema usando url_launcher. Añadir UI para informar al usuario sobre el fallback.",
            "status": "pending",
            "testStrategy": "Simular errores de reproducción y verificar que el fallback a browser funcione correctamente en iOS y Android"
          },
          {
            "id": 4,
            "title": "Configurar controles de video personalizados",
            "description": "Implementar controles de reproducción play/pausa, volumen y barra de progreso",
            "dependencies": [
              2
            ],
            "details": "Customizar controles del YoutubePlayer. Implementar botones de play/pausa, control de volumen, barra de progreso con seek functionality. Añadir overlay de controles con auto-hide después de inactividad.",
            "status": "pending",
            "testStrategy": "Tests de interacción para verificar que todos los controles respondan correctamente y que el auto-hide funcione"
          },
          {
            "id": 5,
            "title": "Implementar modo fullscreen",
            "description": "Configurar reproducción en pantalla completa con transiciones suaves",
            "dependencies": [
              4
            ],
            "details": "Implementar toggle de fullscreen usando YoutubePlayerController. Configurar SystemChrome para ocultar status bar en fullscreen. Manejar transiciones de UI entre modo normal y fullscreen.",
            "status": "pending",
            "testStrategy": "Verificar transiciones suaves entre modos normal y fullscreen en diferentes tamaños de pantalla"
          },
          {
            "id": 6,
            "title": "Manejar orientación automática",
            "description": "Implementar cambio automático de orientación al entrar/salir de fullscreen",
            "dependencies": [
              5
            ],
            "details": "Configurar auto-rotación a landscape al entrar en fullscreen y vuelta a portrait al salir. Usar SystemChrome.setPreferredOrientations para controlar orientación. Manejar casos edge como rotación manual del dispositivo.",
            "status": "pending",
            "testStrategy": "Probar rotación automática en diferentes dispositivos y verificar que la orientación se restaure correctamente"
          },
          {
            "id": 7,
            "title": "Implementar testing multiplataforma",
            "description": "Crear suite de tests para verificar funcionamiento en iOS y Android",
            "dependencies": [
              6
            ],
            "details": "Desarrollar integration tests específicos para cada plataforma. Verificar reproducción de video, controles, fullscreen y fallback en iOS y Android. Incluir tests para diferentes resoluciones de pantalla.",
            "status": "pending",
            "testStrategy": "Integration tests automatizados que verifiquen funcionalidad completa en simuladores iOS y emuladores Android"
          },
          {
            "id": 8,
            "title": "Optimizar manejo de memoria y errores",
            "description": "Implementar gestión eficiente de memoria y manejo robusto de errores de reproducción",
            "dependencies": [
              7
            ],
            "details": "Implementar dispose correcto de YoutubePlayerController. Añadir manejo de errores de red, videos no disponibles y restricciones geográficas. Optimizar memory usage durante reproducción prolongada.",
            "status": "pending",
            "testStrategy": "Memory profiling para verificar que no hay leaks. Tests de error handling para diferentes tipos de fallos de reproducción"
          }
        ]
      },
      {
        "id": 33,
        "title": "Crear visor de artículos offline",
        "description": "Implementar pantalla para lectura de artículos con soporte offline",
        "details": "Diseñar ArticleViewerScreen con WebView para contenido HTML. Implementar cache de artículos para lectura offline. Añadir controles de tamaño de fuente y modo noche. Configurar scroll progress indicator. Implementar sharing de artículos.",
        "testStrategy": "Verificar lectura offline de artículos cacheados. Probar controles de fuente. Confirmar sharing functionality.",
        "priority": "low",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar ArticleViewerScreen con WebView",
            "description": "Crear la pantalla principal del visor de artículos utilizando WebView para mostrar contenido HTML",
            "dependencies": [],
            "details": "Crear ArticleViewerScreen como StatefulWidget. Configurar WebView con webview_flutter package. Implementar loading state y error handling. Configurar JavaScript habilitado para interactividad. Añadir AppBar con título del artículo y botones de navegación.",
            "status": "pending",
            "testStrategy": "Unit tests para inicialización del WebView. Widget tests para estados de loading y error. Verificar renderizado correcto de contenido HTML."
          },
          {
            "id": 2,
            "title": "Configurar cache de artículos para lectura offline",
            "description": "Implementar sistema de cache que permita almacenar artículos localmente para acceso sin conexión",
            "dependencies": [
              1
            ],
            "details": "Crear ArticleCacheService usando Isar para persistencia. Implementar métodos: cacheArticle, getCachedArticle, removeCachedArticle. Configurar cache automático al abrir artículos. Implementar límite de cache (ej: 50 artículos) con LRU eviction. Manejar actualización de artículos cacheados.",
            "status": "pending",
            "testStrategy": "Unit tests para operaciones de cache. Integration tests para verificar funcionamiento offline. Probar límites de cache y eviction policy."
          },
          {
            "id": 3,
            "title": "Implementar controles de tamaño de fuente y modo noche",
            "description": "Añadir controles de accesibilidad para ajustar el tamaño de fuente y alternar modo oscuro",
            "dependencies": [
              1
            ],
            "details": "Crear bottom sheet con controles de fuente (pequeña, mediana, grande, extra grande). Implementar toggle para modo noche/día. Persistir preferencias en SharedPreferences. Inyectar CSS dinámico en WebView para aplicar cambios. Configurar transiciones suaves entre modos.",
            "status": "pending",
            "testStrategy": "Widget tests para controles de UI. Verificar persistencia de preferencias. Probar aplicación correcta de estilos CSS en WebView."
          },
          {
            "id": 4,
            "title": "Crear indicador de progreso de scroll",
            "description": "Implementar barra de progreso que muestre el avance de lectura del artículo",
            "dependencies": [
              1
            ],
            "details": "Implementar LinearProgressIndicator en AppBar que refleje posición de scroll. Usar WebView controller para obtener scroll position y content height. Calcular porcentaje de progreso de lectura. Añadir smooth animations para transiciones. Configurar auto-hide cuando no hay scroll activo.",
            "status": "pending",
            "testStrategy": "Widget tests para indicador de progreso. Verificar cálculos correctos de porcentaje. Probar behavior con diferentes tamaños de contenido."
          },
          {
            "id": 5,
            "title": "Implementar funcionalidad de sharing de artículos",
            "description": "Añadir capacidad para compartir artículos a través de diferentes plataformas",
            "dependencies": [
              1
            ],
            "details": "Integrar share_plus package para sharing nativo. Crear ShareService con métodos: shareArticle, shareWithText, shareWithLink. Añadir botón de share en AppBar. Configurar diferentes opciones: texto plano, link, con imagen preview. Manejar sharing de artículos offline con metadata local.",
            "status": "pending",
            "testStrategy": "Integration tests para sharing functionality. Verificar diferentes formatos de share. Probar sharing de artículos cacheados offline."
          },
          {
            "id": 6,
            "title": "Implementar testing de lectura offline",
            "description": "Crear suite de tests completa para verificar funcionalidad offline del visor",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Crear integration tests que simulen estado offline. Verificar carga de artículos desde cache cuando no hay conexión. Probar persistencia de preferencias de fuente y modo noche offline. Validar funcionamiento de progress indicator sin conexión. Confirmar que sharing funciona con contenido cacheado.",
            "status": "pending",
            "testStrategy": "Integration tests con mock de conectividad. Verificar todos los features en modo offline. Probar recuperación cuando vuelve conexión."
          },
          {
            "id": 7,
            "title": "Optimizar performance del WebView",
            "description": "Implementar optimizaciones para mejorar velocidad de carga y fluidez del WebView",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar caching strategy del WebView. Implementar lazy loading de imágenes en contenido HTML. Optimizar CSS injection para reducir reflows. Configurar WebView settings para performance: enableZoom=false, geolocation=false. Implementar preloading de artículos frecuentemente accedidos. Añadir compression para contenido cacheado.",
            "status": "pending",
            "testStrategy": "Performance tests para tiempo de carga. Memory tests para usage optimization. Verificar smooth scrolling y responsiveness de UI."
          }
        ]
      },
      {
        "id": 34,
        "title": "Implementar modelo de perfil de usuario",
        "description": "Crear UserProfile model para configuración y datos personales",
        "details": "Crear UserProfile model con campos: id, email, weight_kg, height_cm, daily_hydration_goal, theme_preference, notification_settings. Implementar validaciones y computed properties. Configurar sincronización bidireccional Isar-Supabase.",
        "testStrategy": "Unit tests para validaciones de datos. Verificar cálculos automáticos (hidratación). Probar sincronización bidireccional.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir estructura del UserProfile model",
            "description": "Crear la clase UserProfile con todos los campos requeridos y tipos de datos apropiados",
            "dependencies": [],
            "details": "Definir UserProfile class con campos: id (String), email (String), weight_kg (double), height_cm (double), daily_hydration_goal (int), theme_preference (enum), notification_settings (Map<String, bool>). Configurar anotaciones Isar y Supabase.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar estructura correcta de campos y tipos de datos"
          },
          {
            "id": 2,
            "title": "Implementar validaciones de datos",
            "description": "Crear sistema de validación para todos los campos del UserProfile",
            "dependencies": [
              1
            ],
            "details": "Implementar validaciones: email formato válido, weight_kg > 0 y < 300, height_cm > 50 y < 250, daily_hydration_goal > 0 y < 8000ml. Crear métodos validate() y getValidationErrors().",
            "status": "pending",
            "testStrategy": "Unit tests para cada validación con casos límite y valores inválidos"
          },
          {
            "id": 3,
            "title": "Desarrollar computed properties",
            "description": "Implementar propiedades calculadas como BMI y recomendaciones automáticas",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear computed properties: BMI calculation (weight / (height^2)), recommended daily hydration basado en peso y actividad, caloric needs estimation. Implementar getters que calculen en tiempo real.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar precisión de cálculos automáticos y fórmulas"
          },
          {
            "id": 4,
            "title": "Configurar persistencia en Isar",
            "description": "Implementar almacenamiento local del UserProfile usando Isar database",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar Isar collection para UserProfile. Implementar métodos: save(), findById(), update(), delete(). Configurar índices para búsquedas eficientes. Manejar migrations de schema.",
            "status": "pending",
            "testStrategy": "Integration tests para CRUD operations y verificar persistencia local"
          },
          {
            "id": 5,
            "title": "Implementar sincronización con Supabase",
            "description": "Configurar sync bidireccional entre Isar local y Supabase remoto",
            "dependencies": [
              4
            ],
            "details": "Implementar UserProfileService con métodos: syncToServer(), syncFromServer(), handleConflicts(). Configurar auto-sync en app foreground. Implementar conflict resolution strategy (last-write-wins con timestamps).",
            "status": "pending",
            "testStrategy": "Integration tests para sync bidireccional y resolución de conflictos"
          },
          {
            "id": 6,
            "title": "Testing integral y verificación final",
            "description": "Ejecutar suite completa de tests y verificar funcionamiento end-to-end",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Ejecutar todos los unit tests y integration tests. Verificar sync completo offline-online. Probar validaciones en escenarios reales. Verificar computed properties con datos de prueba. Confirmar persistencia tras restart de app.",
            "status": "pending",
            "testStrategy": "End-to-end testing del modelo completo y verificación de sincronización"
          }
        ]
      },
      {
        "id": 35,
        "title": "Crear ProfileScreen para configuración",
        "description": "Implementar pantalla de configuración de perfil y preferencias",
        "details": "Diseñar ProfileScreen con secciones: datos personales, preferencias de tema, configuración de notificaciones, gestión de cuenta. Implementar formularios para editar peso/altura. Añadir toggle para tema claro/oscuro. Configurar logout y delete account.",
        "testStrategy": "UI tests para formularios de edición. Verificar persistencia de cambios. Probar logout y eliminación de cuenta.",
        "priority": "medium",
        "dependencies": [
          34
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar estructura y layout de ProfileScreen",
            "description": "Crear el diseño base de la pantalla de perfil con las secciones organizadas: datos personales, preferencias de tema, notificaciones y gestión de cuenta",
            "dependencies": [],
            "details": "Implementar scaffold con AppBar personalizado, crear widgets para cada sección usando Cards o Containers, definir la navegación entre secciones y establecer el layout responsivo para diferentes tamaños de pantalla",
            "status": "pending",
            "testStrategy": "Tests de widget para verificar que todas las secciones se rendericen correctamente y respondan a diferentes tamaños de pantalla"
          },
          {
            "id": 2,
            "title": "Implementar formularios para datos personales",
            "description": "Crear formularios para editar información personal del usuario como peso, altura y otros datos del perfil",
            "dependencies": [
              1
            ],
            "details": "Desarrollar TextFormFields con validación para peso y altura, implementar picker widgets para selección de unidades (kg/lbs, cm/ft), crear controladores de formulario y manejar la validación en tiempo real",
            "status": "pending",
            "testStrategy": "Unit tests para validación de formularios y tests de integración para verificar guardado de datos personales"
          },
          {
            "id": 3,
            "title": "Configurar toggle de tema claro/oscuro",
            "description": "Implementar switch para alternar entre tema claro y oscuro de la aplicación",
            "dependencies": [
              1
            ],
            "details": "Crear widget Switch personalizado, conectar con el provider de tema de la aplicación, implementar persistencia de la preferencia usando SharedPreferences y aplicar cambios de tema en tiempo real",
            "status": "pending",
            "testStrategy": "Tests para verificar cambio de tema funciona correctamente y persiste entre sesiones de la app"
          },
          {
            "id": 4,
            "title": "Implementar configuración de notificaciones",
            "description": "Crear sección para gestionar preferencias de notificaciones push y recordatorios",
            "dependencies": [
              1
            ],
            "details": "Desarrollar switches para diferentes tipos de notificaciones (recordatorios de ayuno, hidratación, etc.), integrar con OneSignal para gestión de push notifications y implementar horarios personalizados para recordatorios",
            "status": "pending",
            "testStrategy": "Tests de integración para verificar que las preferencias de notificaciones se guarden y apliquen correctamente"
          },
          {
            "id": 5,
            "title": "Configurar funcionalidades de logout y eliminación de cuenta",
            "description": "Implementar opciones para cerrar sesión y eliminar cuenta del usuario de forma segura",
            "dependencies": [
              1
            ],
            "details": "Crear botones con confirmación para logout y delete account, implementar diálogos de confirmación con advertencias, limpiar datos locales en logout y gestionar eliminación completa de datos en delete account",
            "status": "pending",
            "testStrategy": "Tests de seguridad para verificar limpieza completa de datos y confirmación adecuada antes de acciones destructivas"
          },
          {
            "id": 6,
            "title": "Testing de persistencia y integración completa",
            "description": "Realizar testing integral de la pantalla de perfil y verificar persistencia de todos los cambios realizados",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Ejecutar tests end-to-end de la pantalla completa, verificar que todos los cambios se persistan correctamente, probar navegación entre secciones y validar que la UX sea fluida y consistente",
            "status": "pending",
            "testStrategy": "Tests E2E completos para verificar flujo completo de configuración de perfil y persistencia de datos entre sesiones"
          }
        ]
      },
      {
        "id": 36,
        "title": "Implementar toggle de tema claro/oscuro",
        "description": "Crear sistema de cambio dinámico entre temas con persistencia",
        "details": "Implementar ThemeModeProvider con opciones: light, dark, system. Crear ThemeToggle widget con SegmentedButton. Configurar persistencia en SharedPreferences. Implementar detección automática de tema del sistema. Asegurar contraste WCAG 2.1 AA en ambos modos.",
        "testStrategy": "Verificar persistencia de preferencia tras restart. Probar detección automática de tema del sistema. Validar contraste en ambos modos.",
        "priority": "low",
        "dependencies": [
          2,
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar ThemeModeProvider con opciones light, dark y system",
            "description": "Crear el provider principal para manejar el estado del tema con soporte para modo claro, oscuro y automático según el sistema",
            "dependencies": [],
            "details": "Implementar ThemeModeProvider usando Riverpod con estados light, dark, system. Configurar ThemeData para ambos modos con esquemas de colores personalizados. Implementar método para cambiar tema y notificar a widgets dependientes.",
            "status": "pending",
            "testStrategy": "Unit tests para cambios de estado del provider. Verificar notificaciones correctas a listeners."
          },
          {
            "id": 2,
            "title": "Crear ThemeToggle widget con SegmentedButton",
            "description": "Desarrollar widget interactivo para permitir al usuario cambiar entre modos de tema usando un SegmentedButton",
            "dependencies": [
              1
            ],
            "details": "Crear ThemeToggle widget usando SegmentedButton con opciones light/dark/system. Implementar iconografía clara para cada modo. Conectar con ThemeModeProvider para reflejar estado actual y manejar cambios.",
            "status": "pending",
            "testStrategy": "Widget tests para interacciones de usuario. Verificar sincronización con provider de tema."
          },
          {
            "id": 3,
            "title": "Configurar persistencia en SharedPreferences",
            "description": "Implementar almacenamiento persistente de la preferencia de tema usando SharedPreferences para mantener la selección entre sesiones",
            "dependencies": [
              1
            ],
            "details": "Crear ThemePreferences service que use SharedPreferences para guardar/cargar tema seleccionado. Implementar métodos saveThemeMode y loadThemeMode. Integrar con ThemeModeProvider para persistencia automática.",
            "status": "pending",
            "testStrategy": "Integration tests verificando persistencia tras restart de app. Probar valores por defecto."
          },
          {
            "id": 4,
            "title": "Implementar detección automática de tema del sistema",
            "description": "Desarrollar funcionalidad para detectar automáticamente el tema del sistema operativo cuando está seleccionado el modo 'system'",
            "dependencies": [
              1
            ],
            "details": "Usar MediaQuery.platformBrightnessOf para detectar tema del sistema. Implementar listener para cambios de tema del OS en tiempo real. Configurar actualización automática del tema cuando cambia el sistema.",
            "status": "pending",
            "testStrategy": "Tests simulando cambios de tema del sistema. Verificar respuesta automática a cambios de brightnes."
          },
          {
            "id": 5,
            "title": "Validar contraste WCAG 2.1 AA en ambos modos",
            "description": "Asegurar que todos los colores y combinaciones cumplan con estándares de accesibilidad WCAG 2.1 AA para contraste",
            "dependencies": [
              1,
              2
            ],
            "details": "Auditar esquemas de colores para ambos temas usando herramientas de contraste. Ajustar colores que no cumplan ratio 4.5:1 para texto normal y 3:1 para texto grande. Documentar paleta de colores accesible.",
            "status": "pending",
            "testStrategy": "Tests automatizados verificando ratios de contraste. Auditoría manual con herramientas de accesibilidad."
          },
          {
            "id": 6,
            "title": "Testing de persistencia tras restart y funcionalidad completa",
            "description": "Realizar testing integral del sistema de temas incluyendo persistencia, detección automática y cambios de usuario",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Crear integration tests que verifiquen: persistencia de tema tras restart, detección correcta de tema del sistema, funcionamiento del toggle, transiciones suaves entre temas. Probar edge cases y escenarios de error.",
            "status": "pending",
            "testStrategy": "Integration tests end-to-end cubriendo todos los flujos. Tests de regresión para persistencia y detección automática."
          }
        ]
      },
      {
        "id": 37,
        "title": "Configurar notificaciones de ayuno",
        "description": "Implementar notificaciones automáticas para hitos de ayuno",
        "details": "Crear FastingNotificationService para notificaciones en: inicio de ayuno, hitos (4h, 8h, 12h, 16h), completación. Configurar deep links para abrir app en pantalla específica. Personalizar contenido basado en progreso. Implementar programación con OneSignal.",
        "testStrategy": "Verificar notificaciones llegan en horarios correctos. Probar deep linking desde notificaciones. Confirmar delivery en background.",
        "priority": "medium",
        "dependencies": [
          6,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear FastingNotificationService base",
            "description": "Implementar la clase principal FastingNotificationService para gestionar las notificaciones de ayuno",
            "dependencies": [],
            "details": "Crear FastingNotificationService con métodos para programar, cancelar y gestionar notificaciones de ayuno. Incluir configuración básica, manejo de estados y conexión con OneSignal. Implementar singleton pattern para acceso global.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar creación correcta del servicio y métodos básicos"
          },
          {
            "id": 2,
            "title": "Configurar notificaciones para inicio de ayuno",
            "description": "Implementar notificaciones automáticas cuando el usuario inicia un período de ayuno",
            "dependencies": [
              1
            ],
            "details": "Configurar notificación de confirmación de inicio de ayuno con mensaje personalizado. Incluir información del tipo de ayuno seleccionado y duración estimada. Integrar con FastingTimerService para trigger automático.",
            "status": "pending",
            "testStrategy": "Verificar que la notificación se envía inmediatamente al iniciar ayuno"
          },
          {
            "id": 3,
            "title": "Implementar notificaciones de hitos de progreso",
            "description": "Configurar notificaciones automáticas para hitos específicos durante el ayuno (4h, 8h, 12h, 16h)",
            "dependencies": [
              1
            ],
            "details": "Programar notificaciones push para cada hito de ayuno con mensajes motivacionales personalizados. Calcular timing basado en hora de inicio. Incluir progreso actual y tiempo restante. Configurar diferentes mensajes para cada hito.",
            "status": "pending",
            "testStrategy": "Probar timing exacto de notificaciones en diferentes hitos y verificar contenido personalizado"
          },
          {
            "id": 4,
            "title": "Configurar notificación de completación de ayuno",
            "description": "Implementar notificación de felicitación cuando el usuario completa exitosamente su ayuno",
            "dependencies": [
              1
            ],
            "details": "Crear notificación de celebración al completar ayuno con estadísticas del período completado. Incluir logros desbloqueados y métricas de progreso. Configurar deep link a pantalla de resumen de ayuno.",
            "status": "pending",
            "testStrategy": "Verificar que la notificación llega exactamente al completar el tiempo programado"
          },
          {
            "id": 5,
            "title": "Implementar deep links para pantallas específicas",
            "description": "Configurar navegación automática a pantallas específicas desde notificaciones push",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Configurar deep links usando go_router para dirigir a pantallas específicas: /fasting-progress, /fasting-complete, /fasting-stats. Implementar manejador de notificación click para parsear URLs y navegar correctamente. Incluir parámetros de contexto.",
            "status": "pending",
            "testStrategy": "Probar navegación desde cada tipo de notificación a la pantalla correcta"
          },
          {
            "id": 6,
            "title": "Personalizar contenido basado en progreso del usuario",
            "description": "Implementar lógica para personalizar mensajes de notificación según el historial y progreso individual",
            "dependencies": [
              1
            ],
            "details": "Crear sistema de personalización que adapte mensajes según: racha actual, tipo de ayuno preferido, hora del día, progreso histórico. Implementar templates de mensajes dinámicos con variables contextuales. Integrar con datos de usuario desde Supabase.",
            "status": "pending",
            "testStrategy": "Verificar que los mensajes cambian apropiadamente según el contexto del usuario"
          },
          {
            "id": 7,
            "title": "Integrar programación con OneSignal",
            "description": "Configurar la programación y envío de notificaciones a través del SDK de OneSignal",
            "dependencies": [
              1,
              6
            ],
            "details": "Implementar integración completa con OneSignal API para programar notificaciones futuras. Configurar segmentación de usuarios, manejo de time zones, y delivery optimization. Incluir fallback para notificaciones locales si OneSignal falla.",
            "status": "pending",
            "testStrategy": "Probar delivery de notificaciones en background y verificar timing correcto"
          },
          {
            "id": 8,
            "title": "Testing integral del sistema de notificaciones",
            "description": "Realizar testing completo del flujo de notificaciones, timing y deep linking",
            "dependencies": [
              2,
              3,
              4,
              5,
              7
            ],
            "details": "Ejecutar suite de tests integrales verificando: timing preciso de notificaciones, funcionamiento de deep links, delivery en background, personalización de contenido, manejo de errores y fallbacks. Incluir testing en dispositivos iOS y Android.",
            "status": "pending",
            "testStrategy": "Integration tests completos cubriendo todo el flujo desde inicio hasta completación de ayuno"
          }
        ]
      },
      {
        "id": 38,
        "title": "Implementar notificaciones de engagement",
        "description": "Crear sistema de re-engagement para usuarios inactivos",
        "details": "Implementar EngagementNotificationService que detecte inactividad >24h. Enviar recordatorios personalizados basados en historial. Configurar mensajes sobre streaks en riesgo. Implementar rate limiting para evitar spam. Respetar preferencias de usuario.",
        "testStrategy": "Verificar detección correcta de inactividad. Probar rate limiting. Confirmar respeto a preferencias de notificación.",
        "priority": "low",
        "dependencies": [
          6,
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar EngagementNotificationService base",
            "description": "Crear la estructura básica del servicio de notificaciones de engagement con métodos principales",
            "dependencies": [],
            "details": "Crear clase EngagementNotificationService con métodos checkUserInactivity(), sendEngagementNotification(), y setupPeriodicChecks(). Definir interfaces y estructura básica del servicio sin lógica compleja aún.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar creación correcta del servicio y métodos base"
          },
          {
            "id": 2,
            "title": "Configurar detección de inactividad de usuarios",
            "description": "Implementar lógica para detectar usuarios inactivos por más de 24 horas",
            "dependencies": [
              1
            ],
            "details": "Implementar método para calcular tiempo de inactividad basado en última actividad del usuario. Configurar threshold de 24 horas. Integrar con base de datos para obtener timestamp de última actividad. Manejar casos edge como usuarios nuevos.",
            "status": "pending",
            "testStrategy": "Verificar detección correcta de inactividad con diferentes escenarios temporales"
          },
          {
            "id": 3,
            "title": "Implementar mensajes personalizados basados en historial",
            "description": "Crear sistema de mensajes de re-engagement personalizados según el historial del usuario",
            "dependencies": [
              1,
              2
            ],
            "details": "Analizar historial de usuario para generar mensajes personalizados. Incluir información sobre streaks en riesgo, progreso previo, y objetivos. Crear templates de mensajes dinámicos. Implementar lógica para seleccionar mensaje más relevante.",
            "status": "pending",
            "testStrategy": "Probar generación de mensajes con diferentes tipos de historial de usuario"
          },
          {
            "id": 4,
            "title": "Configurar sistema de rate limiting",
            "description": "Implementar rate limiting para evitar spam de notificaciones a los usuarios",
            "dependencies": [
              1
            ],
            "details": "Implementar rate limiting con límites: máximo 1 notificación por día por usuario, cooldown de 8 horas entre notificaciones. Persistir estado de rate limiting en base de datos. Configurar diferentes límites para diferentes tipos de engagement.",
            "status": "pending",
            "testStrategy": "Validar que rate limiting funcione correctamente y no envíe notificaciones en exceso"
          },
          {
            "id": 5,
            "title": "Implementar respeto a preferencias de usuario",
            "description": "Configurar sistema para respetar las preferencias de notificación del usuario",
            "dependencies": [
              1
            ],
            "details": "Integrar con configuración de usuario para verificar preferencias de notificación. Implementar opt-out completo y configuración granular por tipo de notificación. Verificar horarios permitidos para notificaciones. Manejar Do Not Disturb periods.",
            "status": "pending",
            "testStrategy": "Confirmar respeto completo a preferencias de notificación configuradas"
          },
          {
            "id": 6,
            "title": "Testing de detección de inactividad",
            "description": "Crear tests comprehensivos para la detección de usuarios inactivos",
            "dependencies": [
              2
            ],
            "details": "Crear tests unitarios y de integración para verificar detección correcta de inactividad. Probar edge cases como cambios de zona horaria, usuarios nuevos, y períodos de inactividad variables. Mockear timestamps para testing determinista.",
            "status": "pending",
            "testStrategy": "Tests automatizados que cubran todos los escenarios de detección de inactividad"
          },
          {
            "id": 7,
            "title": "Validación completa de rate limiting",
            "description": "Testing exhaustivo del sistema de rate limiting implementado",
            "dependencies": [
              4
            ],
            "details": "Crear tests de stress para rate limiting. Verificar comportamiento con múltiples usuarios simultáneos. Probar edge cases como reset de límites, persistencia tras restart de app, y manejo de errores en rate limiting.",
            "status": "pending",
            "testStrategy": "Tests de carga y stress para verificar robustez del rate limiting"
          }
        ]
      },
      {
        "id": 39,
        "title": "Configurar Superwall para paywall",
        "description": "Integrar Superwall SDK para gestión de suscripciones y paywall",
        "details": "Configurar Superwall SDK con API keys. Implementar SuperwallService para presentación de paywall. Configurar experiments para A/B testing de paywalls. Implementar manejo de purchase events y subscription status. Configurar webhook endpoints para sincronización.",
        "testStrategy": "Integration tests para flow de compra. Verificar A/B testing funcional. Probar webhook synchronization.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuración inicial de Superwall SDK",
            "description": "Instalar y configurar el SDK de Superwall con las API keys necesarias",
            "dependencies": [],
            "details": "Añadir dependencia de Superwall SDK al pubspec.yaml. Configurar API keys en archivos de configuración específicos para iOS y Android. Inicializar SDK en main.dart con configuración básica.",
            "status": "pending",
            "testStrategy": "Verificar que el SDK se inicialice correctamente sin errores"
          },
          {
            "id": 2,
            "title": "Implementación de SuperwallService",
            "description": "Crear servicio para gestionar la presentación de paywalls",
            "dependencies": [
              1
            ],
            "details": "Crear clase SuperwallService con métodos para presentar paywall, verificar estado de suscripción y manejar eventos. Implementar singleton pattern para acceso global.",
            "status": "pending",
            "testStrategy": "Unit tests para métodos del servicio y mock de respuestas del SDK"
          },
          {
            "id": 3,
            "title": "Configuración de experiments para A/B testing",
            "description": "Establecer configuración de experimentos para testing de diferentes paywalls",
            "dependencies": [
              2
            ],
            "details": "Configurar experiments en dashboard de Superwall. Implementar lógica para asignar usuarios a diferentes variantes de paywall. Crear métrica tracking para conversión.",
            "status": "pending",
            "testStrategy": "Verificar que usuarios se asignen correctamente a diferentes experiments"
          },
          {
            "id": 4,
            "title": "Implementación de manejo de purchase events",
            "description": "Desarrollar sistema para manejar eventos de compra y transacciones",
            "dependencies": [
              2
            ],
            "details": "Implementar listeners para eventos de purchase success, failure y restoration. Crear lógica para actualizar estado local de suscripción y sincronizar con backend.",
            "status": "pending",
            "testStrategy": "Simular diferentes tipos de purchase events y verificar respuestas correctas"
          },
          {
            "id": 5,
            "title": "Configuración de subscription status monitoring",
            "description": "Establecer monitoreo continuo del estado de suscripción del usuario",
            "dependencies": [
              4
            ],
            "details": "Implementar servicio para verificar periódicamente el estado de suscripción. Configurar cache local del estado premium. Manejar casos de suscripción expirada o cancelada.",
            "status": "pending",
            "testStrategy": "Probar diferentes estados de suscripción y verificar actualizaciones correctas"
          },
          {
            "id": 6,
            "title": "Establecimiento de webhook endpoints",
            "description": "Configurar endpoints para recibir webhooks de Superwall",
            "dependencies": [
              1
            ],
            "details": "Configurar webhooks en dashboard de Superwall para eventos de subscription. Crear endpoints en backend para procesar notifications de cambios de estado.",
            "status": "pending",
            "testStrategy": "Verificar que webhooks se reciban y procesen correctamente"
          },
          {
            "id": 7,
            "title": "Configuración de sincronización con backend",
            "description": "Implementar sincronización bidireccional entre Superwall y Supabase",
            "dependencies": [
              5,
              6
            ],
            "details": "Crear lógica para sincronizar estado de suscripción entre Superwall y base de datos. Implementar manejo de conflictos y retry logic para fallos de sincronización.",
            "status": "pending",
            "testStrategy": "Probar sincronización en diferentes escenarios de conectividad"
          },
          {
            "id": 8,
            "title": "Testing de flow de compra completo",
            "description": "Probar el flujo completo de compra desde paywall hasta confirmación",
            "dependencies": [
              7
            ],
            "details": "Crear tests de integración que cubran todo el flujo: presentación de paywall, selección de plan, proceso de compra, confirmación y activación de features premium.",
            "status": "pending",
            "testStrategy": "Integration tests con ambiente de sandbox para simular compras reales"
          },
          {
            "id": 9,
            "title": "Validación de A/B testing funcional",
            "description": "Verificar que el sistema de A/B testing funcione correctamente en producción",
            "dependencies": [
              3,
              8
            ],
            "details": "Configurar métricas para trackear conversión por variante. Implementar logging para debugging de assignment de experiments. Crear dashboard para monitorear performance.",
            "status": "pending",
            "testStrategy": "Verificar que métricas se capturen correctamente y experiments funcionen como esperado"
          }
        ]
      },
      {
        "id": 40,
        "title": "Implementar gating de funciones premium",
        "description": "Crear sistema de restricción de acceso a funcionalidades premium",
        "details": "Implementar isPremiumProvider que monitoree subscription status. Crear guards para funciones premium: custom plans, advanced analytics, meditation library. Implementar upsell prompts cuando usuario accede a función premium. Configurar grace period para suscripciones expiradas.",
        "testStrategy": "Verificar gating correcto de funciones premium. Probar upsell prompts. Confirmar grace period functionality.",
        "priority": "medium",
        "dependencies": [
          39
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar isPremiumProvider para monitoreo de suscripción",
            "description": "Crear provider que monitoree constantemente el estado de suscripción del usuario",
            "dependencies": [],
            "details": "Implementar isPremiumProvider usando Riverpod que se conecte con el subscription service. Debe escuchar cambios en tiempo real del estado de suscripción y proveer valores booleanos para el gating. Incluir manejo de estados de carga y error.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar detección correcta de estados de suscripción premium/free"
          },
          {
            "id": 2,
            "title": "Crear guards para custom plans premium",
            "description": "Implementar sistema de restricción para la funcionalidad de planes personalizados",
            "dependencies": [
              1
            ],
            "details": "Crear PremiumGuard para custom plans que verifique suscripción antes de permitir acceso. Implementar interceptor que bloquee navegación y muestre upsell prompt. Aplicar guard en rutas y widgets relacionados con planes personalizados.",
            "status": "pending",
            "testStrategy": "Verificar bloqueo correcto para usuarios free y acceso permitido para premium"
          },
          {
            "id": 3,
            "title": "Crear guards para advanced analytics premium",
            "description": "Implementar restricción de acceso para analíticas avanzadas solo para usuarios premium",
            "dependencies": [
              1
            ],
            "details": "Desarrollar guard específico para advanced analytics que verifique suscripción premium. Implementar en pantallas de reportes avanzados, gráficos detallados y exportación de datos. Mostrar versión limitada para usuarios free.",
            "status": "pending",
            "testStrategy": "Probar restricción de analytics avanzadas y disponibilidad de versión básica"
          },
          {
            "id": 4,
            "title": "Crear guards para meditation library premium",
            "description": "Implementar sistema de gating para biblioteca de meditación premium",
            "dependencies": [
              1
            ],
            "details": "Crear guard para meditation library que permita acceso limitado a usuarios free y completo a premium. Implementar preview de contenido premium y bloqueo de descarga. Configurar marcadores visuales para contenido premium.",
            "status": "pending",
            "testStrategy": "Verificar acceso limitado para free users y completo para premium subscribers"
          },
          {
            "id": 5,
            "title": "Implementar upsell prompts para funciones premium",
            "description": "Crear sistema de prompts persuasivos cuando usuarios free acceden a funcionalidades premium",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Desarrollar UpsellPromptService que muestre modals contextuales explicando beneficios premium. Personalizar mensajes según funcionalidad accedida. Implementar analytics para tracking de conversión. Configurar frequency capping para evitar spam.",
            "status": "pending",
            "testStrategy": "Probar aparición correcta de prompts y tracking de interacciones de usuario"
          },
          {
            "id": 6,
            "title": "Configurar grace period para suscripciones expiradas",
            "description": "Implementar periodo de gracia que permita acceso temporal tras expiración de suscripción",
            "dependencies": [
              1
            ],
            "details": "Configurar grace period de 3-7 días tras expiración de suscripción. Implementar lógica que mantenga acceso premium temporalmente mientras muestra avisos de renovación. Configurar countdown timer y prompts de renovación incrementales.",
            "status": "pending",
            "testStrategy": "Verificar funcionamiento correcto del periodo de gracia y transición a free tier"
          },
          {
            "id": 7,
            "title": "Integrar con Superwall para upsells automáticos",
            "description": "Configurar integración con Superwall para manejo automatizado de upselling",
            "dependencies": [
              5
            ],
            "details": "Integrar Superwall SDK para manejo de paywalls dinámicos. Configurar triggers automáticos basados en comportamiento de usuario. Implementar A/B testing de diferentes upsell strategies. Configurar eventos de conversión y analytics.",
            "status": "pending",
            "testStrategy": "Probar funcionamiento de paywalls automáticos y tracking de conversiones"
          },
          {
            "id": 8,
            "title": "Testing integral del sistema de gating premium",
            "description": "Realizar testing exhaustivo de todo el sistema de restricción de funciones premium",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Ejecutar suite de integration tests que verifique todos los guards funcionando correctamente. Probar transiciones entre estados de suscripción. Verificar upsell prompts, grace period y integración con Superwall. Incluir tests de edge cases y performance.",
            "status": "pending",
            "testStrategy": "Integration tests completos del sistema de gating con diferentes scenarios de usuario"
          }
        ]
      },
      {
        "id": 41,
        "title": "Crear PaywallScreen con Superwall",
        "description": "Implementar UI de paywall con opciones de suscripción",
        "details": "Integrar Superwall paywall UI dentro de la app. Configurar pricing tiers y features list. Implementar restore purchases functionality. Añadir términos de servicio y privacy policy links. Configurar analytics para conversion tracking.",
        "testStrategy": "UI tests para paywall display. Verificar restore purchases. Probar conversion tracking y analytics.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrar Superwall paywall UI en la app",
            "description": "Implementar la integración básica del SDK Superwall para mostrar la UI de paywall dentro de la aplicación",
            "dependencies": [],
            "details": "Configurar SuperwallService para presentar paywall. Integrar con el estado de la app usando Riverpod. Implementar métodos para mostrar/ocultar paywall en momentos apropiados. Configurar handlers para eventos de paywall.",
            "status": "pending",
            "testStrategy": "UI tests para verificar que el paywall se muestra correctamente. Probar integración con navigation stack."
          },
          {
            "id": 2,
            "title": "Configurar pricing tiers y features list",
            "description": "Establecer la configuración de precios y lista de características para las opciones de suscripción",
            "dependencies": [
              1
            ],
            "details": "Definir tiers de suscripción (mensual, anual). Configurar features list con beneficios de cada tier. Implementar UI components para mostrar pricing. Configurar localización de precios por región.",
            "status": "pending",
            "testStrategy": "Verificar que los precios se muestren correctamente en diferentes locales. Probar UI responsiva para diferentes tamaños de pantalla."
          },
          {
            "id": 3,
            "title": "Implementar restore purchases functionality",
            "description": "Desarrollar la funcionalidad para restaurar compras previas del usuario",
            "dependencies": [
              1
            ],
            "details": "Implementar botón y lógica para restore purchases. Integrar con Superwall restore API. Manejar estados de loading y error durante restore. Actualizar UI basado en subscription status restaurado.",
            "status": "pending",
            "testStrategy": "Probar restore con usuarios que tengan compras previas. Verificar manejo de errores cuando no hay compras para restaurar."
          },
          {
            "id": 4,
            "title": "Configurar links a términos de servicio y privacy policy",
            "description": "Añadir enlaces a términos de servicio y política de privacidad en el paywall",
            "dependencies": [
              2
            ],
            "details": "Implementar botones/links para términos y privacidad. Configurar navegación a WebView o browser externo. Asegurar compliance con App Store guidelines. Añadir textos legales requeridos.",
            "status": "pending",
            "testStrategy": "Verificar que los links abran correctamente. Probar navegación back al paywall. Validar textos legales requeridos."
          },
          {
            "id": 5,
            "title": "Configurar analytics para conversion tracking",
            "description": "Implementar seguimiento de conversiones y métricas de paywall para análisis",
            "dependencies": [
              1
            ],
            "details": "Integrar eventos de analytics con Superwall. Configurar tracking de paywall shown, dismissed, purchased. Implementar custom events para A/B testing. Configurar dashboards para monitoreo.",
            "status": "pending",
            "testStrategy": "Verificar que los eventos se envíen correctamente. Probar analytics en diferentes flows de paywall."
          },
          {
            "id": 6,
            "title": "Testing de display de paywall",
            "description": "Realizar pruebas exhaustivas del funcionamiento visual y UX del paywall",
            "dependencies": [
              2,
              4
            ],
            "details": "Crear test cases para diferentes scenarios de paywall. Probar en diferentes dispositivos y orientaciones. Verificar animaciones y transiciones. Probar edge cases como conexión lenta.",
            "status": "pending",
            "testStrategy": "UI tests automatizados para paywall display. Manual testing en diferentes dispositivos iOS/Android."
          },
          {
            "id": 7,
            "title": "Validación de restore purchases",
            "description": "Verificar y validar completamente el flujo de restauración de compras",
            "dependencies": [
              3,
              6
            ],
            "details": "Crear test scenarios para restore purchases. Verificar comportamiento con múltiples tipos de suscripción. Probar edge cases como suscripciones expiradas. Validar sincronización con backend.",
            "status": "pending",
            "testStrategy": "Integration tests para restore flow completo. Testing con cuentas reales que tengan suscripciones activas e inactivas."
          }
        ]
      },
      {
        "id": 42,
        "title": "Configurar go_router para navegación",
        "description": "Implementar sistema de navegación declarativo con deep linking",
        "details": "Configurar GoRouter con rutas principales: /home, /panic, /meditation, /metrics, /learning, /profile, /paywall. Implementar route guards para autenticación y premium features. Configurar deep linking para notificaciones. Añadir redirect logic para onboarding.",
        "testStrategy": "Integration tests para navegación entre pantallas. Verificar deep linking desde notificaciones. Probar route guards.",
        "priority": "high",
        "dependencies": [
          2,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar GoRouter inicial con rutas principales",
            "description": "Establecer la configuración base de GoRouter con las rutas principales del sistema",
            "dependencies": [],
            "details": "Instalar go_router package y configurar GoRouter con rutas: /home, /panic, /meditation, /metrics, /learning, /profile, /paywall. Definir la estructura de navegación jerárquica y configurar shell routes si es necesario.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar que todas las rutas estén correctamente definidas y navegables"
          },
          {
            "id": 2,
            "title": "Implementar route guards para autenticación",
            "description": "Crear sistema de guards para proteger rutas que requieren usuario autenticado",
            "dependencies": [
              1
            ],
            "details": "Implementar AuthGuard que verifique el estado de autenticación del usuario. Redirigir a pantalla de login si no está autenticado. Configurar redirect automático después del login exitoso.",
            "status": "pending",
            "testStrategy": "Integration tests para verificar que usuarios no autenticados sean redirigidos correctamente"
          },
          {
            "id": 3,
            "title": "Configurar guards para premium features",
            "description": "Implementar protección de rutas para funcionalidades premium",
            "dependencies": [
              2
            ],
            "details": "Crear PremiumGuard que verifique el estado de suscripción del usuario. Redirigir a paywall si el usuario no tiene acceso premium. Configurar lista de rutas que requieren suscripción activa.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar que usuarios free sean redirigidos al paywall en rutas premium"
          },
          {
            "id": 4,
            "title": "Implementar deep linking para notificaciones",
            "description": "Configurar navegación automática desde notificaciones push a pantallas específicas",
            "dependencies": [
              1
            ],
            "details": "Configurar manejo de deep links en GoRouter. Implementar parsing de URLs personalizadas desde OneSignal. Establecer mapeo entre tipos de notificación y rutas de destino.",
            "status": "pending",
            "testStrategy": "Integration tests simulando clicks en notificaciones y verificando navegación correcta"
          },
          {
            "id": 5,
            "title": "Configurar redirect logic para onboarding",
            "description": "Implementar lógica de redirección basada en estado de onboarding del usuario",
            "dependencies": [
              2
            ],
            "details": "Crear OnboardingGuard que verifique si el usuario completó el onboarding inicial. Redirigir a flow de onboarding si es primera vez. Configurar rutas de onboarding y skip logic.",
            "status": "pending",
            "testStrategy": "Unit tests para verificar redirección correcta según estado de onboarding"
          },
          {
            "id": 6,
            "title": "Testing de navegación entre pantallas",
            "description": "Crear suite de tests para verificar navegación fluida entre todas las pantallas",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Implementar integration tests que verifiquen navegación entre todas las rutas principales. Probar transiciones de estado y mantenimiento de contexto. Verificar back navigation y stack management.",
            "status": "pending",
            "testStrategy": "Integration tests exhaustivos cubriendo todos los flujos de navegación posibles"
          },
          {
            "id": 7,
            "title": "Verificación de deep linking funcional",
            "description": "Validar que el deep linking funcione correctamente desde diferentes fuentes",
            "dependencies": [
              4
            ],
            "details": "Probar deep linking desde notificaciones, emails, y links externos. Verificar que el estado de la aplicación se mantenga correctamente. Implementar fallback handling para URLs inválidas.",
            "status": "pending",
            "testStrategy": "E2E tests simulando diferentes escenarios de deep linking y verificando comportamiento"
          },
          {
            "id": 8,
            "title": "Testing de route guards completo",
            "description": "Validar funcionamiento correcto de todos los route guards implementados",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Crear tests para verificar AuthGuard, PremiumGuard y OnboardingGuard en diferentes escenarios. Probar combinaciones de guards y edge cases. Verificar performance de guards en navegación.",
            "status": "pending",
            "testStrategy": "Unit e integration tests cubriendo todos los guards y sus interacciones"
          }
        ]
      },
      {
        "id": 43,
        "title": "Implementar SyncManager para sincronización",
        "description": "Crear servicio de sincronización bidireccional entre Isar y Supabase",
        "details": "Implementar SyncManager con estrategias: upload local changes, download server changes, conflict resolution (last-write-wins). Configurar triggers automáticos: app foreground, WiFi connect, manual sync. Implementar exponential backoff para retry logic. Manejar offline queue.",
        "testStrategy": "Integration tests para sync bidireccional. Verificar conflict resolution. Probar offline queue y retry logic.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar clase base SyncManager con arquitectura principal",
            "description": "Crear la estructura principal del SyncManager con interfaces y métodos base para sincronización bidireccional",
            "dependencies": [],
            "details": "Implementar clase SyncManager con métodos sync(), uploadChanges(), downloadChanges(), resolveConflicts(). Definir interfaces ISyncStrategy, IConflictResolver. Configurar dependency injection y logging básico.",
            "status": "pending",
            "testStrategy": "Unit tests para estructura base y métodos principales del SyncManager"
          },
          {
            "id": 2,
            "title": "Desarrollar estrategia de upload de cambios locales",
            "description": "Implementar lógica para detectar y subir cambios locales pendientes al servidor",
            "dependencies": [
              1
            ],
            "details": "Implementar LocalChangeDetector que identifique registros modificados en Isar usando timestamps. Crear UploadStrategy para enviar cambios a Supabase en lotes. Marcar registros como sincronizados tras upload exitoso.",
            "status": "pending",
            "testStrategy": "Verificar detección correcta de cambios locales y upload exitoso a Supabase"
          },
          {
            "id": 3,
            "title": "Implementar estrategia de download de cambios del servidor",
            "description": "Crear sistema para descargar y aplicar cambios del servidor a la base de datos local",
            "dependencies": [
              1
            ],
            "details": "Implementar DownloadStrategy que consulte cambios en Supabase usando timestamps de última sincronización. Aplicar cambios a Isar preservando integridad referencial. Actualizar marcadores de sincronización local.",
            "status": "pending",
            "testStrategy": "Probar download de cambios del servidor y aplicación correcta en base local"
          },
          {
            "id": 4,
            "title": "Desarrollar sistema de resolución de conflictos last-write-wins",
            "description": "Implementar algoritmo de resolución de conflictos basado en timestamps de última modificación",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear ConflictResolver que compare timestamps de modificación entre versión local y servidor. Implementar estrategia last-write-wins preservando el registro más reciente. Registrar conflictos resueltos para auditoría.",
            "status": "pending",
            "testStrategy": "Verificar resolución correcta de conflictos y preservación de datos más recientes"
          },
          {
            "id": 5,
            "title": "Configurar triggers automáticos de sincronización",
            "description": "Implementar sistema de triggers para iniciar sincronización automática en eventos específicos",
            "dependencies": [
              1
            ],
            "details": "Configurar AppLifecycleListener para sync en foreground. Implementar ConnectivityListener para sync en conexión WiFi. Crear ScheduledSyncTrigger para sync periódico. Permitir configuración de frecuencia por usuario.",
            "status": "pending",
            "testStrategy": "Probar activación automática de sync en diferentes eventos y condiciones"
          },
          {
            "id": 6,
            "title": "Implementar exponential backoff para retry logic",
            "description": "Crear sistema de reintentos con backoff exponencial para operaciones de sincronización fallidas",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar RetryManager con algoritmo exponential backoff (2^attempts * base_delay). Configurar máximo de reintentos y delay máximo. Distinguir entre errores temporales y permanentes para estrategias diferentes.",
            "status": "pending",
            "testStrategy": "Verificar comportamiento correcto de backoff y límites de reintentos"
          },
          {
            "id": 7,
            "title": "Desarrollar offline queue para operaciones pendientes",
            "description": "Implementar cola persistente para almacenar operaciones de sincronización cuando no hay conectividad",
            "dependencies": [
              1
            ],
            "details": "Crear OfflineQueue usando Isar para persistir operaciones pendientes. Implementar priorización de operaciones (CREATE, UPDATE, DELETE). Procesar cola automáticamente al restaurar conectividad.",
            "status": "pending",
            "testStrategy": "Probar almacenamiento y procesamiento de cola offline tras reconexión"
          },
          {
            "id": 8,
            "title": "Integrar componentes y testing de sincronización bidireccional",
            "description": "Ensamblar todos los componentes del SyncManager y realizar testing integral de sincronización",
            "dependencies": [
              4,
              5,
              6,
              7
            ],
            "details": "Integrar todas las estrategias en SyncManager principal. Configurar orquestación de upload/download. Implementar integration tests que simulen escenarios reales de sincronización bidireccional.",
            "status": "pending",
            "testStrategy": "Integration tests completos para flujos de sincronización bidireccional"
          },
          {
            "id": 9,
            "title": "Verificar y optimizar resolución de conflictos",
            "description": "Realizar testing exhaustivo del sistema de resolución de conflictos y optimizar rendimiento",
            "dependencies": [
              8
            ],
            "details": "Crear test cases para diversos escenarios de conflictos. Verificar preservación de integridad de datos. Optimizar algoritmos de comparación y resolución. Implementar métricas de conflictos para monitoreo.",
            "status": "pending",
            "testStrategy": "Test cases específicos para resolución de conflictos y validación de integridad"
          },
          {
            "id": 10,
            "title": "Validar offline queue y retry logic con testing de stress",
            "description": "Realizar testing de stress para offline queue y retry logic bajo condiciones adversas",
            "dependencies": [
              9
            ],
            "details": "Simular condiciones de red intermitente y fallos de servidor. Verificar comportamiento de retry logic bajo carga. Probar limpieza y recuperación de offline queue. Optimizar rendimiento bajo stress.",
            "status": "pending",
            "testStrategy": "Stress tests para offline queue y retry logic bajo condiciones adversas"
          }
        ]
      },
      {
        "id": 44,
        "title": "Configurar testing y CI/CD",
        "description": "Establecer pipeline de testing automatizado y deployment",
        "details": "Configurar Codemagic para CI/CD con workflows para iOS y Android. Implementar unit tests (60%), integration tests (30%), E2E tests (10%). Configurar code coverage reports. Establecer automated builds para production con obfuscation. Configurar deployment a TestFlight y Play Console.",
        "testStrategy": "Verificar pipeline completo funciona. Alcanzar 80% code coverage mínimo. Confirmar builds automáticos sin errores.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar cuenta y proyecto en Codemagic",
            "description": "Crear cuenta en Codemagic y configurar proyecto inicial con repositorio conectado",
            "dependencies": [],
            "details": "Registrar cuenta en Codemagic, conectar repositorio de GitHub/GitLab, configurar credenciales de acceso, crear proyecto base y verificar conexión con el código fuente",
            "status": "pending",
            "testStrategy": "Verificar que el proyecto se sincronice correctamente con el repositorio"
          },
          {
            "id": 2,
            "title": "Configurar workflow de CI/CD para iOS",
            "description": "Establecer pipeline automatizado para builds y deployment de iOS",
            "dependencies": [
              1
            ],
            "details": "Crear archivo codemagic.yaml con workflow para iOS, configurar certificados de desarrollo y distribución, establecer provisioning profiles, configurar build settings para obfuscation",
            "status": "pending",
            "testStrategy": "Ejecutar build completo y verificar que el archivo IPA se genere correctamente"
          },
          {
            "id": 3,
            "title": "Configurar workflow de CI/CD para Android",
            "description": "Establecer pipeline automatizado para builds y deployment de Android",
            "dependencies": [
              1
            ],
            "details": "Configurar workflow Android en codemagic.yaml, establecer keystore para firma de APK/AAB, configurar build settings con obfuscation, establecer gradle configurations para release",
            "status": "pending",
            "testStrategy": "Ejecutar build y verificar que el archivo AAB se genere sin errores"
          },
          {
            "id": 4,
            "title": "Implementar unit tests con 60% coverage",
            "description": "Desarrollar suite completa de unit tests para componentes principales",
            "dependencies": [],
            "details": "Crear unit tests para servicios, modelos y utilidades usando flutter_test. Enfocar en SupabaseService, NotificationService, AuthService y modelos de datos. Configurar test coverage reporting",
            "status": "pending",
            "testStrategy": "Ejecutar flutter test --coverage y verificar que se alcance mínimo 60% de cobertura"
          },
          {
            "id": 5,
            "title": "Desarrollar integration tests con 30% coverage",
            "description": "Crear tests de integración para flujos principales de la aplicación",
            "dependencies": [
              4
            ],
            "details": "Implementar integration tests para autenticación, navegación entre pantallas, sincronización de datos con Supabase, y flujos de notificaciones usando integration_test package",
            "status": "pending",
            "testStrategy": "Ejecutar integration tests en dispositivos reales y verificar que todos los flujos principales funcionen"
          },
          {
            "id": 6,
            "title": "Crear E2E tests con 10% coverage",
            "description": "Desarrollar tests end-to-end para escenarios críticos del usuario",
            "dependencies": [
              5
            ],
            "details": "Implementar E2E tests para registro de usuario, inicio de sesión, configuración de ayuno, recepción de notificaciones y flujo de compra premium usando detox o similar",
            "status": "pending",
            "testStrategy": "Ejecutar E2E tests en entorno de staging y verificar comportamiento completo del usuario"
          },
          {
            "id": 7,
            "title": "Configurar code coverage reports y métricas",
            "description": "Establecer sistema de reporte de cobertura de código y métricas de calidad",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Integrar lcov para coverage reporting, configurar SonarQube o codecov para análisis de calidad, establecer badges de coverage, configurar alertas para caída de cobertura",
            "status": "pending",
            "testStrategy": "Verificar que los reportes se generen automáticamente y sean accesibles"
          },
          {
            "id": 8,
            "title": "Configurar deployment automático a TestFlight y Play Console",
            "description": "Establecer deployment automático a tiendas de aplicaciones",
            "dependencies": [
              2,
              3
            ],
            "details": "Configurar App Store Connect API para TestFlight uploads, establecer Google Play Console API para Play Store uploads, configurar credenciales y permisos necesarios, establecer triggers de deployment",
            "status": "pending",
            "testStrategy": "Verificar que las builds se suban automáticamente a TestFlight y Play Console sin intervención manual"
          },
          {
            "id": 9,
            "title": "Validar pipeline completo y establecer monitoreo",
            "description": "Probar pipeline end-to-end y configurar monitoreo de builds",
            "dependencies": [
              7,
              8
            ],
            "details": "Ejecutar pipeline completo desde commit hasta deployment, configurar notificaciones de build status, establecer rollback procedures, documentar proceso de CI/CD y troubleshooting",
            "status": "pending",
            "testStrategy": "Ejecutar ciclo completo de desarrollo y verificar que todas las etapas se completen exitosamente"
          }
        ]
      },
      {
        "id": 45,
        "title": "Optimización de rendimiento y preparación para lanzamiento",
        "description": "Optimizar rendimiento, configurar analytics y preparar assets para App Store/Play Store",
        "details": "Implementar Sentry para error monitoring. Optimizar rendimiento: app launch <2s, animations 60fps. Configurar flavors production con obfuscation. Crear assets para tiendas: screenshots, descriptions, privacy policy. Realizar testing de accesibilidad WCAG 2.1 AA. Configurar analytics con custom events.",
        "testStrategy": "Performance tests en dispositivos objetivo. Accessibility audit completo. Verificar assets de tienda listos. Probar error reporting con Sentry.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar integración de Sentry para monitoreo de errores",
            "description": "Configurar Sentry SDK en Flutter para capturar errores automáticamente y enviar reportes de crashes",
            "dependencies": [],
            "details": "Instalar sentry_flutter package, configurar DSN en flavors, implementar SentryService con captura de errores no manejados, configurar breadcrumbs y contexto de usuario, establecer release tracking",
            "status": "pending",
            "testStrategy": "Probar captura de errores forzados y verificar aparición en dashboard de Sentry"
          },
          {
            "id": 2,
            "title": "Optimizar tiempo de inicio de aplicación a menos de 2 segundos",
            "description": "Implementar lazy loading y optimizaciones para reducir el app launch time",
            "dependencies": [
              1
            ],
            "details": "Implementar SplashScreen optimizado, lazy loading de providers, precarga de assets críticos, optimizar imports y dependencias, usar deferred loading para módulos no críticos",
            "status": "pending",
            "testStrategy": "Medir tiempo de startup con flutter driver y verificar métricas <2s en dispositivos objetivo"
          },
          {
            "id": 3,
            "title": "Optimizar animaciones para 60fps consistentes",
            "description": "Asegurar que todas las animaciones mantengan 60fps sin drops de frames",
            "dependencies": [
              2
            ],
            "details": "Revisar AnimationControllers, implementar RepaintBoundary en widgets pesados, optimizar custom painters, usar Transform en lugar de Container para animaciones, implementar performance monitoring",
            "status": "pending",
            "testStrategy": "Usar Flutter Inspector para medir frame rendering y verificar 60fps en animaciones críticas"
          },
          {
            "id": 4,
            "title": "Configurar flavor production con obfuscation",
            "description": "Establecer configuración de producción con código ofuscado y assets optimizados",
            "dependencies": [
              3
            ],
            "details": "Configurar android/app/build.gradle con obfuscation rules, setup proguard, configurar ios/Runner.xcodeproj para release, establecer environment variables por flavor, optimizar asset bundling",
            "status": "pending",
            "testStrategy": "Verificar build de producción funcional y confirmar código ofuscado en APK/IPA"
          },
          {
            "id": 5,
            "title": "Crear screenshots para App Store y Play Store",
            "description": "Generar screenshots profesionales en múltiples dispositivos y idiomas para las tiendas",
            "dependencies": [
              4
            ],
            "details": "Capturar screenshots en iPhone 6.7', iPhone 5.5', iPad Pro, Android phones y tablets, crear versiones en español e inglés, optimizar resoluciones según requirements de tiendas",
            "status": "pending",
            "testStrategy": "Verificar que screenshots cumplan guidelines de Apple App Store y Google Play Store"
          },
          {
            "id": 6,
            "title": "Desarrollar descripciones para tiendas de aplicaciones",
            "description": "Crear copy optimizado para App Store y Play Store con keywords y beneficios claros",
            "dependencies": [
              5
            ],
            "details": "Redactar descripción corta y larga, destacar beneficios del ayuno intermitente, incluir keywords relevantes, crear bullet points de características, adaptar para límites de caracteres de cada tienda",
            "status": "pending",
            "testStrategy": "Revisar compliance con guidelines de contenido y verificar optimización SEO/ASO"
          },
          {
            "id": 7,
            "title": "Desarrollar privacy policy completa",
            "description": "Crear política de privacidad que cumpla con GDPR, CCPA y requisitos de las tiendas",
            "dependencies": [
              6
            ],
            "details": "Documentar recolección de datos, uso de analytics, integración con OneSignal, derechos del usuario, procedimientos de eliminación de datos, contacto para privacidad",
            "status": "pending",
            "testStrategy": "Revisar compliance legal y verificar accesibilidad desde la app"
          },
          {
            "id": 8,
            "title": "Realizar testing de accesibilidad WCAG 2.1 AA",
            "description": "Auditar y corregir la aplicación para cumplir estándares de accesibilidad WCAG 2.1 nivel AA",
            "dependencies": [
              7
            ],
            "details": "Implementar semantics en widgets, verificar contraste de colores, añadir labels para screen readers, probar navegación por teclado, validar tamaños mínimos de toque",
            "status": "pending",
            "testStrategy": "Usar herramientas de accessibility testing y probar con screen readers reales"
          },
          {
            "id": 9,
            "title": "Configurar analytics con eventos personalizados",
            "description": "Implementar sistema de analytics con eventos específicos para tracking de engagement",
            "dependencies": [
              8
            ],
            "details": "Configurar Firebase Analytics, definir custom events (fasting_started, hydration_logged, goal_achieved), implementar user properties, establecer conversion funnels",
            "status": "pending",
            "testStrategy": "Verificar eventos en Firebase console y validar tracking de user journey completo"
          },
          {
            "id": 10,
            "title": "Ejecutar performance testing en dispositivos objetivo",
            "description": "Realizar testing exhaustivo de rendimiento en dispositivos de gama baja y alta",
            "dependencies": [
              9
            ],
            "details": "Probar en iPhone SE, iPhone 14 Pro, Samsung Galaxy A series, flagship Android, medir memory usage, CPU utilization, battery drain, network efficiency",
            "status": "pending",
            "testStrategy": "Documentar métricas de performance y confirmar que cumple targets en todos los dispositivos"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-21T22:39:04.280Z",
      "updated": "2025-10-21T22:39:04.280Z",
      "description": "Tasks for master context"
    }
  }
}