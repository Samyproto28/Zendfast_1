{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Configurar sistema de diseño Zendfast (colores, tipografía, espaciado)",
        "description": "Crear el sistema de diseño base con colores zen-inspirados, tipografías legibles y espaciado consistente para toda la aplicación",
        "details": "Implementar ZendfastColors con paleta: Teal principal (#069494), Verde secundario (#7fb069), Naranja para botón pánico (#ffb366). Configurar tipografías: Inter para headers, Source Sans Pro para cuerpo, Nunito Sans para énfasis emocional. Establecer espaciado base 8dp grid system. Crear ThemeData para Material 3 con elevaciones y radios de borde apropiados.",
        "testStrategy": "Verificar contraste WCAG 2.1 AA (4.5:1 mínimo), pruebas de snapshot visual para consistencia, validar tamaños de fuente legibles (16sp mínimo para cuerpo)",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar paleta de colores ZendfastColors con Material 3",
            "description": "Crear clase ZendfastColors con la paleta completa: Teal principal (#069494), Verde secundario (#7fb069), Naranja para botón pánico (#ffb366) y configurar ColorScheme para Material 3",
            "dependencies": [],
            "details": "Crear archivo lib/theme/colors.dart con clase ZendfastColors conteniendo colores primarios, secundarios, surface, background, error y sus variantes. Implementar ColorScheme.fromSeed() usando teal como color primario. Agregar colores semánticos específicos como panicButton, successColor, warningColor. Definir variaciones para light/dark theme. Asegurar compatibilidad con Material 3 color tokens.",
            "status": "done",
            "testStrategy": "Verificar contraste WCAG 2.1 AA mínimo 4.5:1 entre texto y fondo, probar visualización en dispositivos con diferentes pantallas, validar coherencia en light/dark themes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar tipografías Inter, Source Sans Pro y Nunito Sans",
            "description": "Establecer jerarquía tipográfica con Inter para headers, Source Sans Pro para texto de cuerpo y Nunito Sans para énfasis emocional, integrando con TextTheme de Material 3",
            "dependencies": [
              1
            ],
            "details": "Agregar fuentes a pubspec.yaml y assets/fonts/. Crear ZendfastTextStyles con estilos: displayLarge/Medium/Small (Inter), headlineLarge/Medium/Small (Inter), bodyLarge/Medium/Small (Source Sans Pro), labelLarge/Medium/Small (Nunito Sans). Configurar TextTheme con tamaños apropiados: headlines 24-32sp, body 16-18sp, labels 12-14sp. Implementar responsive typography scaling.",
            "status": "done",
            "testStrategy": "Verificar legibilidad con tamaño mínimo 16sp para texto de cuerpo, probar en diferentes tamaños de pantalla, validar carga correcta de fuentes custom",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Establecer sistema de espaciado 8dp grid y ThemeData completo",
            "description": "Implementar sistema de espaciado basado en grid de 8dp y crear ThemeData completo para Material 3 con elevaciones, radios de borde y componentes",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear ZendfastSpacing con valores: xs(4dp), s(8dp), m(16dp), l(24dp), xl(32dp), xxl(40dp). Implementar ZendfastTheme que combine colores, tipografías y espaciado en ThemeData. Configurar elevaciones Material 3: level0-5. Establecer border radius: small(4dp), medium(8dp), large(12dp), extraLarge(16dp). Configurar component themes: AppBar, Card, Button, TextField con estilos consistentes.",
            "status": "done",
            "testStrategy": "Verificar espaciado consistente en toda la app, probar elevaciones y sombras apropiadas, validar component themes aplicados correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on configurar sistema de diseño zendfast (colores, tipografía, espaciado)."
      },
      {
        "id": "2",
        "title": "Configurar base de datos Isar v3.1.0 con esquemas principales",
        "description": "Inicializar Isar con esquemas para FastingSession, UserProfile, HydrationLog y ContentItem con relaciones y índices optimizados",
        "details": "Instalar isar 3.1.0, isar_flutter_libs, build_runner. Crear esquemas @collection para: FastingSession (id, userId, startTime, endTime, durationMinutes, completed, interrupted, planType), UserProfile (id, weightKg, heightCm, dailyHydrationGoal calculado), HydrationLog (id, userId, amount, timestamp), ContentItem (id, title, contentType, category, url, isPremium). Configurar índices para consultas frecuentes (userId, timestamp). Implementar DatabaseService singleton.",
        "testStrategy": "Pruebas unitarias CRUD para cada colección, verificar migraciones funcionan, probar rendimiento con 1000+ registros",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencias de Isar y configurar build tools",
            "description": "Instalar las dependencias necesarias de Isar 3.1.0 y configurar las herramientas de construcción para Flutter",
            "dependencies": [],
            "details": "Agregar al pubspec.yaml: isar: ^3.1.0, isar_flutter_libs: ^3.1.0, path_provider: ^2.0.11. En dev_dependencies agregar: build_runner: ^2.2.1, isar_generator: ^3.1.0. Ejecutar flutter pub get para instalar dependencias. Configurar build.yaml si es necesario para optimizaciones de generación de código.",
            "status": "done",
            "testStrategy": "Verificar que flutter pub get se ejecuta sin errores y que todas las dependencias se instalan correctamente",
            "updatedAt": "2025-10-24T17:57:39.377Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear esquemas de colecciones con anotaciones @collection",
            "description": "Definir los modelos de datos FastingSession, UserProfile, HydrationLog y ContentItem con sus campos y tipos correspondientes",
            "dependencies": [
              1
            ],
            "details": "Crear lib/models/ con archivos: fasting_session.dart (id, userId, startTime, endTime, durationMinutes, completed, interrupted, planType), user_profile.dart (id, weightKg, heightCm, dailyHydrationGoal calculado), hydration_log.dart (id, userId, amount, timestamp), content_item.dart (id, title, contentType, category, url, isPremium). Usar anotaciones @collection, @Id(), @Index() para optimización. Definir relaciones entre entidades usando @Backlink() donde sea apropiado.",
            "status": "done",
            "testStrategy": "Ejecutar dart run build_runner build para generar código y verificar que no hay errores de compilación en los esquemas",
            "parentId": "undefined",
            "updatedAt": "2025-10-24T17:58:09.523Z"
          },
          {
            "id": 3,
            "title": "Implementar DatabaseService singleton con inicialización de Isar",
            "description": "Crear servicio singleton para manejar la conexión a la base de datos Isar y operaciones CRUD básicas",
            "dependencies": [
              2
            ],
            "details": "Crear lib/services/database_service.dart como singleton. Implementar método initializeDatabase() que abra Isar con todos los esquemas definidos. Crear métodos CRUD básicos para cada colección: createFastingSession(), getUserProfile(), logHydration(), getContentItems(). Configurar índices compuestos para consultas frecuentes (userId + timestamp). Manejar errores de inicialización y proporcionar fallbacks apropiados.",
            "status": "done",
            "testStrategy": "Pruebas unitarias para verificar inicialización correcta de la base de datos, operaciones CRUD básicas y manejo de errores",
            "parentId": "undefined",
            "updatedAt": "2025-10-24T17:58:18.007Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on configurar base de datos isar v3.1.0 con esquemas principales.",
        "updatedAt": "2025-10-24T17:58:18.007Z"
      },
      {
        "id": "3",
        "title": "Configurar cliente Supabase con autenticación y RLS",
        "description": "Establecer conexión con Supabase, configurar autenticación email/password y políticas Row Level Security para aislamiento de datos",
        "details": "Instalar supabase_flutter ^2.0.0. Configurar client con URL y anon key desde environment variables. Implementar AuthService con métodos signUp, signIn, signOut, resetPassword. Crear tablas en Supabase: user_profiles, fasting_sessions, hydration_logs, learning_content, analytics_events. Configurar RLS policies: usuarios solo acceden a sus datos. Implementar manejo de errores Supabase específicos.",
        "testStrategy": "Pruebas de integración para auth flows, verificar RLS bloquea acceso no autorizado, probar conexión offline/online",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar cliente Supabase y variables de entorno",
            "description": "Instalar y configurar el cliente Supabase con credenciales de entorno",
            "dependencies": [],
            "details": "Instalar supabase_flutter ^2.0.0 en pubspec.yaml. Crear archivo .env con SUPABASE_URL y SUPABASE_ANON_KEY. Configurar flutter_dotenv para cargar variables. Inicializar cliente Supabase en main.dart con credenciales de entorno. Configurar manejo seguro de API keys.",
            "status": "pending",
            "testStrategy": "Verificar conexión exitosa con Supabase, probar carga de variables de entorno",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar AuthService con métodos de autenticación",
            "description": "Crear servicio de autenticación con todos los flujos requeridos",
            "dependencies": [
              1
            ],
            "details": "Crear AuthService class con métodos signUp, signIn, signOut, resetPassword. Implementar manejo de estados de autenticación con Stream. Configurar persistencia de sesión automática. Implementar validación de email y contraseña. Añadir manejo de errores específicos de Supabase Auth.",
            "status": "pending",
            "testStrategy": "Probar todos los flujos de autenticación, verificar persistencia de sesión, validar manejo de errores",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear estructura de tablas en Supabase",
            "description": "Configurar todas las tablas necesarias en la base de datos",
            "dependencies": [
              1
            ],
            "details": "Crear tablas: user_profiles (id, user_id, name, preferences), fasting_sessions (id, user_id, start_time, end_time, duration), hydration_logs (id, user_id, amount, timestamp), learning_content (id, title, content, category), analytics_events (id, user_id, event_name, properties, timestamp). Configurar relaciones foreign key apropiadas.",
            "status": "pending",
            "testStrategy": "Verificar creación correcta de tablas, probar relaciones entre tablas, validar constraints",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar políticas RLS para seguridad de datos",
            "description": "Implementar Row Level Security para aislamiento completo de datos de usuario",
            "dependencies": [
              3
            ],
            "details": "Habilitar RLS en todas las tablas de usuario. Crear políticas: usuarios solo pueden leer/escribir sus propios datos basado en auth.uid(). Configurar políticas específicas para user_profiles, fasting_sessions, hydration_logs, analytics_events. Crear políticas de lectura pública solo para learning_content.",
            "status": "pending",
            "testStrategy": "Probar que usuarios no pueden acceder a datos de otros, verificar políticas funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar manejo de errores y testing de flujos",
            "description": "Configurar manejo robusto de errores y testing completo del sistema",
            "dependencies": [
              2,
              4
            ],
            "details": "Crear SupabaseErrorHandler para manejar errores específicos (network, auth, database). Implementar retry logic para operaciones fallidas. Crear tests de integración para auth flows completos. Probar escenarios offline/online. Implementar logging de errores para debugging.",
            "status": "pending",
            "testStrategy": "Verificar manejo correcto de todos los tipos de error, probar resilience en conexiones pobres",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Dividir en setup de cliente Supabase, implementación de AuthService, configuración de tablas y RLS policies, manejo de errores específicos, y testing de flows de autenticación"
      },
      {
        "id": "4",
        "title": "Implementar servicio de fondo para persistencia del timer",
        "description": "Configurar flutter_background_service para mantener timer activo cuando app está cerrada o en background",
        "details": "Instalar flutter_background_service ^3.0.0. Configurar permisos Android (FOREGROUND_SERVICE, WAKE_LOCK) e iOS (background modes). Crear BackgroundTimerService que mantenga estado del ayuno en SharedPreferences. Implementar notificación persistente mostrando tiempo restante. Manejar reinicio del dispositivo y auto-start del servicio. Sincronizar estado con UI principal cuando app vuelve a foreground.",
        "testStrategy": "Probar timer continúa tras force-quit, verificar precisión ±5 segundos después de 16 horas, validar consumo batería <5% en 16h",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar dependencias y permisos del servicio de fondo",
            "description": "Instalar flutter_background_service y configurar todos los permisos necesarios para Android e iOS",
            "dependencies": [],
            "details": "Instalar flutter_background_service ^3.0.0 en pubspec.yaml. Configurar permisos Android: FOREGROUND_SERVICE, WAKE_LOCK, SYSTEM_ALERT_WINDOW en AndroidManifest.xml. Configurar iOS background modes en Info.plist: background-processing, background-fetch. Configurar workmanager para tareas periódicas. Agregar permisos de notificación local.",
            "status": "pending",
            "testStrategy": "Verificar que la app puede ejecutar en background sin crashes, probar permisos funcionan en ambas plataformas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar BackgroundTimerService con persistencia",
            "description": "Crear servicio que mantenga el estado del timer activo usando SharedPreferences y notificaciones",
            "dependencies": [
              1
            ],
            "details": "Crear BackgroundTimerService class que implemente flutter_background_service. Usar SharedPreferences para persistir: start_time, duration, fasting_state. Implementar timer que actualice cada minuto en background. Crear notificación persistente mostrando tiempo restante formateado. Implementar auto-start del servicio tras reinicio del dispositivo usando boot receiver (Android) y background app refresh (iOS).",
            "status": "pending",
            "testStrategy": "Probar que el timer continúa contando tras force-quit de la app, verificar notificación se actualiza correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Sincronizar estado entre servicio de fondo y UI principal",
            "description": "Implementar comunicación bidireccional entre el servicio de fondo y la interfaz de usuario",
            "dependencies": [
              2
            ],
            "details": "Crear TimerSyncService para manejar comunicación entre background service y UI. Implementar stream listeners para detectar cuando app vuelve a foreground. Sincronizar estado desde SharedPreferences al TimerProvider de Riverpod. Manejar casos edge: diferencias de tiempo, estados inconsistentes, recovery automático. Implementar heartbeat mechanism para validar que background service está activo.",
            "status": "pending",
            "testStrategy": "Verificar sincronización correcta cuando app vuelve a foreground, probar precisión del timer ±5 segundos después de períodos largos",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar servicio de fondo para persistencia del timer."
      },
      {
        "id": "5",
        "title": "Configurar OneSignal para notificaciones push",
        "description": "Integrar OneSignal para envío de notificaciones de ayuno, hidratación y engagement con segmentación de usuarios",
        "details": "Instalar onesignal_flutter ^5.0.0. Configurar OneSignal app ID y REST API key. Implementar NotificationService wrapper para OneSignal. Configurar permisos iOS (notification, remote-notification) y Android. Implementar manejo de deep links desde notificaciones. Crear templates para: inicio ayuno, hitos (4h, 8h, 12h, 16h), finalización, recordatorios hidratación, re-engagement.",
        "testStrategy": "Verificar notificaciones llegan en iOS y Android, probar deep linking funciona, validar entrega en background",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar SDK de OneSignal en el proyecto Flutter",
            "description": "Instalar y configurar el SDK de OneSignal en el proyecto Flutter con las dependencias necesarias",
            "dependencies": [],
            "details": "Añadir onesignal_flutter ^5.0.0 al pubspec.yaml. Configurar OneSignal app ID en las variables de entorno. Añadir REST API key para comunicación con OneSignal. Inicializar OneSignal en main.dart con la configuración básica. Verificar que la instalación sea correcta con logs de debug.",
            "status": "pending",
            "testStrategy": "Verificar que OneSignal se inicializa correctamente sin errores en los logs de debug",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar permisos de notificaciones por plataforma",
            "description": "Establecer permisos necesarios para notificaciones push en iOS y Android",
            "dependencies": [
              1
            ],
            "details": "Para iOS: añadir capabilities de notification y remote-notification en Runner.xcodeproj. Configurar Background Modes para notificaciones remotas. Para Android: añadir permisos INTERNET, VIBRATE y WAKE_LOCK en AndroidManifest.xml. Configurar notification channels para Android 8+. Implementar solicitud de permisos en tiempo de ejecución.",
            "status": "pending",
            "testStrategy": "Probar que se solicitan permisos correctamente en ambas plataformas y que las notificaciones llegan",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar templates de notificaciones para ayuno e hidratación",
            "description": "Crear templates predefinidos para diferentes tipos de notificaciones del ayuno y recordatorios",
            "dependencies": [
              2
            ],
            "details": "Crear NotificationService wrapper para OneSignal con métodos específicos. Implementar templates para: inicio de ayuno, hitos de progreso (4h, 8h, 12h, 16h), finalización de ayuno, recordatorios de hidratación, y mensajes de re-engagement. Configurar segmentación de usuarios basada en tipo de plan de ayuno. Personalizar mensajes según el progreso del usuario.",
            "status": "pending",
            "testStrategy": "Verificar que cada template se envía correctamente con el contenido apropiado según el contexto del usuario",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar manejo de deep links desde notificaciones",
            "description": "Configurar navegación automática a pantallas específicas cuando el usuario toca una notificación",
            "dependencies": [
              3
            ],
            "details": "Configurar deep linking scheme en iOS (Info.plist) y Android (AndroidManifest.xml). Implementar handler de notificaciones que detecte cuando la app se abre desde una notificación. Crear routing automático a pantallas específicas: dashboard de ayuno, pantalla de hidratación, configuración, etc. Manejar casos cuando la app está cerrada, en background o en foreground. Pasar datos adicionales a través de la notificación.",
            "status": "pending",
            "testStrategy": "Probar que las notificaciones abren las pantallas correctas en todos los estados de la app (cerrada, background, foreground)",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en setup inicial de OneSignal SDK, configuración de permisos por plataforma, implementación de templates de notificaciones, y manejo de deep links desde notificaciones"
      },
      {
        "id": "6",
        "title": "Implementar sistema de autenticación con Supabase Auth",
        "description": "Crear flujos completos de registro, login y logout con validación de email y manejo de estados de sesión",
        "details": "Crear AuthService con métodos async para signUp, signIn, signOut usando Supabase Auth. Implementar validación email format, password strength (8+ caracteres). Crear Riverpod authStateProvider que exponga User? y isAuthenticated. Manejar estados loading, error, success. Implementar auto-login si sesión válida existe. Crear pantallas LoginScreen y RegisterScreen con formularios responsive.",
        "testStrategy": "Pruebas unitarias para validaciones, pruebas de integración para flows completos, verificar sesión persiste tras reinicio app",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Auth y crear servicio base de autenticación",
            "description": "Configurar la instancia de Supabase en el proyecto Flutter e implementar la clase AuthService con los métodos básicos de autenticación",
            "dependencies": [],
            "details": "Instalar dependencias supabase_flutter. Configurar SUPABASE_URL y SUPABASE_ANON_KEY en variables de entorno. Crear clase AuthService con SupabaseClient instance. Implementar métodos async signUp(email, password), signIn(email, password), signOut(), getCurrentUser(). Agregar validaciones básicas de email format usando RegExp y password strength (mínimo 8 caracteres). Manejar SupabaseException y retornar Result<User, AuthError> custom types.",
            "status": "pending",
            "testStrategy": "Pruebas unitarias para validaciones de email y password. Pruebas de integración para métodos de Auth con mocks de Supabase. Verificar manejo correcto de errores.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar estado global de autenticación con Riverpod",
            "description": "Crear providers de Riverpod para manejar el estado de autenticación y sesión del usuario en toda la aplicación",
            "dependencies": [
              1
            ],
            "details": "Crear authStateProvider usando StateNotifierProvider que exponga AuthState{User? user, bool isLoading, String? error, bool isAuthenticated}. Implementar AuthStateNotifier que utilice AuthService y escuche cambios de sesión via Supabase.auth.onAuthStateChange. Crear computed provider isAuthenticatedProvider que retorne bool. Implementar auto-login verificando sesión existente al iniciar app. Manejar estados de loading durante operaciones async.",
            "status": "pending",
            "testStrategy": "Pruebas unitarias para AuthStateNotifier. Probar que isAuthenticated se actualiza correctamente. Verificar auto-login funciona tras reinicio de app.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear pantallas de Login y Registro con formularios validados",
            "description": "Desarrollar las interfaces de usuario para login y registro con validación en tiempo real y manejo de estados",
            "dependencies": [
              2
            ],
            "details": "Crear LoginScreen y RegisterScreen con formularios usando TextFormField y GlobalKey<FormState>. Implementar validación en tiempo real para email y password con visual feedback. Agregar botones con loading states que consumen authStateProvider. Implementar navigation entre pantallas y redirect automático tras login exitoso. Diseño responsive con constraints para diferentes tamaños de pantalla. Agregar error messages user-friendly y loading indicators durante auth operations.",
            "status": "pending",
            "testStrategy": "Pruebas de widget para pantallas de login/registro. Verificar validación funciona correctamente. Probar navigation flows y estados de loading/error.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de autenticación con supabase auth."
      },
      {
        "id": "7",
        "title": "Crear modelo FastingSession en Isar",
        "description": "Definir esquema completo para sesiones de ayuno con campos para tracking, estado y sincronización",
        "details": "Crear @collection class FastingSession con campos: Id id (auto-increment), String userId, DateTime startTime, DateTime? endTime, int durationMinutes, bool completed, bool interrupted, String? planType, DateTime createdAt, DateTime updatedAt, int? syncVersion. Agregar métodos helper para calcular elapsed time, progress percentage, isActive. Implementar toJson/fromJson para sync con Supabase.",
        "testStrategy": "Pruebas unitarias para cálculos de tiempo, verificar serialización JSON correcta, probar queries por userId y dateRange",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir esquema y anotaciones de la clase FastingSession",
            "description": "Crear la estructura básica de la clase FastingSession con todas las anotaciones Isar requeridas y campos principales",
            "dependencies": [],
            "details": "Crear archivo fasting_session.dart con @collection class FastingSession. Definir campos: Id id (auto-increment), String userId, DateTime startTime, DateTime? endTime, int durationMinutes, bool completed, bool interrupted, String? planType, DateTime createdAt, DateTime updatedAt, int? syncVersion. Agregar imports necesarios de Isar y anotaciones @Index para userId y timestamp.",
            "status": "pending",
            "testStrategy": "Verificar que el esquema compile correctamente y genere código Isar sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar métodos helper para cálculos de tiempo",
            "description": "Agregar métodos de utilidad para calcular tiempo transcurrido, porcentaje de progreso y estado activo de la sesión",
            "dependencies": [
              1
            ],
            "details": "Implementar getters y métodos: Duration get elapsedTime (calcula tiempo desde startTime), double get progressPercentage (elapsed/duration * 100), bool get isActive (startTime != null && endTime == null), bool get isCompleted (completed == true). Manejar casos edge como sesiones interrumpidas y cálculos con endTime null.",
            "status": "pending",
            "testStrategy": "Pruebas unitarias para cada método calculando escenarios diversos: sesiones activas, completadas, interrumpidas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar serialización JSON para sincronización con Supabase",
            "description": "Crear métodos toJson y fromJson para permitir sincronización bidireccional con la base de datos Supabase",
            "dependencies": [
              1
            ],
            "details": "Implementar Map<String, dynamic> toJson() convirtiendo todos los campos a formato JSON compatible con Supabase. Crear factory FastingSession.fromJson(Map<String, dynamic> json) manejando conversiones de DateTime y campos nullable. Asegurar compatibilidad con campos syncVersion para control de versiones.",
            "status": "pending",
            "testStrategy": "Verificar serialización correcta round-trip (toJson -> fromJson), validar compatibilidad con formato Supabase",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear modelo fastingsession en isar."
      },
      {
        "id": "8",
        "title": "Desarrollar TimerService con lógica de ayuno",
        "description": "Implementar servicio central para gestionar estado del timer, inicio/pausa/finalización de ayunos con persistencia",
        "details": "Crear TimerService como singleton con Stream<FastingState> para reactive updates. Implementar métodos: startFast(planType), pauseFast(), resumeFast(), completeFast(), interruptFast(). Usar Timer.periodic para updates cada segundo. Persistir estado en Isar y background service. Manejar edge cases: cambio de timezone, reinicio de dispositivo. Implementar FastingState enum (idle, fasting, paused, completed).",
        "testStrategy": "Probar precisión de timer, verificar estado persiste tras app kill, validar transiciones de estado correctas",
        "priority": "high",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar FastingState enum y TimerService singleton base",
            "description": "Crear la estructura fundamental del TimerService incluyendo el enum FastingState y la configuración básica del singleton",
            "dependencies": [],
            "details": "Crear FastingState enum con valores (idle, fasting, paused, completed). Implementar TimerService como singleton con Stream<FastingState> para reactive updates. Configurar estructura básica de la clase con propiedades necesarias: currentState, startTime, duration, planType. Establecer constructor privado y getInstance() method para singleton pattern.",
            "status": "pending",
            "testStrategy": "Probar que singleton retorna misma instancia, verificar estado inicial es idle, validar stream emite cambios correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar métodos de control del timer y Timer.periodic",
            "description": "Implementar todos los métodos de control del ayuno y el sistema de actualización automática cada segundo",
            "dependencies": [
              1
            ],
            "details": "Implementar métodos: startFast(planType), pauseFast(), resumeFast(), completeFast(), interruptFast(). Crear Timer.periodic que actualiza cada segundo y emite nuevos estados. Manejar lógica de transiciones entre estados válidos. Calcular tiempo transcurrido y restante. Implementar auto-completion cuando timer llega a cero.",
            "status": "pending",
            "testStrategy": "Probar precisión del timer con updates cada segundo, verificar transiciones de estado correctas, validar métodos responden apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar persistencia con Isar y manejo de edge cases",
            "description": "Implementar persistencia del estado en Isar y manejar casos especiales como cambios de timezone y reinicios",
            "dependencies": [
              2
            ],
            "details": "Integrar TimerService con Isar para persistir estado del timer y FastingSession. Implementar saveState() y loadState() methods. Manejar edge cases: cambio de timezone (recalcular times), reinicio de dispositivo (restaurar estado desde DB), background service integration. Implementar recovery logic para estados inconsistentes.",
            "status": "pending",
            "testStrategy": "Probar estado persiste tras app kill, verificar recovery después de reinicio, validar manejo correcto de timezone changes",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar timerservice con lógica de ayuno."
      },
      {
        "id": "9",
        "title": "Crear pantalla de selección de planes de ayuno",
        "description": "Diseñar UI para elegir entre planes predefinidos (12/12, 14/10, 16/8, 18/6, 24h, 48h) con descripción y nivel de dificultad",
        "details": "Crear PlanSelectionScreen con ListView de FastingPlanCard widgets. Mostrar para cada plan: nombre, duración ayuno/comida, nivel dificultad (principiante/intermedio/avanzado), descripción beneficios, recomendado para (pérdida grasa/autofagia). Implementar selección visual con Material 3 selection states. Crear FastingPlan model con datos predefinidos. Guardar selección en UserProfile.",
        "testStrategy": "Verificar UI responsive en diferentes tamaños pantalla, probar selección persiste, validar accesibilidad con TalkBack/VoiceOver",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo FastingPlan y datos predefinidos",
            "description": "Implementar la estructura de datos para los planes de ayuno con toda la información necesaria para mostrar en la UI",
            "dependencies": [],
            "details": "Crear clase FastingPlan con propiedades: nombre, duración de ayuno, duración de comida, nivel de dificultad (enum), descripción de beneficios, recomendado para (pérdida de grasa/autofagia), icono. Definir lista de planes predefinidos: 12/12, 14/10, 16/8, 18/6, 24h, 48h con sus respectivos datos completos. Incluir validaciones de datos y métodos de serialización JSON.",
            "status": "pending",
            "testStrategy": "Verificar que todos los planes tienen datos completos, probar serialización/deserialización JSON, validar enum values correctos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar widget FastingPlanCard con Material 3",
            "description": "Crear componente reutilizable para mostrar información de cada plan de ayuno con estados de selección visual",
            "dependencies": [
              1
            ],
            "details": "Crear FastingPlanCard widget que muestre nombre del plan, duración ayuno/comida, nivel de dificultad con badge colorido, descripción de beneficios y para qué está recomendado. Implementar estados visuales de Material 3: normal, hover, pressed, selected. Usar Card con elevation y border radius apropiados. Agregar animaciones suaves de transición entre estados (250ms). Soportar temas claro y oscuro.",
            "status": "pending",
            "testStrategy": "Probar estados visuales funcionan correctamente, verificar animaciones fluidas, validar accesibilidad con semantic labels",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar PlanSelectionScreen con selección y persistencia",
            "description": "Crear pantalla completa con lista de planes, manejo de selección y guardado en UserProfile",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear PlanSelectionScreen con ListView de FastingPlanCard widgets. Implementar selección single-choice con estado visual claro. Agregar AppBar con título y botón confirmar. Manejar selección con StatefulWidget o Riverpod provider. Guardar plan seleccionado en UserProfile y persistir en storage local. Implementar navegación de regreso con resultado. Agregar loading states durante guardado.",
            "status": "pending",
            "testStrategy": "Verificar selección funciona correctamente, probar persistencia de datos, validar UI responsive en diferentes tamaños de pantalla",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear pantalla de selección de planes de ayuno."
      },
      {
        "id": "10",
        "title": "Desarrollar pantalla principal FastingHomeScreen",
        "description": "Crear UI principal mostrando timer grande, progreso del ayuno, botones de control y estado actual",
        "details": "Crear FastingHomeScreen con timer central (48sp, bold, color dinámico según estado). Mostrar progress ring circular o linear bar. Implementar botones Start/Stop/Pause con estados visuales claros. Mostrar información contextual: tiempo transcurrido/restante, fase actual (ayuno/comida), próximo hito. Usar Riverpod fastingTimerProvider para estado reactivo. Agregar animaciones suaves (250ms transitions).",
        "testStrategy": "Probar UI actualiza en tiempo real, verificar botones responden correctamente, validar animaciones fluidas 60fps",
        "priority": "high",
        "dependencies": [
          "8",
          "9",
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar componente de timer central con diseño visual dinámico",
            "description": "Crear el componente principal del timer que mostrará el tiempo transcurrido/restante con tipografía grande y colores que cambien según el estado del ayuno",
            "dependencies": [],
            "details": "Implementar widget de timer central con texto de 48sp en fuente bold. Aplicar colores dinámicos según estado: verde para ayuno activo, azul para ventana de comida, gris para pausado. Mostrar formato hh:mm:ss. Integrar con fastingTimerProvider de Riverpod para actualizaciones reactivas en tiempo real. Usar AnimatedDefaultTextStyle para transiciones suaves de color.",
            "status": "pending",
            "testStrategy": "Verificar que el timer se actualiza cada segundo, probar cambios de color según estado, validar formato de tiempo correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar indicador de progreso circular y botones de control",
            "description": "Crear el anillo de progreso circular alrededor del timer y implementar los botones de Start/Stop/Pause con estados visuales claros",
            "dependencies": [
              1
            ],
            "details": "Implementar CircularProgressIndicator customizado que muestre progreso del ayuno actual. Crear botones de control con estados visuales distintos: Start (verde), Pause (amarillo), Stop (rojo). Usar IconButton con Material 3 design y elevated button style. Agregar haptic feedback en button presses. Implementar lógica para mostrar/ocultar botones según estado actual.",
            "status": "pending",
            "testStrategy": "Probar que botones responden correctamente, verificar estados visuales apropiados, validar haptic feedback funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar información contextual y animaciones de transición",
            "description": "Añadir información contextual sobre la fase actual del ayuno, próximos hitos y implementar animaciones suaves para todas las transiciones",
            "dependencies": [
              1,
              2
            ],
            "details": "Mostrar información contextual: fase actual (ayuno/ventana de comida), tiempo transcurrido vs restante, próximo hito temporal. Crear widgets informativos con Typography.bodyMedium. Implementar AnimatedSwitcher y AnimatedContainer para transiciones de 250ms. Agregar subtle micro-interactions y state changes animations. Usar Curves.easeInOut para transiciones naturales.",
            "status": "pending",
            "testStrategy": "Verificar animaciones fluidas a 60fps, probar información contextual se actualiza correctamente, validar transiciones suaves entre estados",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar pantalla principal fastinghomescreen."
      },
      {
        "id": "11",
        "title": "Implementar botón de pánico como FloatingActionButton",
        "description": "Crear botón pánico persistente que aparece solo durante ayuno activo para apoyo emocional en momentos de antojos",
        "details": "Crear PanicButton como FloatingActionButton naranja (#ffb366) de 64×64dp con icono corazón o SOS. Mostrar solo cuando fastingState == fasting. Implementar animación pulse sutil (no distractiva). Posicionar en bottom-right con elevation 8dp. Al tap, abrir PanicModal con opciones: frases motivacionales, meditación respiración, opción 'No puedo continuar'. Trackear eventos panic_button_used en analytics.",
        "testStrategy": "Verificar botón solo visible durante ayuno, probar animación no afecta rendimiento, validar analytics tracking",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente PanicButton con FloatingActionButton",
            "description": "Implementar el componente visual del botón de pánico como FloatingActionButton con estilo específico",
            "dependencies": [],
            "details": "Crear widget PanicButton que extienda FloatingActionButton con color naranja (#ffb366), tamaño 64×64dp, icono de corazón o SOS. Posicionar en bottom-right de la pantalla con elevation 8dp. Implementar visibilidad condicional basada en fastingState == fasting usando Consumer/Riverpod.",
            "status": "pending",
            "testStrategy": "Verificar que el botón se muestra solo durante ayuno activo y tiene el estilo visual correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar animación pulse sutil para el botón",
            "description": "Agregar animación de pulso no distractiva al FloatingActionButton para atraer atención sin ser molesto",
            "dependencies": [
              1
            ],
            "details": "Implementar AnimationController con Tween para crear efecto pulse sutil. Usar Transform.scale con values entre 1.0 y 1.1, duración 1.5-2 segundos, repeat infinito. Aplicar CurvedAnimation con Curves.easeInOut para transición suave. Optimizar para no afectar rendimiento usando SingleTickerProviderStateMixin.",
            "status": "pending",
            "testStrategy": "Probar que la animación no afecta el rendimiento y es visualmente apropiada",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar analytics tracking para eventos del botón",
            "description": "Implementar seguimiento de analytics cuando el usuario interactúa con el botón de pánico",
            "dependencies": [
              1
            ],
            "details": "Agregar evento 'panic_button_used' al AnalyticsService existente. Incluir metadata: timestamp, duración actual del ayuno, tipo de ayuno activo. Llamar analytics tracking en onPressed callback del FloatingActionButton. Usar patrón fire-and-forget para no bloquear UI. Considerar batching de eventos si es necesario.",
            "status": "pending",
            "testStrategy": "Verificar que los eventos se registran correctamente en analytics sin afectar la experiencia de usuario",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar botón de pánico como floatingactionbutton."
      },
      {
        "id": "12",
        "title": "Crear modal de pánico con contenido motivacional",
        "description": "Desarrollar overlay que se muestra al presionar botón pánico con quotes motivacionales y opciones de apoyo",
        "details": "Crear PanicModal como full-screen overlay con blur background. Mostrar frase motivacional aleatoria de categories: motivation, anti_binge, calm. Incluir botones: 'Meditar 5 min', 'Continuar ayuno', 'No puedo seguir'. Implementar repository MotivationalPhrasesRepository que fetch desde Supabase o cache local. Agregar ilustraciones calm/zen. Usar Material 3 modal design patterns.",
        "testStrategy": "Probar modal aparece rápidamente, verificar frases cargan offline, validar UX no es intrusiva pero efectiva",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar PanicModal con diseño full-screen overlay",
            "description": "Crear el componente PanicModal como full-screen overlay con blur background siguiendo patrones de Material 3 modal design",
            "dependencies": [],
            "details": "Crear PanicModal widget que ocupe toda la pantalla con blur background effect. Implementar diseño responsivo con padding apropiado. Usar Material 3 modal design patterns con elevation y animaciones de entrada/salida. Agregar ilustraciones calm/zen en la parte superior. Configurar dismiss behavior y accessibility features. Asegurar que el modal se muestre correctamente sobre todo el contenido existente.",
            "status": "pending",
            "testStrategy": "Probar que el modal aparece rápidamente al activarse, verificar blur effect funciona correctamente, validar diseño responsivo en diferentes tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar MotivationalPhrasesRepository para gestión de frases",
            "description": "Implementar repositorio que gestione frases motivacionales desde Supabase con cache local para acceso offline",
            "dependencies": [
              1
            ],
            "details": "Crear MotivationalPhrasesRepository con métodos: getRandomPhrase(category), loadPhrasesFromSupabase(), cachePhrasesLocally(). Implementar model MotivationalPhrase con campos: id, text, category (motivation, anti_binge, calm), language. Configurar cache local usando Shared Preferences o Hive para acceso offline. Implementar fallback phrases en caso de no connectivity. Manejar categorización y filtrado de frases según contexto.",
            "status": "pending",
            "testStrategy": "Verificar frases cargan desde Supabase correctamente, probar funcionamiento offline con cache local, validar categorización funciona apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar botones de acción y lógica de respuesta del modal",
            "description": "Crear botones de acción 'Meditar 5 min', 'Continuar ayuno', 'No puedo seguir' con navegación y lógica correspondiente",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar tres botones principales con Material 3 styling: 'Meditar 5 min' (navega a timer meditación), 'Continuar ayuno' (cierra modal y continúa timer), 'No puedo seguir' (pausa/termina sesión con confirmación). Agregar ripple effects y estados hover/pressed. Implementar NavigationService calls para routing apropiado. Manejar estados de loading durante acciones. Integrar analytics tracking para user actions en panic modal.",
            "status": "pending",
            "testStrategy": "Probar navegación de botones funciona correctamente, verificar confirmaciones para acciones destructivas, validar UX no es intrusiva pero efectiva",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear modal de pánico con contenido motivacional."
      },
      {
        "id": "13",
        "title": "Implementar animación de respiración 4-4-8 con Lottie",
        "description": "Crear pantalla de meditación guiada con animación visual para técnica de respiración 4-4-8 (inhalar-mantener-exhalar)",
        "details": "Instalar lottie ^2.7.0. Crear MeditationScreen con Lottie widget mostrando círculo/pulmones que expande (4s inhale), mantiene (4s hold), contrae (8s exhale). Agregar text overlay con instrucciones 'Inhala', 'Mantén', 'Exhala'. Implementar contador de ciclos completados. Botones: 'Parar meditación', 'Continuar ayuno', 'No puedo seguir'. Asset Lottie <100KB para rendimiento. Colores teal/verde zen.",
        "testStrategy": "Verificar animación 60fps en dispositivos mid-range, probar timing preciso 4-4-8, validar transiciones suaves",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencia Lottie y configurar assets",
            "description": "Agregar la dependencia lottie 2.7.0 al proyecto y preparar los assets de animación necesarios para la respiración",
            "dependencies": [],
            "details": "Ejecutar 'flutter pub add lottie:^2.7.0' para instalar la dependencia. Crear carpeta assets/animations/ y agregar archivo breathing_animation.json con animación de círculo/pulmones que expande y contrae. El asset debe ser menor a 100KB para optimizar rendimiento. Configurar pubspec.yaml para incluir los assets. Usar colores teal/verde zen (#4DB6AC, #66BB6A) en la animación.",
            "status": "pending",
            "testStrategy": "Verificar que la dependencia se instala correctamente y que el asset Lottie se carga sin errores en la aplicación",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear MeditationScreen con widget Lottie y controles de tiempo",
            "description": "Desarrollar la pantalla principal de meditación con la animación Lottie y lógica de timing para el patrón 4-4-8",
            "dependencies": [
              1
            ],
            "details": "Crear MeditationScreen como StatefulWidget. Implementar Lottie.asset() widget para mostrar animación. Desarrollar controlador de timing con tres fases: inhalar (4s), mantener (4s), exhalar (8s). Usar AnimationController para sincronizar timing con animación Lottie. Agregar overlay de texto que muestre 'Inhala', 'Mantén', 'Exhala' según fase actual. Implementar contador de ciclos completados con display visible.",
            "status": "pending",
            "testStrategy": "Probar que la animación se reproduce correctamente con timing preciso de 4-4-8 segundos y que el texto overlay cambia apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar botones de control y navegación",
            "description": "Agregar botones de control para gestionar la sesión de meditación y navegar según las decisiones del usuario",
            "dependencies": [
              2
            ],
            "details": "Implementar tres botones en la parte inferior de la pantalla: 'Parar meditación' (detiene animación y regresa a pantalla anterior), 'Continuar ayuno' (completa meditación y regresa al timer), 'No puedo seguir' (abre modal de soporte o interrumpe ayuno). Usar colores consistentes con el tema zen (teal/verde). Agregar confirmaciones para acciones destructivas. Integrar con el sistema de navegación existente y FastingState management.",
            "status": "pending",
            "testStrategy": "Verificar que todos los botones funcionan correctamente y navegan a las pantallas apropiadas sin errores",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar animación de respiración 4-4-8 con lottie."
      },
      {
        "id": "14",
        "title": "Crear biblioteca de frases motivacionales",
        "description": "Desarrollar repository y modelo para gestionar frases motivacionales categorizadas para el botón pánico",
        "details": "Crear MotivationalPhrase model con fields: id, phraseText, category (motivation/anti_binge/calm), language. Implementar MotivationalPhrasesRepository con métodos: getRandomByCategory(), getAllByLanguage(). Seed data con 15+ frases en español cubrir categories. Implementar cache local en Isar para offline access. Sync desde Supabase motivational_phrases table. Manejar fallbacks si no hay conexión.",
        "testStrategy": "Verificar frases random no se repiten consecutivamente, probar funciona offline, validar sync bidireccional",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo MotivationalPhrase y configurar base de datos",
            "description": "Implementar el modelo de datos para frases motivacionales con todos los campos necesarios y configurar la estructura en Isar y Supabase",
            "dependencies": [],
            "details": "Crear MotivationalPhrase model con campos: id (String), phraseText (String), category (enum: motivation/anti_binge/calm), language (String, default 'es'). Definir schema Isar con índices apropiados por category y language. Crear tabla motivational_phrases en Supabase con misma estructura. Implementar serialización/deserialización JSON para sync.",
            "status": "pending",
            "testStrategy": "Verificar modelo se guarda/recupera correctamente en Isar, probar serialización JSON, validar constraints de campos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar MotivationalPhrasesRepository con métodos core",
            "description": "Desarrollar repository con métodos principales para gestionar frases motivacionales incluyendo obtención aleatoria y filtrado por idioma",
            "dependencies": [
              1
            ],
            "details": "Implementar MotivationalPhrasesRepository con métodos: getRandomByCategory(category) que evite repetir última frase, getAllByLanguage(language), addPhrase(), deletePhrase(), syncFromSupabase(). Usar Isar queries optimizadas. Implementar lógica anti-repetición guardando última frase mostrada. Manejar cache local y fallbacks cuando no hay datos.",
            "status": "pending",
            "testStrategy": "Probar getRandomByCategory no repite frases consecutivamente, verificar filtrado por idioma funciona, validar métodos CRUD",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Poblar base de datos y configurar sincronización",
            "description": "Crear seed data con frases motivacionales en español y implementar sincronización automática con Supabase",
            "dependencies": [
              2
            ],
            "details": "Crear seed data con 15+ frases en español distribuidas en categories: 5+ motivation, 5+ anti_binge, 5+ calm. Implementar auto-sync desde Supabase motivational_phrases table al iniciar app. Configurar sync bidireccional cuando usuario agrega frases custom. Implementar fallback a frases hardcoded si no hay conexión ni datos locales. Manejar errores de red gracefully.",
            "status": "pending",
            "testStrategy": "Verificar seed data se carga correctamente, probar funciona offline con frases locales, validar sync bidireccional con Supabase",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear biblioteca de frases motivacionales."
      },
      {
        "id": "15",
        "title": "Implementar gestión de sesiones (completar/interrumpir ayuno)",
        "description": "Desarrollar lógica para finalizar ayunos correctamente, guardar métricas y actualizar historial del usuario",
        "details": "Extender TimerService con completeFast() e interruptFast() methods. Al completar: marcar session.completed = true, calcular duration final, save to Isar, trigger metrics recalculation, mostrar congratulations UI, sync to Supabase. Al interrumpir: marcar interrupted = true, save partial session, preguntar razón (opcional), no penalizar métricas severamente. Implementar SessionManager para orchestrate estos flows.",
        "testStrategy": "Verificar sessions se guardan correctamente, probar sync funciona, validar métricas se actualizan apropiadamente",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extender TimerService con métodos completeFast() e interruptFast()",
            "description": "Implementar los métodos principales en TimerService para gestionar la finalización e interrupción de ayunos con toda la lógica de negocio requerida",
            "dependencies": [],
            "details": "Agregar completeFast() method que marque session.completed = true, calcule duration final y trigger todos los flows de completion. Implementar interruptFast() method que marque session.interrupted = true, guarde partial session y maneje el flow de interrupción. Ambos métodos deben actualizar el estado interno del TimerService y notificar a los listeners apropiados.",
            "status": "pending",
            "testStrategy": "Verificar que ambos métodos actualicen correctamente el estado de la sesión, probar que se calculan las duraciones apropiadamente y validar que los listeners son notificados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar persistencia y sincronización de sesiones",
            "description": "Desarrollar la lógica para guardar sesiones completadas/interrumpidas en Isar y sincronizar con Supabase",
            "dependencies": [
              1
            ],
            "details": "Al completar ayuno: guardar session en Isar con completed=true y duration final, trigger recalculation de métricas, sync a Supabase. Al interrumpir: guardar partial session con interrupted=true, opcional reason field, no penalizar métricas severamente. Implementar error handling para sync failures y retry logic apropiado.",
            "status": "pending",
            "testStrategy": "Probar que las sesiones se guardan correctamente en Isar, verificar sync a Supabase funciona, validar que métricas se actualizan apropiadamente tras completion",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear SessionManager para orchestrar flows y UI de completion",
            "description": "Desarrollar SessionManager central que coordine los flows de completion/interrupción y mostrar UI apropiada",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar SessionManager que orchestrate calls a TimerService y maneje UI flows. Para completion: mostrar congratulations UI con estadísticas del ayuno completado. Para interrupción: mostrar dialog preguntando razón opcional con opciones predefinidas. Coordinar con navigation para transitions apropiadas y state management.",
            "status": "pending",
            "testStrategy": "Verificar que SessionManager coordina correctamente los flows, probar que congratulations UI aparece tras completion exitoso, validar que interruption dialog funciona apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar gestión de sesiones (completar/interrumpir ayuno)."
      },
      {
        "id": "16",
        "title": "Crear modelo UserProfile con cálculo de hidratación",
        "description": "Implementar perfil de usuario con peso, altura y cálculo automático de meta diaria de hidratación",
        "details": "Crear @collection UserProfile con fields: String id (auth user id), double weightKg, int? heightCm, int dailyHydrationGoal (computed), DateTime createdAt, DateTime updatedAt. Implementar getter que calcula hydration goal: weightKg * 32 ml. Crear UserProfileRepository con CRUD operations y sync con Supabase user_profiles table. Manejar conversiones unidades si necesario (kg/lbs).",
        "testStrategy": "Verificar cálculo hidratación correcto (ej: 70kg = 2240ml), probar updates se sincronizan, validar datos persisten",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir esquema UserProfile con campos básicos",
            "description": "Crear la clase UserProfile con decorador @collection de Isar y definir todos los campos necesarios para el perfil de usuario",
            "dependencies": [],
            "details": "Implementar @collection class UserProfile con campos: String id (auth user id), double weightKg, int? heightCm, DateTime createdAt, DateTime updatedAt. Configurar índices apropiados y relaciones con auth user. Definir constraints de validación para peso y altura.",
            "status": "pending",
            "testStrategy": "Verificar que el schema se crea correctamente, probar validaciones de campos, confirmar índices funcionan",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar cálculo automático de meta de hidratación",
            "description": "Agregar getter dailyHydrationGoal que calcule automáticamente la meta diaria basada en el peso del usuario",
            "dependencies": [
              1
            ],
            "details": "Implementar getter int get dailyHydrationGoal que calcule weightKg * 32 ml. Manejar casos edge como peso nulo o inválido. Agregar método helper para convertir entre unidades (kg/lbs) si es necesario. Documentar fórmula utilizada.",
            "status": "pending",
            "testStrategy": "Verificar cálculo correcto (ej: 70kg = 2240ml), probar casos edge con pesos extremos, validar conversiones de unidades",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear UserProfileRepository con operaciones CRUD y sync Supabase",
            "description": "Implementar repositorio completo para manejar operaciones de base de datos local y sincronización con Supabase",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear UserProfileRepository con métodos: create, read, update, delete, getByUserId. Implementar sync bidireccional con tabla user_profiles de Supabase. Manejar conflictos de sincronización y offline storage. Agregar toJson/fromJson para serialización.",
            "status": "pending",
            "testStrategy": "Probar CRUD operations funcionan correctamente, verificar sync con Supabase, validar manejo de conflictos y offline persistence",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear modelo userprofile con cálculo de hidratación."
      },
      {
        "id": "17",
        "title": "Desarrollar servicio de hidratación (HydrationService)",
        "description": "Implementar lógica para tracking de ingesta de agua, metas diarias y cálculo de progreso",
        "details": "Crear HydrationService con métodos: logWater(amount), getTodayProgress(), getDailyGoal(), resetDaily(). Implementar HydrationLog model: id, userId, amount, timestamp, glassSize. Calcular progreso como percentage: totalToday / dailyGoal * 100. Manejar timezone changes y reset automático daily a medianoche. Integrar con UserProfile para goal dinámico.",
        "testStrategy": "Probar logging agua actualiza progreso correctamente, verificar reset diario funciona, validar cálculos precisos",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar modelo HydrationLog y esquema de base de datos",
            "description": "Crear el modelo de datos HydrationLog con todos los campos necesarios para el tracking de hidratación",
            "dependencies": [],
            "details": "Definir HydrationLog model con campos: id (String), userId (String), amount (double), timestamp (DateTime), glassSize (int). Configurar esquema en Isar database con indexes apropiados para queries por userId y timestamp. Implementar métodos de serialización/deserialización. Agregar validaciones para amount > 0 y glassSize válido (150-500ml). Configurar relación con UserProfile.",
            "status": "pending",
            "testStrategy": "Verificar modelo se persiste correctamente en Isar, probar queries por userId y fecha, validar constraints de datos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar métodos core del HydrationService",
            "description": "Implementar la lógica principal del servicio de hidratación con todos los métodos requeridos",
            "dependencies": [
              1
            ],
            "details": "Crear HydrationService con métodos: logWater(amount, glassSize) que persiste nuevo HydrationLog, getTodayProgress() que suma amount del día actual, getDailyGoal() que obtiene meta desde UserProfile, resetDaily() que limpia logs antiguos. Implementar cálculo de progreso como percentage: totalToday / dailyGoal * 100. Manejar timezone correctamente usando DateTime.now() local.",
            "status": "pending",
            "testStrategy": "Probar logWater actualiza progreso, verificar getTodayProgress suma correctamente, validar cálculo de percentage preciso",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar reset automático diario y integración con UserProfile",
            "description": "Configurar el sistema de reset automático nocturno y conectar con el perfil de usuario para metas dinámicas",
            "dependencies": [
              2
            ],
            "details": "Implementar WorkManager job para reset diario a medianoche (00:00 local time). Crear listener para timezone changes que recalcula next reset time. Integrar con UserProfile para obtener dailyGoal dinámico basado en peso/actividad. Implementar background task que limpia logs antiguos (>30 días) para optimizar storage. Agregar notification opcional para recordatorio de hidratación.",
            "status": "pending",
            "testStrategy": "Verificar reset automático funciona a medianoche, probar timezone changes no rompen reset, validar integración con UserProfile actualiza metas",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar servicio de hidratación (hydrationservice)."
      },
      {
        "id": "18",
        "title": "Crear WaterButton widget para logging rápido",
        "description": "Desarrollar botón flotante para registrar ingesta de agua con un tap, mostrando progreso visual",
        "details": "Crear WaterButton como FloatingActionButton 56×56dp en bottom-left corner. Color azul/teal. Al tap: log glass default (250ml), mostrar ripple animation + haptic feedback, update progress instantáneamente. Implementar debouncing para evitar double-taps. Mostrar badge con progreso percentage. Long-press para ajustar glass size. Considerar accessibility labels para screen readers.",
        "testStrategy": "Verificar no hay double-logging, probar haptic feedback funciona, validar accesibilidad con VoiceOver/TalkBack",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente WaterButton base con FloatingActionButton",
            "description": "Implementar el widget base WaterButton como FloatingActionButton con diseño y posicionamiento específico",
            "dependencies": [],
            "details": "Crear archivo water_button.dart con StatefulWidget WaterButton. Implementar FloatingActionButton con tamaño 56×56dp, color azul/teal, posicionado en bottom-left corner. Agregar icono de gota de agua. Configurar shape circular y elevation apropiada. Implementar onPressed callback básico para navegación o logging.",
            "status": "pending",
            "testStrategy": "Verificar tamaño correcto del botón, posicionamiento bottom-left, color azul/teal aplicado correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar funcionalidad de logging y feedback visual",
            "description": "Agregar lógica de logging de agua con animaciones, haptic feedback y debouncing",
            "dependencies": [
              1
            ],
            "details": "Integrar con HydrationService para logWater(250ml) al tap. Implementar ripple animation con InkWell/Material. Agregar HapticFeedback.lightImpact() al tap. Implementar debouncing con Timer para evitar double-taps (300ms delay). Mostrar feedback visual temporal como SnackBar o toast indicando cantidad logged.",
            "status": "pending",
            "testStrategy": "Probar no hay double-logging con taps rápidos, verificar haptic feedback funciona en dispositivo, validar ripple animation visible",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar badge de progreso y long-press para ajustar cantidad",
            "description": "Implementar badge visual con porcentaje de progreso y funcionalidad long-press para configurar tamaño de vaso",
            "dependencies": [
              2
            ],
            "details": "Crear Badge widget overlay mostrando percentage de progreso diario. Posicionar badge en top-right del FAB. Implementar GestureDetector con onLongPress para mostrar dialog de glass size selection (150ml, 250ml, 500ml). Agregar accessibility labels con Semantics widget para screen readers. Update badge automáticamente cuando progress cambia via Stream/StateNotifier.",
            "status": "pending",
            "testStrategy": "Verificar badge muestra porcentaje correcto, probar long-press abre dialog configuración, validar accesibilidad con VoiceOver/TalkBack",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear waterbutton widget para logging rápido."
      },
      {
        "id": "19",
        "title": "Implementar indicador de progreso de hidratación",
        "description": "Crear widget visual que muestre progreso diario de hidratación como barra o círculo con meta dinámica",
        "details": "Crear HydrationProgressIndicator widget como linear progress bar o circular indicator. Mostrar: current intake / daily goal con colors: azul para progreso, verde cuando completado (≥100%). Agregar text overlay con ml consumed y ml remaining. Actualizar en tiempo real via Riverpod hydrationProvider. Implementar animaciones smooth para changes. Considerar diferentes visual styles según contexto (dashboard vs home).",
        "testStrategy": "Verificar progreso actualiza instantáneamente tras log, probar animaciones fluidas, validar cálculos visuales correctos",
        "priority": "low",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear widget HydrationProgressIndicator básico",
            "description": "Desarrollar el componente base del indicador de progreso de hidratación con estructura inicial y estilos",
            "dependencies": [],
            "details": "Crear StatelessWidget HydrationProgressIndicator que reciba currentIntake y dailyGoal como parámetros. Implementar LinearProgressIndicator con BorderRadius personalizado. Definir colores: azul (#2196F3) para progreso normal, verde (#4CAF50) cuando ≥100%. Configurar height de 12dp y width responsivo. Agregar Container wrapper con padding y margin apropiados para diferentes contextos (dashboard vs home).",
            "status": "pending",
            "testStrategy": "Verificar widget se renderiza correctamente con diferentes valores de progreso, probar colores cambian según porcentaje",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Agregar text overlay y cálculos visuales",
            "description": "Implementar superposición de texto mostrando ml consumidos y restantes con formateo apropiado",
            "dependencies": [
              1
            ],
            "details": "Agregar Stack widget con Positioned text overlay en el centro del progress bar. Mostrar formato '{currentMl}ml / {goalMl}ml' o '{remainingMl}ml restantes' según preferencia. Implementar helper methods: calculatePercentage(), formatMlText(), getRemainingMl(). Usar TextStyle con fontSize 12sp, fontWeight medium, color blanco con shadow para legibilidad. Responsive text que se ajuste al ancho disponible.",
            "status": "pending",
            "testStrategy": "Probar cálculos matemáticos son correctos, verificar texto legible en diferentes tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar Riverpod y animaciones en tiempo real",
            "description": "Conectar el indicador con hydrationProvider para actualizaciones en tiempo real y agregar animaciones fluidas",
            "dependencies": [
              2
            ],
            "details": "Convertir a ConsumerWidget y escuchar hydrationProvider.currentDailyIntake y dailyGoal. Implementar AnimatedContainer con Duration(milliseconds: 500) y Curves.easeInOut para smooth transitions. Agregar TweenAnimationBuilder para animar cambios de valor progresivamente. Configurar AnimationController para pulse effect cuando se alcanza 100%. Implementar didUpdateWidget para detectar cambios y triggear animaciones apropiadas.",
            "status": "pending",
            "testStrategy": "Verificar actualizaciones en tiempo real funcionan instantáneamente, probar animaciones son fluidas sin lag",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar indicador de progreso de hidratación."
      },
      {
        "id": "20",
        "title": "Desarrollar pantalla de onboarding con flujo de 6 pasos",
        "description": "Crear experiencia de primera vez con splash, introducción, registro, cuestionario, paywall y recomendación detox",
        "details": "Crear OnboardingCoordinator con PageView de 6 screens: SplashScreen (logo + loading), IntroScreen (beneficios app), RegisterScreen (email/password), QuestionnaireScreen (peso, altura, experiencia), PaywallScreen (Superwall), DetoxRecommendationScreen (48h plan opcional). Implementar navigation entre steps con progress indicator. Guardar answers en UserProfile. Usar go_router para deep linking. Permitir skip en algunos steps.",
        "testStrategy": "Probar flujo completo funciona, verificar datos se guardan correctamente, validar navigation y back handling",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del OnboardingCoordinator y navegación",
            "description": "Implementar el coordinador principal del onboarding con PageView y sistema de navegación entre las 6 pantallas",
            "dependencies": [],
            "details": "Crear OnboardingCoordinator que maneje PageViewController con 6 screens. Implementar navegación forward/backward con botones Next/Previous. Agregar progress indicator (6 dots o barra de progreso). Configurar go_router para deep linking a pasos específicos. Implementar lógica para skip opcional en ciertos steps. Manejar state management con Riverpod para current step y user progress.",
            "status": "pending",
            "testStrategy": "Probar navegación entre steps funciona correctamente, verificar progress indicator actualiza, validar deep linking y skip functionality",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar las 6 pantallas del flujo de onboarding",
            "description": "Crear todas las pantallas individuales: Splash, Intro, Register, Questionnaire, Paywall y DetoxRecommendation",
            "dependencies": [
              1
            ],
            "details": "Implementar SplashScreen con logo animado y loading indicator. Crear IntroScreen mostrando beneficios de la app con ilustraciones. Desarrollar RegisterScreen con formulario email/password y validación. Construir QuestionnaireScreen para capturar peso, altura y experiencia previa. Integrar PaywallScreen con Superwall SDK para suscripciones. Diseñar DetoxRecommendationScreen con plan detox de 48h opcional.",
            "status": "pending",
            "testStrategy": "Probar cada pantalla renderiza correctamente, verificar formularios validan datos, validar integración Superwall funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar persistencia de datos y finalización del onboarding",
            "description": "Guardar respuestas del usuario en UserProfile y completar el flujo de onboarding",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar guardado de registration data (email/password) en authentication service. Persistir questionnaire answers (peso, altura, experiencia) en UserProfile usando Isar database. Guardar paywall decisions y subscription status. Implementar completion callback que marque onboarding como terminado y navigate a main app. Manejar error states y retry logic para failed saves.",
            "status": "pending",
            "testStrategy": "Verificar datos se guardan correctamente en UserProfile, probar completion flow lleva a main app, validar error handling para failed saves",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar pantalla de onboarding con flujo de 6 pasos."
      },
      {
        "id": "21",
        "title": "Implementar plan de detox de 48 horas (opcional)",
        "description": "Crear pantalla y lógica para protocolo detox carnívoro pre-ayuno para reducir antojos iniciales",
        "details": "Crear DetoxScreen con countdown timer 48h separado del main timer. Mostrar lista allowed foods: carne, huevos, pescado, caldo de hueso, sal, agua. Implementar daily check-ins (morning/evening) para log adherence. Crear DetoxService paralelo a TimerService. Al completar: unlock fasting plans con congratulations screen. Permitir skip con warning message. Trackear completion rate para analytics.",
        "testStrategy": "Verificar timer detox independiente del main timer, probar check-ins funcionan, validar completion unlock plans",
        "priority": "low",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear DetoxScreen con countdown timer de 48 horas",
            "description": "Desarrollar la pantalla principal del plan de detox con un temporizador de 48 horas independiente del timer principal de ayuno",
            "dependencies": [],
            "details": "Crear DetoxScreen widget con countdown timer específico para 48 horas. Implementar DetoxTimer separado del TimerService principal. Mostrar tiempo restante en formato HH:MM:SS con diseño visual atractivo. Incluir botón para pausar/reanudar detox y opción skip con mensaje de advertencia. Configurar navegación desde plan selection hacia DetoxScreen.",
            "status": "pending",
            "testStrategy": "Verificar timer detox funciona independientemente del timer principal, probar pausa/reanudación, validar precisión del countdown",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lista de alimentos permitidos y check-ins diarios",
            "description": "Mostrar lista de alimentos permitidos durante el detox y sistema de seguimiento diario con check-ins matutinos y vespertinos",
            "dependencies": [
              1
            ],
            "details": "Crear sección de alimentos permitidos: carne, huevos, pescado, caldo de hueso, sal, agua con iconos visuales. Implementar daily check-ins con formularios simples para morning/evening adherence logging. Crear DetoxCheckIn widget con preguntas básicas sobre adherencia y estado anímico. Almacenar datos en Isar para tracking posterior.",
            "status": "pending",
            "testStrategy": "Probar check-ins se registran correctamente, verificar lista alimentos es clara y accesible, validar persistencia de datos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear DetoxService y pantalla de finalización con unlock de planes",
            "description": "Desarrollar servicio de gestión del detox y pantalla de congratulaciones que desbloquea los planes de ayuno",
            "dependencies": [
              2
            ],
            "details": "Implementar DetoxService paralelo a TimerService para gestionar estado del detox. Al completar 48h: mostrar congratulations screen, unlock fasting plans con animación, trackear completion rate en analytics. Crear DetoxCompletionScreen con celebración visual y botón para continuar a fasting plans. Integrar analytics para medir adherencia y tasas de completion.",
            "status": "pending",
            "testStrategy": "Verificar completion desbloquea correctamente los planes, probar analytics tracking funciona, validar flujo completo detox-to-fasting",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar plan de detox de 48 horas (opcional)."
      },
      {
        "id": "22",
        "title": "Crear MetricsService para cálculo de estadísticas",
        "description": "Implementar servicio que calcule streak, horas totales, tasa de completación y análisis de patrones del usuario",
        "details": "Crear MetricsService con métodos: calculateStreak(), getTotalHours(), getCompletionRate(), getLongestFast(), getPatterns(). Streak = días consecutivos con ayunos completados. Completion rate = completed sessions / total sessions. Patterns = análisis best days/times para start fasts. Usar Isar queries optimizadas con indices. Cache calculations en user_metrics table para performance.",
        "testStrategy": "Verificar cálculos matemáticos correctos, probar performance con large datasets, validar cache updates apropiadamente",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del MetricsService con métodos principales",
            "description": "Implementar la clase MetricsService con todos los métodos principales definidos y su estructura básica",
            "dependencies": [],
            "details": "Crear archivo metrics_service.dart en lib/services/. Definir clase MetricsService con métodos calculateStreak(), getTotalHours(), getCompletionRate(), getLongestFast(), getPatterns(). Implementar constructor que reciba dependencias necesarias como FastingRepository e Isar database. Crear interfaces/tipos para responses de cada método. Establecer documentación básica para cada método explicando qué calculan y qué retornan.",
            "status": "pending",
            "testStrategy": "Crear unit tests básicos verificando que métodos existen y retornan tipos correctos. Probar instanciación del service sin errores.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de cálculo para streak y métricas temporales",
            "description": "Desarrollar algoritmos de cálculo para streak de días consecutivos, horas totales y ayuno más largo",
            "dependencies": [
              1
            ],
            "details": "Implementar calculateStreak() que consulte ayunos completados ordenados por fecha y calcule días consecutivos actuales. Implementar getTotalHours() sumando duración de todas las sesiones completadas. Implementar getLongestFast() encontrando sesión con mayor duración. Usar Isar queries optimizadas con filtros por fechas y estados. Manejar edge cases como ayunos que cruzan medianoche y diferentes zonas horarias.",
            "status": "pending",
            "testStrategy": "Probar cálculos con datasets conocidos y verificar resultados matemáticos. Testear edge cases como primer ayuno, ayunos interrumpidos, cambios de fecha.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar análisis de patrones y sistema de cache",
            "description": "Desarrollar cálculo de tasa de completación, análisis de patrones de usuario y sistema de cache para performance",
            "dependencies": [
              2
            ],
            "details": "Implementar getCompletionRate() calculando completed sessions / total sessions con filtros temporales. Implementar getPatterns() analizando mejores días de semana y horas para iniciar ayunos basado en historical data. Crear tabla user_metrics en Isar para cache de cálculos pesados con timestamps. Implementar invalidación de cache cuando se agregan nuevos datos. Optimizar queries con índices apropiados en fechas y user_id.",
            "status": "pending",
            "testStrategy": "Verificar cálculos de completion rate con diferentes scenarios. Probar performance con datasets grandes (1000+ registros). Validar que cache se actualiza correctamente tras nuevos ayunos.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear metricsservice para cálculo de estadísticas."
      },
      {
        "id": "23",
        "title": "Desarrollar MetricsDashboardScreen con widgets visuales",
        "description": "Crear pantalla principal de métricas mostrando streak actual, total de horas ayunadas y tasa de éxito",
        "details": "Crear MetricsDashboardScreen con cards para: current streak (con fire icon), total hours fasted, completion rate (percentage), longest fast. Implementar MetricCard widget reusable con title, value, icon, trend indicator. Usar Material 3 card design con elevation y colors apropiados. Agregar subtle animations para value changes. Considerar charts library para future enhancements.",
        "testStrategy": "Verificar métricas se actualizan en tiempo real, probar UI responsive en diferentes screen sizes, validar accesibilidad",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente MetricCard reutilizable con Material 3",
            "description": "Desarrollar widget reutilizable MetricCard que mostrará métricas individuales con diseño Material 3",
            "dependencies": [],
            "details": "Implementar MetricCard widget con propiedades: title (String), value (String), icon (IconData), trend (opcional TrendIndicator). Usar Material 3 Card con elevation apropiada, esquinas redondeadas y colores del theme. Agregar soporte para iconos con color dinámico. Implementar TrendIndicator enum (up, down, stable) con íconos y colores correspondientes. Hacer responsive para diferentes screen sizes.",
            "status": "pending",
            "testStrategy": "Probar renderizado correcto en diferentes sizes, verificar Material 3 styling, validar accesibilidad y color contrast",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de cálculo de métricas en tiempo real",
            "description": "Desarrollar providers y servicios para calcular métricas de ayuno dinámicamente",
            "dependencies": [
              1
            ],
            "details": "Crear MetricsCalculatorService con métodos: getCurrentStreak(), getTotalHoursFasted(), getCompletionRate(), getLongestFast(). Implementar Riverpod providers para estado reactivo de métricas. Calcular streak actual basado en ayunos consecutivos completados. Sumar total de horas de todas las sesiones completadas. Calcular completion rate como porcentaje de ayunos completados vs iniciados. Integrar con FastingSessionRepository para datos actualizados.",
            "status": "pending",
            "testStrategy": "Verificar cálculos matemáticos correctos, probar actualización reactiva con Riverpod, validar rendimiento con datasets grandes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear MetricsDashboardScreen con layout y animaciones",
            "description": "Ensamblar pantalla principal de métricas usando MetricCards con animaciones suaves",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear MetricsDashboardScreen con AppBar y body en GridView o Column layout. Instanciar 4 MetricCards: Current Streak (🔥 icon), Total Hours Fasted, Completion Rate (%), Longest Fast. Conectar con metrics providers para datos reactivos. Implementar AnimatedBuilder para transiciones suaves (250ms) cuando cambian valores. Agregar pull-to-refresh functionality. Usar Theme.colorScheme para colores consistentes. Hacer responsive con breakpoints para tablets.",
            "status": "pending",
            "testStrategy": "Probar layout responsive en diferentes devices, verificar animaciones fluidas 60fps, validar pull-to-refresh funciona correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar metricsdashboardscreen con widgets visuales."
      },
      {
        "id": "24",
        "title": "Implementar calendario heatmap para historial visual",
        "description": "Crear vista de calendario que muestre días con ayunos completados, interrumpidos o sin actividad",
        "details": "Crear CalendarHeatmapWidget usando table_calendar ^3.0.9 o custom implementation. Color coding: verde para completed fasts, naranja para interrupted, gris para no sessions. Implementar tap en day para mostrar session details en modal. Agregar legend explicando colors. Navigation entre meses. Load data efficiently para date ranges. Considerar different intensities basado en duration/success.",
        "testStrategy": "Verificar colores reflejan datos correctamente, probar navigation meses funciona, validar performance con year data",
        "priority": "low",
        "dependencies": [
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar estructura básica del CalendarHeatmapWidget",
            "description": "Crear el widget base del calendario heatmap con navegación entre meses y estructura de datos para los ayunos",
            "dependencies": [],
            "details": "Crear CalendarHeatmapWidget usando table_calendar ^3.0.9 o implementación custom. Configurar navigation entre meses con botones prev/next. Definir estructura de datos para mapear dates a session states. Implementar básico calendar layout sin color coding aún. Configurar calendar configuration con firstDay, lastDay, y calendarFormat apropiados.",
            "status": "pending",
            "testStrategy": "Verificar navegación entre meses funciona correctamente, probar que calendario se renderiza sin errores, validar estructura básica",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de color coding para estados de ayuno",
            "description": "Desarrollar la lógica de colores para mostrar visualmente los diferentes estados de ayuno en cada día del calendario",
            "dependencies": [
              1
            ],
            "details": "Implementar color coding system: verde para completed fasts, naranja para interrupted, gris para no sessions. Crear helper methods para determinar color basado en session data. Considerar diferentes intensities basado en duration/success rate. Implementar efficient data loading para date ranges para evitar performance issues. Crear CalendarDay widget customizado para mostrar colors apropiados.",
            "status": "pending",
            "testStrategy": "Verificar colores reflejan datos de ayuno correctamente, probar performance con datos de un año completo, validar intensidades visuales",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar interactividad y leyenda explicativa",
            "description": "Implementar funcionalidad de tap en días del calendario para mostrar detalles y agregar leyenda explicativa de colores",
            "dependencies": [
              2
            ],
            "details": "Implementar tap en day para mostrar session details en modal popup con información completa del ayuno. Crear leyenda explicando color meanings (verde=completado, naranja=interrumpido, gris=sin actividad). Diseñar SessionDetailsModal con duration, start/end times, notes si available. Posicionar leyenda en bottom o top del calendario. Implementar animaciones smooth para modal transitions.",
            "status": "pending",
            "testStrategy": "Probar que tap en días abre modal con información correcta, verificar leyenda es clara y visible, validar animaciones fluidas",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar calendario heatmap para historial visual."
      },
      {
        "id": "25",
        "title": "Crear modelo ContentItem para biblioteca de aprendizaje",
        "description": "Implementar esquema para artículos, videos y estudios educativos sobre ayuno intermitente",
        "details": "Crear @collection ContentItem con fields: String id, String title, ContentType type (article/video/study), Category category (basics/science/tips/success_stories), String contentUrl, String? thumbnailUrl, String description, int? durationMinutes, bool isPremium, DateTime createdAt. Implementar enums para type y category. Agregar métodos helper para isVideo, isArticle. Sync con Supabase learning_content table.",
        "testStrategy": "Verificar schema correctamente definido, probar serialization para sync, validar queries por category y type",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear enums ContentType y Category para clasificación",
            "description": "Implementar los enums necesarios para clasificar el contenido educativo por tipo y categoría",
            "dependencies": [],
            "details": "Crear enum ContentType con valores article, video, study. Crear enum Category con valores basics, science, tips, success_stories. Asegurar que ambos enums sean serializables para JSON y compatibles con Isar database. Documentar cada valor del enum con comentarios explicativos.",
            "status": "pending",
            "testStrategy": "Verificar que todos los valores de enum se serialicen correctamente a JSON y se puedan deserializar sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar clase ContentItem con decoradores Isar",
            "description": "Crear la clase principal ContentItem con todos los campos requeridos y anotaciones de Isar",
            "dependencies": [
              1
            ],
            "details": "Crear @collection class ContentItem con campos: String id, String title, ContentType type, Category category, String contentUrl, String? thumbnailUrl, String description, int? durationMinutes, bool isPremium, DateTime createdAt. Agregar métodos helper isVideo() e isArticle(). Implementar toJson() y fromJson() para sincronización con Supabase.",
            "status": "pending",
            "testStrategy": "Probar serialización/deserialización JSON, verificar que métodos helper devuelvan valores correctos, validar que campos opcionales manejen null apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar sincronización con tabla learning_content de Supabase",
            "description": "Establecer la conexión y sincronización bidireccional entre ContentItem local y la tabla learning_content remota",
            "dependencies": [
              2
            ],
            "details": "Crear ContentItemRepository con métodos sync, fetchFromSupabase, uploadToSupabase. Implementar mapping entre campos locales de Isar y columnas de Supabase. Manejar conflictos de sincronización y estrategia de merge. Configurar listeners para cambios remotos y locales.",
            "status": "pending",
            "testStrategy": "Verificar que datos se sincronicen correctamente en ambas direcciones, probar manejo de errores de red, validar que conflictos se resuelvan apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear modelo contentitem para biblioteca de aprendizaje."
      },
      {
        "id": "26",
        "title": "Desarrollar ContentService para gestión de contenido educativo",
        "description": "Implementar servicio para fetching, caching y gestión de favoritos para contenido de aprendizaje",
        "details": "Crear ContentService con métodos: fetchContent(), getByCategory(), getFavorites(), toggleFavorite(), cacheForOffline(). Implementar smart caching: articles cache full content for offline, videos cache metadata only. Manejar favorites como separate Isar collection o field en ContentItem. Sync favorites con Supabase. Implementar search functionality para find content.",
        "testStrategy": "Probar caching funciona offline, verificar favorites sync entre devices, validar search performance",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar estructura base del ContentService",
            "description": "Crear la clase ContentService con métodos principales y configuración inicial para gestión de contenido educativo",
            "dependencies": [],
            "details": "Crear archivo content_service.dart con clase ContentService. Implementar métodos base: fetchContent(), getByCategory(), getFavorites(), toggleFavorite(), cacheForOffline(). Configurar dependency injection con Riverpod. Definir interfaces y tipos de datos para ContentItem. Implementar error handling básico y logging.",
            "status": "pending",
            "testStrategy": "Crear unit tests para cada método público del servicio, verificar dependency injection funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de caching inteligente",
            "description": "Desarrollar lógica de caching diferenciado para artículos completos y metadata de videos usando Isar",
            "dependencies": [
              1
            ],
            "details": "Implementar smart caching: artículos guardan contenido completo para lectura offline, videos solo metadata (título, duración, thumbnail). Usar Isar para persistencia local. Crear ContentCache model con campos: id, type, fullContent, metadata, timestamp, expirationDate. Implementar cleanup automático de cache expirado. Manejar límites de storage.",
            "status": "pending",
            "testStrategy": "Probar caching funciona offline, verificar diferenciación entre tipos de contenido, validar cleanup automático",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar gestión de favoritos y funcionalidad de búsqueda",
            "description": "Desarrollar sistema de favoritos con sincronización Supabase y funcionalidad de búsqueda de contenido",
            "dependencies": [
              2
            ],
            "details": "Crear FavoriteContent collection en Isar o field en ContentItem. Implementar toggleFavorite() con sync bidireccional a Supabase. Desarrollar search functionality con filtros por categoría, tipo, favoritos. Implementar indexing para búsqueda rápida. Manejar offline/online state para favorites sync. Agregar debounce para search queries.",
            "status": "pending",
            "testStrategy": "Probar favorites sync entre devices, verificar search performance con datasets grandes, validar funcionamiento offline",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar contentservice para gestión de contenido educativo."
      },
      {
        "id": "27",
        "title": "Crear LearningHomeScreen para exploración de contenido",
        "description": "Desarrollar pantalla principal de aprendizaje con navegación por categorías y contenido featured",
        "details": "Crear LearningHomeScreen con TabBar para categories: Básicos, Ciencia, Tips, Historias Éxito. Implementar ContentListView con ContentCard widgets mostrando thumbnail, title, duration, premium badge. Agregar search bar en app bar. Featured content section en top. Pull-to-refresh para update content. Manejar empty states y loading states elegantemente.",
        "testStrategy": "Verificar navigation entre tabs funciona, probar pull-to-refresh, validar empty states y loading states",
        "priority": "medium",
        "dependencies": [
          "26"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de LearningHomeScreen con TabBar",
            "description": "Implementar la pantalla principal de aprendizaje con navegación por pestañas para las categorías: Básicos, Ciencia, Tips, Historias de Éxito",
            "dependencies": [],
            "details": "Crear LearningHomeScreen como StatefulWidget. Implementar TabBar con 4 tabs: Básicos, Ciencia, Tips, Historias Éxito. Configurar TabController y TabBarView. Agregar AppBar con título 'Aprendizaje' y integrar search bar. Establecer estructura base del layout con TabBar en la parte superior y contenido dinámico en TabBarView.",
            "status": "pending",
            "testStrategy": "Verificar que la navegación entre tabs funciona correctamente y que el search bar se muestra en el AppBar",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar ContentListView y ContentCard widgets",
            "description": "Desarrollar componentes reutilizables para mostrar listas de contenido con cards que incluyan thumbnail, título, duración y badge premium",
            "dependencies": [
              1
            ],
            "details": "Crear ContentCard widget que muestre: thumbnail (NetworkImage con placeholder), título del contenido, duración formateada, premium badge condicional. Implementar ContentListView que use ListView.builder para renderizar ContentCards. Agregar padding y spacing apropiados. Manejar tap gestures en cards para navegación. Optimizar performance con const constructors donde sea posible.",
            "status": "pending",
            "testStrategy": "Probar que las cards se renderizan correctamente con todos los elementos visuales y que responden a tap gestures",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar featured content section y estados de loading/empty",
            "description": "Implementar sección de contenido destacado en la parte superior y manejar estados vacíos y de carga con pull-to-refresh",
            "dependencies": [
              2
            ],
            "details": "Crear FeaturedContentSection como widget separado que muestre contenido destacado en un carousel horizontal. Implementar RefreshIndicator wrapper para pull-to-refresh functionality. Crear EmptyStateWidget para cuando no hay contenido disponible. Implementar LoadingStateWidget con shimmer effects durante carga. Agregar logic para alternar entre estados según data availability.",
            "status": "pending",
            "testStrategy": "Verificar que pull-to-refresh actualiza el contenido, validar que empty states y loading states se muestran apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear learninghomescreen para exploración de contenido."
      },
      {
        "id": "28",
        "title": "Integrar youtube_player_flutter para reproducción de videos",
        "description": "Implementar reproductor de video embebido para contenido educativo de YouTube con controles nativos",
        "details": "Instalar youtube_player_flutter ^8.0.0. Crear VideoPlayerScreen que extraiga video ID desde URL y muestre YoutubePlayer widget. Implementar fullscreen mode, autoplay settings, quality selection. Manejar estados: loading, playing, paused, error. Fallback a external browser si embedding fails. Considerar Picture-in-Picture para premium users. Trackear video completion para analytics.",
        "testStrategy": "Probar playback en iOS y Android, verificar fullscreen funciona, validar external fallback cuando needed",
        "priority": "low",
        "dependencies": [
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar y configurar youtube_player_flutter SDK",
            "description": "Instalar el paquete youtube_player_flutter v8.0.0 y configurar los permisos necesarios para reproducción de video",
            "dependencies": [],
            "details": "Agregar youtube_player_flutter: ^8.0.0 al pubspec.yaml. Configurar permisos de internet en Android manifest y iOS Info.plist. Importar el paquete en los archivos necesarios. Verificar compatibilidad con la versión actual de Flutter del proyecto.",
            "status": "pending",
            "testStrategy": "Verificar que el paquete se instala correctamente sin conflictos de dependencias y que los permisos están configurados apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear VideoPlayerScreen con extracción de video ID",
            "description": "Implementar pantalla de reproductor que extraiga el ID del video desde URL de YouTube y renderice el widget YoutubePlayer",
            "dependencies": [
              1
            ],
            "details": "Crear VideoPlayerScreen widget que reciba URL de YouTube como parámetro. Implementar función para extraer video ID usando regex o parsing de URL. Configurar YoutubePlayer widget con video ID extraído. Implementar UI básica con controles de reproducción. Manejar casos edge como URLs inválidas o formatos no soportados.",
            "status": "pending",
            "testStrategy": "Probar extracción de video ID con diferentes formatos de URL de YouTube y verificar que el reproductor carga correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar controles avanzados y manejo de estados",
            "description": "Agregar funcionalidades de pantalla completa, autoplay, calidad y manejo completo de estados del reproductor",
            "dependencies": [
              2
            ],
            "details": "Implementar modo fullscreen con rotación automática. Configurar opciones de autoplay y selección de calidad. Manejar estados: loading, playing, paused, error con UI apropiada. Implementar fallback a navegador externo cuando embedding falla. Considerar Picture-in-Picture para usuarios premium. Agregar tracking de completado de video para analytics.",
            "status": "pending",
            "testStrategy": "Verificar que fullscreen funciona en ambas plataformas, probar fallback a navegador externo y validar tracking de eventos de reproducción",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on integrar youtube_player_flutter para reproducción de videos."
      },
      {
        "id": "29",
        "title": "Implementar sistema de favoritos para contenido",
        "description": "Desarrollar funcionalidad para guardar artículos y videos favoritos con sincronización entre dispositivos",
        "details": "Extender ContentItem con isFavorite field boolean. Implementar FavoritesRepository con addFavorite(), removeFavorite(), getFavorites(). UI: heart icon en ContentCard que toggle favorite state con animation. Crear FavoritesScreen para ver saved content. Sync favorites con Supabase usando junction table user_content_favorites. Manejar conflicts si same user modifica favorites en multiple devices.",
        "testStrategy": "Verificar favorites persisten tras reinicio, probar sync entre devices funciona, validar conflict resolution",
        "priority": "low",
        "dependencies": [
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extender modelo ContentItem e implementar FavoritesRepository",
            "description": "Modificar el modelo ContentItem para incluir el campo isFavorite y crear el repositorio de favoritos con métodos básicos",
            "dependencies": [],
            "details": "Agregar campo boolean isFavorite al modelo ContentItem. Crear FavoritesRepository con métodos addFavorite(), removeFavorite() y getFavorites(). Implementar almacenamiento local usando Isar para persistir estado de favoritos. Configurar Riverpod provider para gestionar estado de favoritos en la aplicación.",
            "status": "pending",
            "testStrategy": "Verificar que los favoritos se persisten correctamente en Isar, probar que los métodos del repositorio funcionan sin errores y validar que el estado se mantiene tras reinicio de la app",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar UI de favoritos con ícono heart y pantalla FavoritesScreen",
            "description": "Crear interfaz de usuario para marcar favoritos con ícono de corazón animado y pantalla dedicada para ver contenido guardado",
            "dependencies": [
              1
            ],
            "details": "Agregar ícono heart a ContentCard que permita toggle del estado favorito con animación suave. Implementar FavoritesScreen que muestre lista de contenido favorito con filtros por tipo. Configurar navegación hacia FavoritesScreen desde drawer o tab bar. Añadir estados vacíos cuando no hay favoritos guardados.",
            "status": "pending",
            "testStrategy": "Probar que la animación del corazón funciona correctamente, verificar que FavoritesScreen muestra el contenido adecuado y validar que la navegación funciona sin problemas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sincronización de favoritos con Supabase y resolución de conflictos",
            "description": "Configurar sincronización de favoritos entre dispositivos usando Supabase y manejar conflictos cuando el mismo usuario modifica favoritos en múltiples dispositivos",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear tabla user_content_favorites en Supabase como junction table. Implementar FavoritesSyncService que sincronice favoritos locales con servidor. Manejar conflictos usando timestamp de última modificación, priorizando cambios más recientes. Implementar sync automático en background y manual pull-to-refresh en FavoritesScreen.",
            "status": "pending",
            "testStrategy": "Verificar sincronización funciona entre múltiples dispositivos, probar resolución de conflictos cuando se modifican favoritos simultáneamente y validar que sync en background no afecta rendimiento",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de favoritos para contenido."
      },
      {
        "id": "30",
        "title": "Crear ProfileScreen para gestión de configuración",
        "description": "Desarrollar pantalla de perfil con edición de peso, configuración de tema y preferencias de notificaciones",
        "details": "Crear ProfileScreen con sections: User Info (weight, height editing), Hydration (goal adjustment, glass size), Notifications (toggles por type), Theme (light/dark/system toggle), Account (logout, export data). Implementar form validation para weight/height. Usar TextFormField con input formatters. Settings persisten en UserProfile y SharedPreferences. Agregar confirmation dialogs para destructive actions.",
        "testStrategy": "Probar validaciones form funcionan, verificar settings persisten correctamente, validar confirmation dialogs",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de ProfileScreen con navegación",
            "description": "Implementar la estructura básica de la pantalla de perfil con AppBar, navegación y layout principal con secciones definidas",
            "dependencies": [],
            "details": "Crear archivo profile_screen.dart en lib/screens/. Implementar Scaffold con AppBar personalizado. Crear estructura de secciones usando Column y Card widgets: User Info, Hydration, Notifications, Theme, Account. Agregar navegación desde BottomNavigationBar. Implementar scroll behavior con SingleChildScrollView.",
            "status": "pending",
            "testStrategy": "Verificar navegación funciona correctamente, probar scroll en diferentes tamaños de pantalla, validar estructura visual",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar secciones de User Info y Hydration con validaciones",
            "description": "Desarrollar formularios para edición de peso/altura y configuración de hidratación con validación de inputs",
            "dependencies": [
              1
            ],
            "details": "Implementar User Info section con TextFormField para weight y height usando input formatters (números decimales). Agregar validación: peso 30-300kg, altura 100-250cm. Crear Hydration section con slider para goal adjustment (1-5L) y selector para glass size (150ml, 200ml, 250ml, 300ml). Conectar con UserProfile model para persistir cambios.",
            "status": "pending",
            "testStrategy": "Probar validaciones de formulario funcionan, verificar persistencia de datos, validar input formatters",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar secciones Theme, Notifications y Account con confirmaciones",
            "description": "Desarrollar configuraciones de tema, notificaciones y acciones de cuenta con diálogos de confirmación",
            "dependencies": [
              2
            ],
            "details": "Crear Theme section con radio buttons para light/dark/system. Implementar Notifications section con switches para diferentes tipos de notificaciones (ayuno, hidratación, recordatorios). Crear Account section con botones para logout y export data. Agregar confirmation dialogs para acciones destructivas usando AlertDialog. Persistir configuraciones en SharedPreferences.",
            "status": "pending",
            "testStrategy": "Verificar cambios de tema se aplican correctamente, probar toggles de notificaciones, validar confirmation dialogs para acciones destructivas",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear profilescreen para gestión de configuración."
      },
      {
        "id": "31",
        "title": "Configurar Superwall para monetización y paywall",
        "description": "Integrar Superwall SDK para presentación de paywall, A/B testing y gestión de suscripciones premium",
        "details": "Instalar superwall_flutter SDK. Configurar API keys y experiment IDs. Crear SuperwallService wrapper con métodos: presentPaywall(), checkSubscriptionStatus(), restorePurchases(). Implementar paywall triggers: después onboarding, al acceder premium features. Configurar productos: monthly/yearly subscriptions. Setup webhook endpoint para subscription events. Trackear conversion events para optimization.",
        "testStrategy": "Verificar paywall se presenta correctamente, probar purchase flow completo, validar subscription status sync",
        "priority": "medium",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrar SDK de Superwall en Flutter",
            "description": "Instalar y configurar el SDK superwall_flutter en el proyecto con las dependencias necesarias",
            "dependencies": [],
            "details": "Agregar superwall_flutter SDK al pubspec.yaml. Configurar API keys y experiment IDs en la aplicación. Inicializar Superwall en main.dart con las credenciales apropiadas. Configurar permisos necesarios para iOS y Android. Verificar que la inicialización sea exitosa y el SDK esté correctamente integrado.",
            "status": "pending",
            "testStrategy": "Verificar que el SDK se inicializa sin errores y que las credenciales son válidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear SuperwallService wrapper con métodos core",
            "description": "Desarrollar servicio wrapper que encapsule la funcionalidad de Superwall con métodos principales",
            "dependencies": [
              1
            ],
            "details": "Crear clase SuperwallService con métodos presentPaywall(), checkSubscriptionStatus(), restorePurchases(). Implementar manejo de estados de suscripción y respuestas del paywall. Integrar con el sistema de gestión de estado de la aplicación. Manejar errores y casos edge apropiadamente.",
            "status": "pending",
            "testStrategy": "Probar cada método individualmente y verificar respuestas correctas del SDK",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar triggers de paywall y configurar productos",
            "description": "Configurar cuándo y cómo se presenta el paywall, y establecer productos de suscripción",
            "dependencies": [
              2
            ],
            "details": "Implementar triggers para mostrar paywall después del onboarding y al acceder a features premium. Configurar productos de suscripción monthly/yearly en Superwall dashboard. Integrar triggers con la navegación de la app y flujos de usuario. Configurar A/B testing para diferentes presentaciones de paywall.",
            "status": "pending",
            "testStrategy": "Verificar que el paywall se presenta en los momentos correctos y que los productos están disponibles",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar webhooks y tracking de eventos de conversión",
            "description": "Establecer endpoint para webhooks de Superwall y implementar tracking de eventos de conversión",
            "dependencies": [
              3
            ],
            "details": "Setup webhook endpoint en el backend para recibir eventos de subscription de Superwall. Implementar manejo de eventos como subscription_started, subscription_cancelled, subscription_renewed. Configurar tracking de conversion events para optimization del paywall. Integrar con analytics para monitorear performance de conversión.",
            "status": "pending",
            "testStrategy": "Probar que los webhooks reciben eventos correctamente y que el tracking de conversión funciona",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en integración del SDK Superwall, configuración de productos y suscripciones, implementación de triggers de paywall, y manejo de webhooks para eventos de suscripción"
      },
      {
        "id": "32",
        "title": "Implementar gating de features premium",
        "description": "Desarrollar sistema para restringir funcionalidades avanzadas a usuarios con suscripción activa",
        "details": "Crear SubscriptionManager con checkIsPremium() method. Implementar isPremiumProvider en Riverpod que exponga boolean status. Features premium: custom fasting plans, detailed analytics, meditation library, ad-free experience. Crear PremiumFeatureGate widget que wrappea premium content y muestra upsell si not subscribed. Implementar graceful fallbacks para free users.",
        "testStrategy": "Verificar gating funciona correctamente, probar upsell flows, validar fallbacks para free users apropiados",
        "priority": "low",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear SubscriptionManager y provider de estado premium",
            "description": "Implementar el sistema base de gestión de suscripciones con SubscriptionManager y provider Riverpod para verificar estado premium del usuario",
            "dependencies": [],
            "details": "Crear clase SubscriptionManager con método checkIsPremium() que verifique estado de suscripción actual. Implementar isPremiumProvider en Riverpod que exponga boolean status del estado premium. Configurar lógica de verificación de suscripción activa y gestión de estados de error. Integrar con sistema de autenticación existente para verificar permisos de usuario.",
            "status": "pending",
            "testStrategy": "Verificar checkIsPremium() retorna estado correcto, probar provider actualiza apropiadamente cuando cambia suscripción",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar PremiumFeatureGate widget universal",
            "description": "Crear widget reutilizable que envuelva contenido premium y gestione automáticamente la visualización de upsell o contenido según estado de suscripción",
            "dependencies": [
              1
            ],
            "details": "Implementar PremiumFeatureGate widget que reciba child widget y gestione display condicional. Si usuario no es premium, mostrar pantalla de upsell con call-to-action. Si es premium, mostrar contenido original. Diseñar UI atractiva para upsell con beneficios claramente explicados. Incluir navegación a pantalla de suscripción desde el gate.",
            "status": "pending",
            "testStrategy": "Probar widget muestra upsell para usuarios free y contenido para premium, verificar navegación a suscripción funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar gating en features premium específicas",
            "description": "Aplicar PremiumFeatureGate a todas las funcionalidades premium identificadas y configurar fallbacks apropiados para usuarios gratuitos",
            "dependencies": [
              2
            ],
            "details": "Integrar PremiumFeatureGate en: custom fasting plans (mostrar solo planes básicos), detailed analytics (limitar métricas mostradas), meditation library (acceso limitado), ad-free experience (mostrar ads apropiadamente). Configurar graceful fallbacks que no rompan experiencia de usuario free. Implementar tracking de eventos cuando usuarios interactúan con gates premium.",
            "status": "pending",
            "testStrategy": "Verificar cada feature premium está correctamente protegida, probar fallbacks funcionan sin errores, validar tracking analytics",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar gating de features premium."
      },
      {
        "id": "33",
        "title": "Configurar programación de notificaciones con OneSignal",
        "description": "Implementar sistema para programar notificaciones automáticas de ayuno, hidratación y engagement",
        "details": "Crear NotificationScheduler service con métodos: scheduleFastingNotifications(), scheduleHydrationReminders(), scheduleEngagementNotifications(). Trigger notifications en: fast start, milestones (4h, 8h, 12h, 16h), completion, water reminders cada 2h, re-engagement si inactive >24h. Usar OneSignal scheduled notifications API. Implementar user preferences para disable specific types. Handle timezone changes.",
        "testStrategy": "Verificar notifications llegan en tiempos correctos, probar user preferences respetadas, validar timezone handling",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear servicio base NotificationScheduler",
            "description": "Implementar la clase NotificationScheduler con la estructura básica y métodos principales para programación de notificaciones",
            "dependencies": [],
            "details": "Crear NotificationScheduler service class con métodos scheduleFastingNotifications(), scheduleHydrationReminders(), scheduleEngagementNotifications(). Implementar manejo de OneSignal scheduled notifications API. Configurar estructura base para scheduling con validaciones de tiempo y parámetros.",
            "status": "pending",
            "testStrategy": "Verificar que el servicio se inicializa correctamente y los métodos base están definidos sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar templates y programación de notificaciones de ayuno",
            "description": "Crear templates de notificaciones para eventos de ayuno y programar automáticamente según milestone",
            "dependencies": [
              1
            ],
            "details": "Implementar scheduleFastingNotifications() con templates para fast start, milestones (4h, 8h, 12h, 16h) y completion. Configurar OneSignal scheduled send times basado en user fast schedule. Implementar lógica para cancelar notifications si fast es interrumpido.",
            "status": "pending",
            "testStrategy": "Probar que notifications se programan en tiempos correctos para cada milestone de ayuno",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar sistema de preferencias de usuario para notificaciones",
            "description": "Implementar gestión de preferencias para permitir al usuario deshabilitar tipos específicos de notificaciones",
            "dependencies": [
              1
            ],
            "details": "Crear UserNotificationPreferences model con flags para fasting, hydration, engagement notifications. Implementar storage en SharedPreferences/UserDefaults. Modificar NotificationScheduler para respetar user preferences antes de schedule. Crear UI settings para toggle preferences.",
            "status": "pending",
            "testStrategy": "Verificar que preferences se guardan correctamente y notifications respetan configuración de usuario",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar manejo de cambios de zona horaria y notificaciones de hidratación",
            "description": "Gestionar cambios de timezone y implementar recordatorios automáticos de hidratación cada 2 horas",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar timezone change detection y re-scheduling de notifications existentes. Crear scheduleHydrationReminders() con intervals de 2 horas durante horas activas. Implementar scheduleEngagementNotifications() para re-engagement después 24h inactividad. Manejar timezone conversions para OneSignal API.",
            "status": "pending",
            "testStrategy": "Probar timezone changes actualiza schedules correctamente y hydration reminders llegan cada 2 horas",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en subtareas específicas para programación de notificaciones: configurar servicio de scheduling, implementar templates de notificaciones, manejar preferencias de usuario y gestionar cambios de zona horaria"
      },
      {
        "id": "34",
        "title": "Implementar deep linking para notificaciones",
        "description": "Configurar navigation directa a pantallas específicas cuando usuario tapa notificaciones push",
        "details": "Configurar go_router con routes para deep links. Implementar NotificationHandler que parse notification data y route appropriately: fast_milestone -> /home, hydration_reminder -> /home (focus water button), learning_content -> /learning/article/:id. Configurar Universal Links (iOS) y App Links (Android) con domain verification. Host apple-app-site-association y assetlinks.json en https://zendfast.app/.well-known/.",
        "testStrategy": "Probar deep links funcionan desde notifications, verificar Universal/App Links setup, validar routing correcto",
        "priority": "low",
        "dependencies": [
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar go_router con rutas para deep links",
            "description": "Configurar el sistema de routing de go_router para manejar enlaces profundos y navegación directa desde notificaciones push",
            "dependencies": [],
            "details": "Extender la configuración actual de go_router para incluir rutas específicas para deep links: /home para fast_milestone, /home con parámetro focus para hydration_reminder, y /learning/article/:id para learning_content. Modificar el router principal para detectar y parsear parámetros de deep linking. Implementar fallbacks para rutas inválidas que redirijan al home. Configurar route guards si es necesario para verificar autenticación antes de navegar.",
            "status": "pending",
            "testStrategy": "Verificar que todas las rutas de deep linking funcionan correctamente, probar navegación desde diferentes puntos de entrada, validar fallbacks para rutas inválidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar NotificationHandler para parsing de datos",
            "description": "Desarrollar la lógica para interceptar y procesar notificaciones push, extrayendo datos relevantes para routing",
            "dependencies": [
              1
            ],
            "details": "Crear NotificationHandler service que intercepte notificaciones cuando la app se abre desde notification tap. Parsear el payload de la notificación para extraer tipo (fast_milestone, hydration_reminder, learning_content) y datos adicionales como article_id. Implementar mapping entre tipos de notificación y rutas correspondientes. Manejar casos edge como datos malformados o tipos desconocidos. Integrar con el router configurado en subtask anterior para ejecutar navegación apropiada.",
            "status": "pending",
            "testStrategy": "Probar parsing correcto de diferentes tipos de notificaciones, verificar manejo de datos malformados, validar routing ejecuta correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Universal Links y App Links con verificación de dominio",
            "description": "Implementar Universal Links para iOS y App Links para Android con verificación de dominio en zendfast.app",
            "dependencies": [
              2
            ],
            "details": "Configurar Universal Links en iOS agregando associated domains en capabilities y creando apple-app-site-association file. Para Android, configurar App Links en AndroidManifest.xml con intent filters y crear assetlinks.json. Hostear ambos archivos en https://zendfast.app/.well-known/ directory. Implementar domain verification process para ambas plataformas. Configurar URL schemes que coincidan con las rutas definidas en go_router. Testear que links externos abren la app correctamente.",
            "status": "pending",
            "testStrategy": "Verificar Universal Links funcionan en dispositivos iOS, probar App Links en Android, validar archivos de verificación son accesibles en dominio",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en configuración de routing con go_router, implementación de NotificationHandler para parsing, y setup de Universal/App Links con verificación de dominio"
      },
      {
        "id": "35",
        "title": "Desarrollar SyncManager para sincronización bidireccional",
        "description": "Implementar sistema robusto de sincronización entre Isar local y Supabase con resolución de conflictos",
        "details": "Crear SyncManager con métodos: fullSync(), incrementalSync(), conflictResolution(). Estrategia: last-write-wins usando timestamps. Sync triggers: app foreground, wifi connect, manual refresh, timer eventos. Implement exponential backoff para retry failed syncs. Queue local changes durante offline periods. Sync entities: FastingSession, HydrationLog, UserProfile, ContentFavorites. Handle partial sync failures gracefully.",
        "testStrategy": "Probar sync funciona offline->online, verificar conflict resolution, validar no data loss durante sync failures",
        "priority": "high",
        "dependencies": [
          "7",
          "16",
          "17",
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear clase SyncManager con arquitectura base y métodos principales",
            "description": "Implementar la estructura fundamental del SyncManager con los métodos core para sincronización",
            "dependencies": [],
            "details": "Crear clase SyncManager en lib/services/sync/ con métodos: fullSync(), incrementalSync(), conflictResolution(). Definir interfaces ISyncable para entidades. Implementar SyncState enum (idle, syncing, error). Crear SyncResult class para retornos. Configurar dependency injection con Riverpod. Implementar singleton pattern para acceso global.",
            "status": "pending",
            "testStrategy": "Probar instanciación correcta, verificar métodos están definidos, validar singleton funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de cola offline y triggers de sincronización",
            "description": "Desarrollar mecanismo para queuing de cambios locales y triggers automáticos de sync",
            "dependencies": [
              1
            ],
            "details": "Crear SyncQueue para almacenar cambios offline usando Isar. Implementar SyncTrigger enum (appForeground, wifiConnect, manual, timer). Configurar listeners para app lifecycle y connectivity changes. Implementar timer periódico (configurable). Crear PendingChange model con operationType (create/update/delete), entityType, data, timestamp. Manejar prioridades de sync.",
            "status": "pending",
            "testStrategy": "Probar cola persiste cambios offline, verificar triggers se ejecutan correctamente, validar orden de procesamiento",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar resolución de conflictos y manejo de errores con retry",
            "description": "Implementar estrategia last-write-wins y sistema robusto de manejo de errores con exponential backoff",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar ConflictResolver con estrategia last-write-wins usando updatedAt timestamps. Crear RetryManager con exponential backoff (base 2s, max 60s, max 5 retries). Manejar partial sync failures gracefully manteniendo progreso. Implementar SyncError types (network, conflict, validation). Crear recovery mechanisms para data corruption. Logging detallado para debugging.",
            "status": "pending",
            "testStrategy": "Probar resolución de conflictos con timestamps, verificar retry logic funciona, validar recovery de errores parciales",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar syncmanager para sincronización bidireccional."
      },
      {
        "id": "36",
        "title": "Configurar Sentry para monitoreo de errores",
        "description": "Integrar Sentry SDK para tracking automático de crashes, errores y performance monitoring en producción",
        "details": "Instalar sentry_flutter ^7.0.0. Configurar DSN y environment (dev/prod). Wrap runApp en Sentry.init(). Implementar custom error boundaries para graceful error handling. Setup source maps upload para readable stack traces. Configure performance monitoring para detectar slow frames, large widget builds. Implement user context attachment (user ID, subscription status). Setup release tracking.",
        "testStrategy": "Verificar errores se reportan a Sentry, probar source maps funcionan, validar performance monitoring activo",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar setup inicial de Sentry SDK",
            "description": "Instalar Sentry Flutter SDK, configurar DSN y environments, y realizar integración básica",
            "dependencies": [],
            "details": "Instalar sentry_flutter ^7.0.0 en pubspec.yaml. Crear archivo sentry_config.dart para manejar DSN y environment variables (development/production). Configurar Sentry.init() wrapper alrededor de runApp() en main.dart. Implementar custom error boundaries para graceful error handling. Configurar diferentes DSN para dev/prod environments usando flavors.",
            "status": "pending",
            "testStrategy": "Verificar que los errores se reportan correctamente a Sentry dashboard, probar que environments se diferencian correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar source maps y contexto de usuario",
            "description": "Implementar upload de source maps para stack traces legibles y configurar contexto de usuario",
            "dependencies": [
              1
            ],
            "details": "Setup source maps upload automático para builds de release que permita readable stack traces en Sentry. Implementar user context attachment incluyendo user ID, subscription status, y metadata relevante. Configurar Sentry tags para categorizar errores por tipo de usuario (free/premium). Implementar breadcrumbs para tracking de user journey antes del error.",
            "status": "pending",
            "testStrategy": "Probar que los stack traces son legibles en production builds, validar que el contexto de usuario aparece en los reportes de error",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar performance monitoring y release tracking",
            "description": "Implementar monitoreo de performance y configurar tracking de releases automático",
            "dependencies": [
              1
            ],
            "details": "Configure performance monitoring para detectar slow frames, large widget builds, y slow navigation transitions. Implementar custom performance transactions para operaciones críticas como login, data sync, y screen loads. Setup release tracking automático con CI/CD integration para trackear cuando nuevas versiones causan regressions. Configurar alertas automáticas para performance degradation y crash rate increases.",
            "status": "pending",
            "testStrategy": "Verificar que performance metrics aparecen en Sentry dashboard, probar que releases se trackean automáticamente, validar alertas funcionan correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en setup inicial de Sentry SDK, configuración de source maps y contexto de usuario, y configuración de performance monitoring y alertas"
      },
      {
        "id": "37",
        "title": "Implementar testing de accesibilidad WCAG 2.1 AA",
        "description": "Asegurar cumplimiento de estándares de accesibilidad con contraste de colores, tamaños de toque y etiquetas semánticas",
        "details": "Verificar color contrast 4.5:1 mínimo para todos text/background combinations. Implementar touch targets 44×44dp minimum para todas interactive elements. Agregar Semantics labels a todos widgets: buttons, images, progress indicators. Implement focus navigation correcta para keyboard/switch users. Test con TalkBack (Android) y VoiceOver (iOS). Use Accessibility Scanner para automated testing.",
        "testStrategy": "Usar Accessibility Scanner en todas screens, manual testing con screen readers, verificar keyboard navigation",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar herramientas de testing de accesibilidad automatizado",
            "description": "Instalar y configurar Accessibility Scanner y otras herramientas automatizadas para testing de WCAG 2.1 AA",
            "dependencies": [],
            "details": "Configurar Accessibility Scanner para Android y Accessibility Inspector para iOS. Integrar flutter_accessibility_service package. Configurar CI/CD pipeline para ejecutar automated accessibility tests. Crear script de testing que verifique color contrast ratios automáticamente usando contrast ratio checking tools. Configurar semantic analysis automatizado para detectar missing labels.",
            "status": "pending",
            "testStrategy": "Verificar que las herramientas detecten correctamente violaciones de accesibilidad conocidas y generen reportes útiles",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar validación de contraste de colores y tamaños táctiles",
            "description": "Verificar y corregir ratios de contraste 4.5:1 mínimo y touch targets de 44×44dp para todos los elementos interactivos",
            "dependencies": [
              1
            ],
            "details": "Auditar todos los color combinations en la app para asegurar contrast ratio 4.5:1 mínimo. Crear ColorContrastValidator utility class. Revisar y ajustar touch targets para buttons, FABs, y interactive elements a minimum 44×44dp. Implementar TouchTargetValidator para verificar sizing. Crear accessibility_theme.dart con colores WCAG compliant. Documentar color palette accessible en design system.",
            "status": "pending",
            "testStrategy": "Usar contrast checking tools para validar todos los pares de colores, medir touch targets físicamente en dispositivos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar etiquetas semánticas y testing con screen readers",
            "description": "Agregar semantic labels completas y realizar testing exhaustivo con TalkBack y VoiceOver",
            "dependencies": [
              2
            ],
            "details": "Agregar semantic labels a todos widgets usando Semantics widget: buttons, images, progress indicators, input fields. Implementar focus navigation correcta con FocusNode management. Crear AccessibilityLabels class para centralizar strings. Testing manual completo con TalkBack (Android) y VoiceOver (iOS) en todas las pantallas principales. Documentar accessibility navigation flows. Implementar keyboard navigation support completo.",
            "status": "pending",
            "testStrategy": "Testing manual extensivo con screen readers reales, validar keyboard navigation funciona completamente, verificar semantic tree structure",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar testing de accesibilidad wcag 2.1 aa."
      },
      {
        "id": "38",
        "title": "Implementar tema claro/oscuro con toggle del sistema",
        "description": "Desarrollar soporte completo para temas claro y oscuro con detección automática del sistema y toggle manual",
        "details": "Crear ZendfastTheme.lightTheme y ZendfastTheme.darkTheme usando Material 3 ColorScheme. Dark theme: surface #1E1E1E, background #121212, manteniendo brand colors teal/green. Implementar ThemeModeProvider (light/dark/system) con persistence en SharedPreferences. Crear ThemeToggle widget con SegmentedButton. Verificar legibilidad en ambos themes, especialmente timer display y panic button.",
        "testStrategy": "Verificar theme persiste tras restart, probar auto-detection sistema funciona, validar legibilidad ambos themes",
        "priority": "low",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear esquemas de colores Material 3 para temas claro y oscuro",
            "description": "Implementar ZendfastTheme.lightTheme y ZendfastTheme.darkTheme usando Material 3 ColorScheme con los colores específicos definidos",
            "dependencies": [],
            "details": "Crear clase ZendfastTheme con propiedades lightTheme y darkTheme. Dark theme debe usar surface #1E1E1E, background #121212, manteniendo brand colors teal/green. Light theme usar colores Material 3 por defecto con brand colors personalizados. Configurar todos los tokens de color necesarios para consistencia visual.",
            "status": "pending",
            "testStrategy": "Verificar que ambos themes renderizan correctamente, validar contraste adecuado en todos los componentes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar ThemeModeProvider con persistencia en SharedPreferences",
            "description": "Desarrollar provider para gestionar estado del tema (light/dark/system) con almacenamiento persistente",
            "dependencies": [
              1
            ],
            "details": "Crear ThemeModeProvider usando Riverpod que maneje tres estados: light, dark, system. Implementar persistencia con SharedPreferences para mantener preferencia del usuario entre sesiones. Incluir detección automática del tema del sistema y actualización reactiva cuando el usuario cambia tema en configuración del dispositivo.",
            "status": "pending",
            "testStrategy": "Probar que preferencia persiste tras restart de app, verificar detección automática del sistema funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear widget ThemeToggle con SegmentedButton y verificar legibilidad",
            "description": "Desarrollar interfaz de usuario para alternar entre temas y validar legibilidad en ambos modos",
            "dependencies": [
              2
            ],
            "details": "Crear ThemeToggle widget usando SegmentedButton con opciones Claro/Oscuro/Sistema. Integrar con ThemeModeProvider para cambios reactivos. Realizar pruebas exhaustivas de legibilidad especialmente en timer display y panic button. Ajustar colores si es necesario para mantener accesibilidad.",
            "status": "pending",
            "testStrategy": "Validar legibilidad en timer display y panic button en ambos themes, verificar que toggle funciona correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar tema claro/oscuro con toggle del sistema."
      },
      {
        "id": "39",
        "title": "Crear assets de Lottie para animación de respiración",
        "description": "Diseñar o adquirir animación Lottie optimizada para meditación 4-4-8 con visual zen-inspirado",
        "details": "Adquirir o crear Lottie animation file (<100KB) que muestre breathing pattern: círculo/pulmones expanding (4s), holding (4s), contracting (8s). Colors: teal/green palette matching app theme. Animation debe loop infinitely hasta user stops. Considerar subtle particles o light effects para enhanced meditation experience. Store en assets/animations/breathing.json.",
        "testStrategy": "Verificar animación smooth 60fps en mid-range devices, probar timing preciso 4-4-8, validar file size <100KB",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Investigar y seleccionar assets de animación Lottie existentes",
            "description": "Buscar en repositorios como LottieFiles, Freepik y GitHub animaciones de respiración que cumplan con los requisitos del proyecto",
            "dependencies": [],
            "details": "Explorar LottieFiles.com, Freepik y repositorios open-source para encontrar animaciones de respiración compatibles. Evaluar calidad, tamaño de archivo (<100KB), compatibilidad con palette teal/verde, y timing personalizable para patrón 4-4-8. Documentar opciones viables con URLs y licencias.",
            "status": "pending",
            "testStrategy": "Verificar que animaciones encontradas tengan licencia apropiada, tamaño <100KB y sean editables",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Diseñar animación Lottie personalizada para respiración 4-4-8",
            "description": "Crear desde cero una animación Lottie optimizada específicamente para el patrón de respiración 4-4-8 con diseño zen-inspirado",
            "dependencies": [
              1
            ],
            "details": "Usar After Effects con plugin Bodymovin para crear animación de círculo/pulmones expandiendo (4s), manteniendo (4s), contrayendo (8s). Aplicar palette teal (#069494) y verde (#7fb069). Agregar partículas sutiles y efectos de luz. Optimizar para loop infinito y export como .json <100KB.",
            "status": "pending",
            "testStrategy": "Verificar timing preciso 4-4-8 segundos, smooth loop infinito, tamaño archivo <100KB",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar y probar animación Lottie en la aplicación",
            "description": "Implementar la animación seleccionada en la aplicación Flutter y optimizar su rendimiento en dispositivos de gama media",
            "dependencies": [
              2
            ],
            "details": "Guardar archivo en assets/animations/breathing.json. Implementar con paquete lottie en Flutter. Configurar controles de play/pause/stop. Optimizar rendering para 60fps en dispositivos mid-range. Implementar preloading para evitar delays. Añadir fallback si animación falla al cargar.",
            "status": "pending",
            "testStrategy": "Probar performance 60fps en dispositivos gama media, verificar controles funcionan correctamente, validar smooth playback",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear assets de lottie para animación de respiración."
      },
      {
        "id": "40",
        "title": "Configurar flavors de Flutter (development/production)",
        "description": "Establecer entornos separados para desarrollo y producción con configuraciones y APIs específicas",
        "details": "Configurar Android flavors en build.gradle: development (app ID suffix .dev), production (release config). Configurar iOS schemes separados. Crear AppConfig class que lea environment variables (ENV=dev/prod) y returne appropriate Supabase URLs, API keys, debug settings. Implementar run commands con --flavor y --dart-define. Setup CI/CD para build both flavors automaticamente.",
        "testStrategy": "Verificar builds generan different app IDs, probar environment configs correctas por flavor, validar CI builds",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Android flavors en build.gradle",
            "description": "Configurar flavors de Android para development y production con diferentes app IDs y configuraciones de build",
            "dependencies": [],
            "details": "Modificar android/app/build.gradle para agregar productFlavors: development con applicationIdSuffix '.dev' y debuggable true, production con configuración de release. Configurar buildTypes apropiados para cada flavor. Establecer diferentes iconos de app y nombres para distinguir environments. Configurar proguard y obfuscación solo para production.",
            "status": "pending",
            "testStrategy": "Verificar que se generan APKs con diferentes app IDs, probar instalación simultánea de ambos flavors, validar configuraciones específicas por environment",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar iOS schemes y configuraciones",
            "description": "Establecer schemes separados en Xcode para development y production con diferentes bundle IDs y configuraciones",
            "dependencies": [],
            "details": "Crear schemes en Xcode: ZendFast-Dev y ZendFast-Prod con diferentes bundle identifiers. Configurar diferentes Info.plist para cada scheme con URLs de API y configuraciones específicas. Establecer diferentes iconos y nombres de app. Configurar signing certificates apropiados para cada environment. Actualizar ios/Runner.xcodeproj con las configuraciones necesarias.",
            "status": "pending",
            "testStrategy": "Verificar builds generan diferentes bundle IDs, probar instalación simultánea en device, validar configuraciones específicas se aplican correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar AppConfig class para environment management",
            "description": "Crear sistema centralizado de configuración que lea environment variables y provea configuraciones específicas por flavor",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear lib/core/config/app_config.dart que lea dart-define variables (ENV=dev/prod). Implementar singleton pattern con métodos: getSupabaseUrl(), getSupabaseAnonKey(), isDebugMode(), getAppName(). Crear factory constructors para cada environment. Configurar flutter run commands con --flavor y --dart-define. Documentar comandos: 'flutter run --flavor development --dart-define=ENV=dev' y 'flutter run --flavor production --dart-define=ENV=prod'.",
            "status": "pending",
            "testStrategy": "Verificar AppConfig retorna configuraciones correctas por environment, probar comandos de run con diferentes flavors, validar variables de environment se leen correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en configuración específica por plataforma: setup de Android flavors y build.gradle, configuración de iOS schemes, e implementación de AppConfig para manejo de environment variables"
      },
      {
        "id": "41",
        "title": "Implementar obfuscación de código para producción",
        "description": "Configurar obfuscación de código Dart para proteger propiedad intelectual en builds de producción",
        "details": "Agregar --obfuscate y --split-debug-info flags a production builds. Configurar symbol file upload a Sentry para crash deobfuscation. Setup ProGuard rules para Android release builds con minification enabled. Configure Xcode release settings para iOS optimization. Store symbol files securely para future debugging. Document build commands para CI/CD.",
        "testStrategy": "Verificar production builds están obfuscados, probar Sentry puede deobfuscar crashes, validar app performance no degraded",
        "priority": "low",
        "dependencies": [
          "36",
          "40"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar flags de obfuscación en builds de Flutter",
            "description": "Implementar configuración de obfuscación para builds de producción usando flags --obfuscate y --split-debug-info",
            "dependencies": [],
            "details": "Modificar scripts de build para agregar --obfuscate y --split-debug-info=/path/to/symbols/ a comandos flutter build. Configurar diferentes paths para Android e iOS. Actualizar build.yaml y scripts de CI/CD para incluir estos flags automáticamente en production builds. Documentar ubicación de symbol files generados.",
            "status": "pending",
            "testStrategy": "Verificar que builds de producción generan archivos obfuscados y symbol files se crean correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar ProGuard y optimizaciones nativas",
            "description": "Implementar reglas ProGuard para Android y configuraciones de optimización para iOS",
            "dependencies": [
              1
            ],
            "details": "Crear proguard-rules.pro con reglas específicas para Flutter y dependencias del proyecto. Habilitar minifyEnabled true en android/app/build.gradle para release builds. Configurar Xcode release settings para iOS optimization incluyendo SWIFT_OPTIMIZATION_LEVEL y DEAD_CODE_STRIPPING. Testear que apps funcionan correctamente tras obfuscación.",
            "status": "pending",
            "testStrategy": "Probar builds de release en dispositivos reales para validar funcionamiento tras obfuscación y minificación",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar symbol files con Sentry para crash deobfuscation",
            "description": "Configurar subida automática de symbol files a Sentry para poder deobfuscar crashes en producción",
            "dependencies": [
              1,
              2
            ],
            "details": "Instalar sentry-cli y configurar upload de debug symbols automático. Configurar sentry.properties con tokens y project info. Agregar scripts post-build para subir symbol files a Sentry tras cada release build. Implementar storage seguro de symbol files localmente para debugging futuro. Documentar proceso completo en CI/CD pipeline.",
            "status": "pending",
            "testStrategy": "Generar crash intencional en build obfuscado y verificar que Sentry puede deobfuscar el stack trace correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar obfuscación de código para producción."
      },
      {
        "id": "42",
        "title": "Configurar CI/CD con Codemagic",
        "description": "Establecer pipeline automatizado para testing, building y deployment a app stores",
        "details": "Crear codemagic.yaml con workflows para iOS/Android production builds. Configure triggers: push to main -> production build, PR -> run tests only. Setup environment variables: Supabase keys, signing certificates, App Store Connect keys. Implement automated testing, obfuscated builds, symbol upload to Sentry. Configure deployment a TestFlight (iOS) y Internal testing (Android). Setup Slack notifications para build status.",
        "testStrategy": "Verificar CI runs sin errores, probar deployments automáticos funcionan, validar notifications apropiadas",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar workflows básicos en codemagic.yaml",
            "description": "Crear archivo codemagic.yaml con workflows para iOS y Android, configurando triggers para push a main y pull requests",
            "dependencies": [],
            "details": "Crear codemagic.yaml en la raíz del proyecto. Definir workflows separados para iOS y Android con triggers: push to main -> production build, PR -> run tests only. Configurar scripts de build para Flutter con --release flag. Establecer artefactos de output para IPA y APK.",
            "status": "pending",
            "testStrategy": "Verificar que los workflows se ejecuten correctamente al hacer push y PR, validar que generen artefactos apropiados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar variables de entorno y certificados",
            "description": "Setup de environment variables, signing certificates y keys necesarios para builds de producción",
            "dependencies": [
              1
            ],
            "details": "Configurar variables de entorno en Codemagic: SUPABASE_URL, SUPABASE_ANON_KEY, SENTRY_DSN. Subir certificados iOS (provisioning profiles, distribution certificate) y Android (keystore, key.properties). Configurar App Store Connect API key para deployment automático.",
            "status": "pending",
            "testStrategy": "Probar que las variables se resuelvan correctamente durante el build, verificar signing funciona sin errores",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar testing automatizado en pipeline",
            "description": "Configurar ejecución automática de tests unitarios y de integración en el pipeline CI/CD",
            "dependencies": [
              1
            ],
            "details": "Agregar step de testing en workflows que ejecute 'flutter test' antes del build. Configurar code coverage reporting. Implementar tests que validen funcionalidad crítica antes de deployment. Configurar pipeline para fallar si tests no pasan.",
            "status": "pending",
            "testStrategy": "Verificar que tests corran automáticamente en cada build, validar que pipeline falle con tests rotos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar deployment automático a stores",
            "description": "Setup de deployment automático a TestFlight para iOS e Internal Testing para Android con builds obfuscados",
            "dependencies": [
              2
            ],
            "details": "Configurar deployment a TestFlight usando App Store Connect API. Setup Google Play Console para Android Internal Testing. Implementar obfuscation con --obfuscate flag. Configurar upload de símbolos de debug a Sentry para crash reporting. Establecer versionado automático.",
            "status": "pending",
            "testStrategy": "Probar deployment completo end-to-end, verificar que apps aparezcan en TestFlight e Internal Testing",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar notificaciones Slack para build status",
            "description": "Implementar notificaciones automáticas a Slack para reportar estado de builds exitosos y fallidos",
            "dependencies": [
              4
            ],
            "details": "Configurar Slack webhook en Codemagic para canal de desarrollo. Implementar notificaciones para: build started, build success con links a artifacts, build failed con logs de error. Configurar diferentes mensajes para production builds vs test runs.",
            "status": "pending",
            "testStrategy": "Verificar que notificaciones lleguen correctamente a Slack para todos los estados de build",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Crear subtareas para cada aspecto del pipeline: configuración de workflows, setup de environment variables y certificados, configuración de testing automatizado, deployment automation, y notificaciones de build status"
      },
      {
        "id": "43",
        "title": "Preparar assets para App Store (iOS)",
        "description": "Crear screenshots, iconos, video preview y descripción optimizada para App Store submission",
        "details": "Crear 5 screenshots por device size requerido (6.5\" iPhone, 5.5\" iPhone, iPad opcional): timer activo, panic modal, metrics dashboard, learning content, profile. Crear app icon 1024×1024 PNG zen-inspired. Grabar app preview video 15-30s mostrando core flow. Escribir App Store description optimizada con keywords 'intermittent fasting, IF tracker, meditation'. Preparar keywords string <100 chars.",
        "testStrategy": "Verificar screenshots cumplen guidelines App Store, probar video preview <30s, validar description compelling",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear screenshots para diferentes tamaños de dispositivos iOS",
            "description": "Generar capturas de pantalla optimizadas para App Store mostrando las funcionalidades principales de la aplicación",
            "dependencies": [],
            "details": "Crear 5 screenshots por cada tamaño de dispositivo requerido (6.5\" iPhone, 5.5\" iPhone, iPad opcional) mostrando: timer activo, panic modal, metrics dashboard, learning content, y profile. Usar herramientas como Simulator de Xcode o dispositivos reales para capturar pantallas de alta calidad. Asegurar que las capturas muestren la interfaz completa sin elementos debug y con datos realistas.",
            "status": "pending",
            "testStrategy": "Verificar que screenshots cumplan con las guidelines de App Store, validar resolución correcta para cada tamaño de dispositivo, confirmar que muestran funcionalidades clave de manera atractiva",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Diseñar icono de aplicación y crear video preview",
            "description": "Crear el icono oficial de la aplicación y producir un video promocional para el App Store",
            "dependencies": [],
            "details": "Diseñar app icon de 1024×1024 PNG con inspiración zen, utilizando la paleta de colores de la aplicación (teal/green). Grabar app preview video de 15-30 segundos mostrando el flujo principal: abrir app, iniciar timer, mostrar breathing animation, y dashboard de métricas. Usar herramientas como QuickTime para grabación y herramientas de edición para optimizar el video.",
            "status": "pending",
            "testStrategy": "Verificar que el icono cumple con los estándares de Apple, probar que el video preview dura menos de 30 segundos, validar que muestra el core flow de manera efectiva",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Escribir descripción y metadata optimizada para App Store",
            "description": "Crear contenido de marketing optimizado para mejorar la visibilidad en App Store",
            "dependencies": [],
            "details": "Escribir App Store description optimizada incluyendo keywords relevantes como 'intermittent fasting', 'IF tracker', 'meditation'. Crear título atractivo y subtitle que resalten los beneficios principales. Preparar keywords string de menos de 100 caracteres para maximizar discoverabilidad. Incluir información sobre funcionalidades clave, beneficios del ayuno intermitente, y características de meditación.",
            "status": "pending",
            "testStrategy": "Validar que la descripción es compelling y clara, verificar que keywords están bien distribuidos, confirmar que el contenido cumple con las políticas de App Store",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on preparar assets para app store (ios)."
      },
      {
        "id": "44",
        "title": "Preparar assets para Google Play Store (Android)",
        "description": "Crear screenshots, feature graphic, descripción y metadata para Google Play Store submission",
        "details": "Crear screenshots para phone (1080×1920) mostrando key features. Diseñar feature graphic 1024×500 con app name y key visual. Escribir short description <80 chars y full description <4000 chars con HTML formatting. Preparar promotional video (YouTube URL). Configure age rating, content rating, privacy policy URL. Setup internal testing track para beta users.",
        "testStrategy": "Verificar assets cumplen Play Store requirements, probar descriptions son compelling, validar metadata correcto",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear screenshots y assets visuales para Google Play Store",
            "description": "Desarrollar screenshots de teléfono y feature graphic siguiendo las especificaciones de Google Play Store",
            "dependencies": [],
            "details": "Crear screenshots para teléfono (1080×1920) mostrando características clave de la app: pantalla de ayuno activo, modal de pánico, dashboard de métricas, contenido de aprendizaje y perfil de usuario. Diseñar feature graphic de 1024×500 con nombre de la app y visual clave que represente el concepto de ayuno intermitente y zen. Usar paleta de colores teal/verde consistente con el tema de la app.",
            "status": "pending",
            "testStrategy": "Verificar que todos los screenshots cumplan con las dimensiones exactas requeridas por Google Play Store, validar que las imágenes sean de alta calidad y muestren claramente las funcionalidades principales de la app",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Escribir descripciones y metadata optimizada para Google Play Store",
            "description": "Crear descripciones corta y completa con formato HTML y optimización SEO para Google Play Store",
            "dependencies": [],
            "details": "Escribir descripción corta de menos de 80 caracteres que capture la esencia de la app de ayuno intermitente. Crear descripción completa de menos de 4000 caracteres con formato HTML que incluya características principales, beneficios del ayuno intermitente, funcionalidades de meditación y tracker. Incluir keywords relevantes como 'ayuno intermitente', 'tracker IF', 'meditación', 'wellness'. Configurar categorías apropiadas y tags de contenido.",
            "status": "pending",
            "testStrategy": "Verificar que las descripciones sean atractivas y convincentes, validar que el conteo de caracteres esté dentro de los límites, probar que las keywords estén bien integradas de forma natural",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar clasificaciones y setup de testing interno",
            "description": "Completar configuración de age rating, content rating, privacy policy y configurar track de testing interno",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar age rating apropiado para la app de wellness (probablemente Everyone o Teen). Establecer content rating para aplicaciones de salud y bienestar. Añadir URL de privacy policy válida. Preparar video promocional para YouTube si es necesario. Configurar internal testing track en Google Play Console para beta users, incluyendo lista de testers y instrucciones de testing. Revisar todos los aspectos de compliance y metadata antes de submission.",
            "status": "pending",
            "testStrategy": "Validar que todos los ratings y clasificaciones sean apropiados para el contenido de la app, verificar que la privacy policy sea accesible y completa, probar que el internal testing track funcione correctamente con usuarios beta",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on preparar assets para google play store (android)."
      },
      {
        "id": "45",
        "title": "Crear documentación legal (Privacy Policy y Terms of Service)",
        "description": "Desarrollar documentos legales GDPR/CCPA compliant para cumplimiento regulatorio y app store requirements",
        "details": "Crear Privacy Policy cubriendo: data collected (email, weight, sessions, device info), usage purposes, third-party services (Supabase, OneSignal, Superwall, Sentry), user rights (export, deletion), retention periods. Crear Terms of Service cubriendo: medical disclaimers, subscription terms, user responsibilities, liability limitations. Host en https://zendfast.app/privacy y /terms. Implementar acceptance flow en onboarding.",
        "testStrategy": "Verificar documentos legalmente sound, probar URLs accessible, validar acceptance flow funciona",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear Privacy Policy GDPR/CCPA compliant",
            "description": "Desarrollar documento de Privacy Policy que cumpla con regulaciones GDPR y CCPA para la aplicación de ayuno intermitente",
            "dependencies": [],
            "details": "Crear Privacy Policy cubriendo: datos recolectados (email, peso, sesiones de ayuno, información del dispositivo), propósitos de uso, servicios de terceros (Supabase, OneSignal, Superwall, Sentry), derechos del usuario (exportar datos, eliminación), períodos de retención de datos. Debe incluir secciones sobre cookies, analytics, notificaciones push y manejo de datos de salud. Redactar en lenguaje claro y accesible para usuarios.",
            "status": "pending",
            "testStrategy": "Revisar documento con consultor legal para compliance GDPR/CCPA, verificar cobertura completa de todos los datos recolectados y servicios utilizados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear Terms of Service con disclaimers médicos",
            "description": "Desarrollar documento de Terms of Service incluyendo disclaimers médicos y términos de suscripción para la aplicación",
            "dependencies": [],
            "details": "Crear Terms of Service cubriendo: disclaimers médicos (la app no reemplaza consejos médicos, consultar profesional antes de comenzar ayuno), términos de suscripción (billing, cancelaciones, reembolsos), responsabilidades del usuario, limitaciones de responsabilidad de la empresa, términos de uso aceptable, política de terminación de cuenta. Incluir jurisdicción aplicable y resolución de disputas.",
            "status": "pending",
            "testStrategy": "Validar disclaimers médicos son suficientes para protección legal, revisar términos de suscripción con app stores, verificar compliance con regulaciones locales",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de hosting y acceptance flow",
            "description": "Configurar hosting de documentos legales en URLs públicas e implementar flujo de aceptación en onboarding",
            "dependencies": [
              1,
              2
            ],
            "details": "Hostear documentos en https://zendfast.app/privacy y https://zendfast.app/terms con design responsive y navegación clara. Implementar acceptance flow en onboarding screen donde usuarios deben aceptar Privacy Policy y Terms antes de continuar. Guardar timestamp de aceptación en UserProfile. Agregar enlaces a documentos en settings screen y footer de la app. Implementar versioning para futuras actualizaciones de términos.",
            "status": "pending",
            "testStrategy": "Probar URLs son accesibles públicamente, verificar acceptance flow bloquea acceso sin aceptación, validar timestamps se guardan correctamente, probar responsive design en diferentes dispositivos",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear documentación legal (privacy policy y terms of service)."
      },
      {
        "id": "46",
        "title": "Implementar testing de performance con métricas específicas",
        "description": "Desarrollar suite de pruebas para validar rendimiento de timer, consumo de batería y fluidez de animaciones",
        "details": "Crear performance tests para: timer accuracy (±5s en 16h), battery consumption (<5% en 16h background), app launch time (<2s cold start), animation frame rate (60fps para Lottie), memory usage monitoring. Usar Flutter DevTools Timeline para profiling. Test en target devices: Pixel 6, iPhone 13. Implement automated performance regression testing en CI.",
        "testStrategy": "Ejecutar performance tests en CI, verificar métricas meet requirements, probar en physical devices",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar herramientas de testing de performance y métricas base",
            "description": "Establecer el framework de testing de performance con Flutter DevTools y configurar métricas base para timer accuracy, battery consumption, app launch time, frame rate y memory usage",
            "dependencies": [],
            "details": "Configurar Flutter DevTools Timeline para profiling. Implementar PerformanceTestSuite con métodos para medir timer accuracy (±5s en 16h), battery consumption (<5% en 16h background), app launch time (<2s cold start), animation frame rate (60fps para Lottie) y memory usage monitoring. Crear TestMetricsCollector para capturar y almacenar datos de performance.",
            "status": "pending",
            "testStrategy": "Verificar que todas las herramientas de medición funcionan correctamente y capturan métricas precisas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar tests específicos para cada métrica de performance",
            "description": "Desarrollar tests individuales para validar cada aspecto de performance: timer accuracy, battery usage, launch time, animation smoothness y memory consumption",
            "dependencies": [
              1
            ],
            "details": "Crear TimerAccuracyTest para validar precisión de ±5s en 16h, BatteryConsumptionTest para verificar <5% consumption en background, AppLaunchTest para cold start <2s, AnimationFrameRateTest para 60fps en Lottie animations, MemoryUsageTest para monitoring. Implementar thresholds y assertions para cada métrica. Configurar test execution en target devices: Pixel 6, iPhone 13.",
            "status": "pending",
            "testStrategy": "Ejecutar cada test individualmente y verificar que los thresholds de performance se cumplan en dispositivos objetivo",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar automated performance regression testing en CI",
            "description": "Configurar pipeline de CI para ejecutar performance tests automáticamente y detectar regresiones de performance en cada deployment",
            "dependencies": [
              2
            ],
            "details": "Integrar PerformanceTestSuite en CI pipeline (GitHub Actions o similar). Configurar automated execution en cada PR y merge. Implementar PerformanceReportGenerator para generar reportes comparativos. Configurar alerts para performance regressions que excedan thresholds. Establecer baseline metrics y trending analysis. Implementar fail conditions cuando performance degrada significativamente.",
            "status": "pending",
            "testStrategy": "Verificar que CI ejecuta performance tests correctamente, detecta regresiones y genera reportes útiles para el equipo",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar testing de performance con métricas específicas."
      },
      {
        "id": "47",
        "title": "Desarrollar Edge Functions en Supabase",
        "description": "Crear funciones serverless para cálculo de métricas, scheduling de notificaciones y webhook handling",
        "details": "Crear Edge Functions: calculate-user-metrics (recalcula streak/hours tras session), schedule-notifications (OneSignal API calls), sync-user-data (conflict resolution), handle-superwall-webhook (subscription events), backup-data (GDPR export), track-analytics-event (custom events). Usar Deno runtime. Implement error handling y logging. Deploy via Supabase CLI. Setup monitoring y alertas.",
        "testStrategy": "Probar functions respond correctly, verificar error handling, validar webhook security signatures",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear Edge Function calculate-user-metrics para recálculo de métricas",
            "description": "Desarrollar función serverless que recalcula streak y horas totales de ayuno después de cada sesión completada",
            "dependencies": [],
            "details": "Implementar calculate-user-metrics.ts usando Deno runtime. La función debe recibir userId y sessionId, consultar Supabase para obtener todas las sesiones del usuario, calcular streak actual (días consecutivos), sumar horas totales ayunadas, y actualizar UserProfile. Incluir validación de datos de entrada, manejo de errores con try-catch, y logging detallado. Configurar CORS headers y autenticación JWT.",
            "status": "pending",
            "testStrategy": "Probar función responde correctamente con datos válidos, verificar cálculos de streak son precisos, validar manejo de errores con datos inválidos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar Edge Functions para notificaciones y webhooks",
            "description": "Crear funciones schedule-notifications para OneSignal y handle-superwall-webhook para eventos de suscripción",
            "dependencies": [
              1
            ],
            "details": "Implementar schedule-notifications.ts que use OneSignal API para enviar notificaciones programadas basadas en horarios de ayuno del usuario. Crear handle-superwall-webhook.ts para procesar eventos de Superwall (subscription_started, subscription_expired, etc.) y actualizar UserProfile accordingly. Incluir verificación de signatures de webhook, rate limiting, y error handling robusto con códigos HTTP apropiados.",
            "status": "pending",
            "testStrategy": "Verificar notificaciones se envían correctamente, probar webhook security signatures son válidas, validar rate limiting funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar Edge Functions de utilidad y deploy completo",
            "description": "Crear funciones sync-user-data, backup-data, track-analytics-event y configurar deployment con monitoring",
            "dependencies": [
              1,
              2
            ],
            "details": "Desarrollar sync-user-data.ts para resolución de conflictos durante sincronización, backup-data.ts para exportación GDPR de datos del usuario, y track-analytics-event.ts para eventos personalizados de analytics. Configurar deployment usando Supabase CLI con environment variables apropiadas. Setup monitoring con alertas para errores, timeouts y usage metrics. Documentar todas las funciones con ejemplos de uso.",
            "status": "pending",
            "testStrategy": "Probar todas las funciones deploy correctamente, verificar monitoring captura errores, validar backup GDPR exporta datos completos",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on desarrollar edge functions en supabase."
      },
      {
        "id": "48",
        "title": "Configurar esquemas de base de datos Supabase con RLS",
        "description": "Crear tablas, policies, triggers y seed data para backend completo con seguridad row-level",
        "details": "Crear tablas: user_profiles, fasting_sessions, hydration_logs, learning_content, motivational_phrases, analytics_events, user_metrics. Configurar RLS policies: users access solo own data, public read para content tables. Crear triggers: auto-update metrics on session complete, cleanup old analytics. Seed data: fasting plans, learning content, motivational phrases español. Setup database migrations con versioning.",
        "testStrategy": "Verificar RLS policies bloquean unauthorized access, probar triggers funcionan, validar seed data correcta",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar esquemas de base de datos principales",
            "description": "Crear esquemas SQL para todas las tablas principales del sistema con tipos de datos, constrainsts y relaciones apropiadas",
            "dependencies": [],
            "details": "Crear esquemas SQL para user_profiles (id, user_id, weight_kg, height_cm, daily_hydration_goal, created_at, updated_at), fasting_sessions (id, user_id, start_time, end_time, duration_minutes, plan_type, completed, interrupted, created_at), hydration_logs (id, user_id, amount_ml, timestamp, created_at), learning_content (id, title, content_type, category, content_url, is_premium, order_index, created_at), motivational_phrases (id, phrase_text, category, language, created_at), analytics_events (id, user_id, event_name, event_data, timestamp, created_at), user_metrics (id, user_id, total_fasts, total_duration_hours, streak_days, last_fast_date, created_at, updated_at). Incluir primary keys, foreign keys, indexes y constraints de validación.",
            "status": "pending",
            "testStrategy": "Verificar que todos los esquemas se crean sin errores, validar constraints funcionan correctamente, probar que las relaciones entre tablas son válidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar políticas de seguridad RLS",
            "description": "Implementar Row Level Security policies para controlar acceso a datos por usuario y contenido público",
            "dependencies": [
              1
            ],
            "details": "Habilitar RLS en todas las tablas. Crear políticas para user_profiles, fasting_sessions, hydration_logs, user_metrics: usuarios solo pueden acceder a sus propios datos usando auth.uid() = user_id. Para learning_content y motivational_phrases: acceso público de lectura para contenido no premium, acceso premium solo para usuarios autenticados con plan activo. Para analytics_events: solo insert permitido para propietarios. Configurar políticas de admin para operaciones de mantenimiento.",
            "status": "pending",
            "testStrategy": "Probar que usuarios no pueden acceder a datos de otros usuarios, verificar que contenido público es accesible, validar que contenido premium requiere autenticación apropiada",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear triggers automáticos para métricas",
            "description": "Implementar triggers de base de datos para actualizar automáticamente métricas de usuario y limpieza de datos",
            "dependencies": [
              1
            ],
            "details": "Crear trigger update_user_metrics_on_fast_complete que se ejecute después de UPDATE en fasting_sessions cuando completed=true: incrementar total_fasts, sumar duration a total_duration_hours, actualizar streak_days y last_fast_date en user_metrics. Crear trigger cleanup_old_analytics que se ejecute diariamente para eliminar analytics_events más antiguos de 90 días. Crear trigger update_timestamps que actualice updated_at en user_profiles y user_metrics automáticamente.",
            "status": "pending",
            "testStrategy": "Verificar que métricas se actualizan correctamente al completar ayunos, probar que cleanup funciona sin afectar datos recientes, validar que timestamps se actualizan automáticamente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar sistema de migraciones",
            "description": "Establecer estructura de migraciones versionadas para manejo de cambios de esquema en producción",
            "dependencies": [],
            "details": "Crear directorio supabase/migrations/ con archivos numerados secuencialmente (001_initial_schema.sql, 002_add_rls_policies.sql, etc.). Configurar Supabase CLI para manejar migraciones automáticamente. Crear scripts para aplicar migraciones: up.sql para aplicar cambios, down.sql para rollback. Implementar migration_history table para tracking de versiones aplicadas. Documentar proceso de deployment de migraciones en README.",
            "status": "pending",
            "testStrategy": "Probar que migraciones se aplican en orden correcto, verificar rollback funciona apropiadamente, validar que migration_history mantiene estado consistente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Poblar base de datos con datos iniciales",
            "description": "Insertar datos semilla para planes de ayuno, contenido educativo y frases motivacionales en español",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear seed data para learning_content: artículos sobre beneficios del ayuno intermitente, guías de hidratación, técnicas de mindfulness (mínimo 20 artículos). Poblar motivational_phrases con 100+ frases motivacionales en español categorizadas por momento (inicio, durante, finalización ayuno). Crear fasting plans predefinidos: 16:8, 18:6, 20:4, 24h con descripciones y recomendaciones. Insertar contenido premium marcado apropiadamente. Usar archivos CSV/JSON para facilitar mantenimiento.",
            "status": "pending",
            "testStrategy": "Verificar que todos los datos se insertan correctamente, probar que contenido aparece en aplicación, validar que categorización funciona apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Testing exhaustivo de seguridad y funcionalidad",
            "description": "Realizar pruebas completas de políticas RLS, triggers y integridad de datos",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Crear suite de tests para validar RLS policies: intentar acceso no autorizado entre usuarios, verificar escalación de privilegios no es posible, probar bypass de seguridad. Testear triggers con datos reales: completar múltiples ayunos y verificar métricas, probar edge cases como interrupciones. Realizar load testing con 1000+ registros simultáneos. Usar herramientas como pgTAP para tests automatizados de base de datos. Documentar todos los casos de prueba y resultados.",
            "status": "pending",
            "testStrategy": "Ejecutar suite completa de tests de seguridad sin fallos, verificar performance bajo carga, validar que no hay vulnerabilidades de acceso a datos",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Dividir en diseño de esquemas de base de datos, configuración de políticas RLS, creación de triggers automáticos, setup de migraciones, seeding de datos iniciales, y testing de seguridad"
      },
      {
        "id": "49",
        "title": "Implementar sistema de migración de datos",
        "description": "Desarrollar estrategia para migrar esquemas Isar y Supabase sin pérdida de datos de usuarios",
        "details": "Crear DatabaseMigrationService para Isar schema changes con version tracking en SharedPreferences. Implement migration scripts para add/rename fields manteniendo data integrity. Para Supabase: crear SQL migrations files con timestamps, usar Supabase CLI para apply. Implement rollback procedures y testing en development. Create data export/import functionality para user portability (GDPR).",
        "testStrategy": "Probar migrations no pierden data, verificar rollbacks funcionan, validar export/import data integrity",
        "priority": "low",
        "dependencies": [
          "2",
          "48"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear DatabaseMigrationService para Isar",
            "description": "Implementar servicio de migración para manejar cambios de esquema en base de datos Isar con versionado",
            "dependencies": [],
            "details": "Crear DatabaseMigrationService con version tracking en SharedPreferences. Implementar métodos para detectar cambios de esquema, aplicar migrations step-by-step, y mantener backward compatibility. Incluir logging detallado de migration process y error handling robusto para fallos durante migración.",
            "status": "pending",
            "testStrategy": "Probar migrations con diferentes versiones de esquema, verificar data integrity se mantiene, validar version tracking funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de migraciones SQL para Supabase",
            "description": "Desarrollar infraestructura para manejar migraciones de base de datos Supabase con timestamping y rollbacks",
            "dependencies": [
              1
            ],
            "details": "Crear SQL migration files con timestamps únicos. Configurar Supabase CLI integration para aplicar migrations automáticamente. Implementar rollback procedures con scripts de reversión. Crear migration tracking table en Supabase para monitorear estado de migrations aplicadas.",
            "status": "pending",
            "testStrategy": "Probar migrations en entorno de desarrollo, verificar rollbacks funcionan correctamente, validar no hay pérdida de datos durante proceso",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar funcionalidad de export/import de datos de usuario",
            "description": "Crear sistema para exportar e importar datos de usuario completos para portabilidad y cumplimiento GDPR",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar DataExportService que genere JSON completo de user data desde Isar y Supabase. Crear DataImportService para restaurar datos en nueva instalación o después de migration. Incluir validación de data integrity, encriptación de exports sensibles, y UI para gestionar export/import process.",
            "status": "pending",
            "testStrategy": "Verificar export incluye todos los datos de usuario, probar import restaura datos correctamente, validar integridad de datos post-import",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de migración de datos."
      },
      {
        "id": "50",
        "title": "Crear suite de testing E2E completa",
        "description": "Desarrollar pruebas end-to-end cubriendo flujos críticos de usuario con integration_test",
        "details": "Usar integration_test package para E2E tests. Cubrir critical paths: onboarding flow completo, start/complete fast, panic button durante ayuno, water logging, session completion con metrics update. Test offline scenarios: app funciona sin internet, sync recovery on reconnect. Mock external services (Supabase, OneSignal) para deterministic testing. Run en CI con emulators.",
        "testStrategy": "Ejecutar E2E tests en CI pipeline, verificar critical paths covered, probar offline functionality",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar framework de testing E2E con integration_test",
            "description": "Instalar y configurar el package integration_test de Flutter para ejecutar pruebas end-to-end con emuladores",
            "dependencies": [],
            "details": "Agregar integration_test dependency al pubspec.yaml. Crear directorio integration_test/ con estructura básica. Configurar test runner para Android y iOS emulators. Implementar helper functions para navigation, form filling, y assertions. Configurar CI pipeline para ejecutar tests automáticamente con emulators.",
            "status": "pending",
            "testStrategy": "Verificar que tests básicos ejecuten correctamente en emulators locales y CI",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar tests de flujos críticos de usuario",
            "description": "Crear pruebas E2E para onboarding, inicio/finalización de ayuno, botón de pánico, logging de agua y completion de sesiones",
            "dependencies": [
              1
            ],
            "details": "Desarrollar test cases para: onboarding flow completo desde registro hasta primera sesión, start/complete fast workflow con timers, panic button durante ayuno activo, water logging functionality, session completion con metrics update. Implementar page objects pattern para maintainability. Usar realistic test data y user scenarios.",
            "status": "pending",
            "testStrategy": "Ejecutar todos los critical paths y verificar que cubren los escenarios de usuario más importantes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar testing offline y mocking de servicios externos",
            "description": "Crear tests para funcionalidad offline y mock de Supabase/OneSignal para pruebas determinísticas",
            "dependencies": [
              2
            ],
            "details": "Implementar tests offline: app funciona sin internet, data persiste localmente, sync recovery cuando reconnect. Mock Supabase responses para authentication, data sync, y RLS policies. Mock OneSignal para push notifications testing. Crear deterministic test scenarios con controlled network conditions. Implementar network simulation para edge cases.",
            "status": "pending",
            "testStrategy": "Verificar que la app funciona completamente offline y que el sync recovery funciona correctamente al reconectarse",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear suite de testing e2e completa."
      },
      {
        "id": "51",
        "title": "Implementar beta testing con usuarios reales",
        "description": "Configurar programa de beta testing con 20 usuarios para validar funcionalidad y recopilar feedback",
        "details": "Setup TestFlight (iOS) y Google Play Internal Testing (Android) tracks. Recruit 20 beta testers via social media/forums. Crear beta testing guidelines y feedback form (Google Forms/Typeform). Implement in-app feedback widget para easy bug reporting. Collect metrics: session completion rates, crash frequency, feature usage. Iterate basado en feedback antes production launch.",
        "testStrategy": "Verificar beta distributions funcionan, probar feedback collection effective, validar metrics tracking",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar distribución de beta en TestFlight y Google Play Console",
            "description": "Configurar las plataformas de distribución beta para iOS y Android, estableciendo los tracks internos necesarios para el programa de beta testing",
            "dependencies": [],
            "details": "Configurar TestFlight para iOS creando un nuevo grupo de beta testers y subiendo la build de la app. Para Android, configurar Google Play Internal Testing track y subir la APK/AAB. Establecer configuraciones de distribución, límites de usuarios, y configurar metadata necesaria para ambas plataformas. Verificar que las builds se distribuyan correctamente a los testers.",
            "status": "pending",
            "testStrategy": "Verificar que las builds se suban correctamente, probar descarga e instalación en dispositivos de prueba, validar configuraciones de distribución",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Reclutar 20 beta testers y crear guidelines de testing",
            "description": "Reclutar usuarios beta a través de redes sociales y foros, y crear documentación y formularios para el programa de beta testing",
            "dependencies": [
              1
            ],
            "details": "Crear strategy de reclutamiento via Twitter, Reddit, Discord y foros relevantes de ayuno intermitente. Crear beta testing guidelines document explicando objetivos, duración del programa, y expectativas. Desarrollar feedback form usando Google Forms o Typeform con secciones para bugs, sugerencias de features, y experiencia general. Establecer canal de comunicación directo con beta testers (Discord/Slack).",
            "status": "pending",
            "testStrategy": "Verificar que el proceso de reclutamiento genere suficientes candidatos calificados, probar formularios de feedback funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar widget de feedback in-app y sistema de métricas",
            "description": "Desarrollar widget de feedback integrado en la app y sistema de recolección de métricas para monitorear el comportamiento de los beta testers",
            "dependencies": [
              2
            ],
            "details": "Implementar FeedbackWidget como floating button o drawer item que abra modal para reportar bugs o sugerencias. Integrar con feedback form API o envío directo por email. Implementar analytics tracking para métricas clave: session completion rates, crash frequency usando Crashlytics, feature usage con custom events, user retention. Crear dashboard para monitorear métricas en tiempo real durante beta period.",
            "status": "pending",
            "testStrategy": "Probar widget de feedback envía reports correctamente, verificar métricas se capturan accurately, validar dashboard muestra datos en tiempo real",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar beta testing con usuarios reales."
      },
      {
        "id": "52",
        "title": "Configurar monitoreo de app con analytics custom",
        "description": "Implementar tracking de eventos críticos para product insights y funnel analysis",
        "details": "Implementar custom analytics events: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown. Usar Supabase analytics_events table y/o third-party service (Mixpanel/Amplitude). Create analytics dashboard para track: completion rates por plan type, panic button usage correlation, conversion funnels. Implement privacy-compliant tracking (no PII).",
        "testStrategy": "Verificar events se logean correctamente, probar analytics dashboard functional, validar privacy compliance",
        "priority": "low",
        "dependencies": [
          "48"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar tracking de eventos analíticos básicos",
            "description": "Crear servicio de analytics e implementar tracking de eventos críticos como fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed",
            "dependencies": [],
            "details": "Crear AnalyticsService class que maneje tracking de eventos. Implementar métodos para cada evento crítico: trackFastingStarted(), trackFastingCompleted(), trackFastingInterrupted(), trackPanicButtonUsed(), trackMeditationCompleted(). Configurar parámetros relevantes para cada evento (duration, planType, userId). Implementar queue local para eventos offline y sync cuando hay conexión. Asegurar compliance con privacidad (no enviar PII directamente).",
            "status": "pending",
            "testStrategy": "Verificar que eventos se registran correctamente en diferentes escenarios, probar funcionamiento offline/online, validar que no se envía información personal identificable",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar backend analytics con Supabase y servicio tercero",
            "description": "Configurar tabla analytics_events en Supabase e integrar servicio de analytics de terceros como Mixpanel o Amplitude para almacenamiento y procesamiento",
            "dependencies": [
              1
            ],
            "details": "Crear tabla analytics_events en Supabase con campos: event_name, user_id (hash), properties (JSONB), timestamp, session_id. Configurar RLS policies para seguridad. Integrar Mixpanel o Amplitude SDK para analytics avanzados. Implementar doble tracking: eventos críticos a Supabase para control directo, eventos de engagement a third-party para análisis profundo. Configurar batching y retry logic para optimizar performance.",
            "status": "pending",
            "testStrategy": "Verificar inserción correcta en Supabase, probar integración con servicio tercero, validar políticas de seguridad y batching de eventos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear dashboard de analytics y métricas de conversión",
            "description": "Desarrollar dashboard para visualizar métricas clave: completion rates por plan, uso de panic button, conversion funnels y premium conversions",
            "dependencies": [
              2
            ],
            "details": "Crear dashboard web usando Supabase queries para mostrar: completion rates por tipo de plan de ayuno, correlación de uso del panic button con abandono, funnel de conversión desde gratuito a premium, métricas de paywall_shown vs premium_conversion. Implementar gráficos temporales, filtros por fecha y segmentación de usuarios. Configurar métricas clave: CAC, LTV, retention rates, churn analysis. Incluir alertas automáticas para métricas críticas.",
            "status": "pending",
            "testStrategy": "Verificar precisión de cálculos de métricas, probar filtros y visualizaciones funcionan correctamente, validar alertas se disparan apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en implementación de tracking de eventos, configuración de analytics backend (Supabase/terceros), y creación de dashboard para visualización de métricas"
      },
      {
        "id": "53",
        "title": "Optimizar performance y memory usage",
        "description": "Realizar optimizaciones finales para asegurar fluidez en dispositivos de gama media y bajo consumo de memoria",
        "details": "Profile app con Flutter DevTools para identify bottlenecks. Optimize Riverpod providers para avoid unnecessary rebuilds. Implement lazy loading para learning content images. Optimize Lottie animations para smooth playback. Use const constructors where possible. Implement image caching strategies. Monitor memory leaks con Dart DevTools. Target: <100MB RAM usage, 60fps animations, <2s cold start.",
        "testStrategy": "Ejecutar performance profiling, verificar memory usage within targets, probar en low-end devices",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Realizar profiling y análisis de rendimiento con Flutter DevTools",
            "description": "Ejecutar análisis completo de rendimiento usando Flutter DevTools para identificar cuellos de botella en CPU, memoria y renderizado",
            "dependencies": [],
            "details": "Usar Flutter DevTools para profile la app en dispositivos de gama media. Analizar CPU usage patterns, memory allocation spikes, y frame rendering times. Identificar widgets que causan unnecessary rebuilds. Generar performance reports y documentar bottlenecks específicos. Focus en scenarios de uso intensivo como scroll de listas largas y animaciones simultáneas.",
            "status": "pending",
            "testStrategy": "Ejecutar profiling en al menos 3 dispositivos diferentes de gama media, documentar métricas before/after optimizations",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Optimizar Riverpod providers y implementar lazy loading",
            "description": "Refactorizar providers de Riverpod para evitar rebuilds innecesarios e implementar carga perezosa de contenido multimedia",
            "dependencies": [
              1
            ],
            "details": "Revisar todos los Riverpod providers para ensure proper dispose y avoid memory leaks. Implementar autoDispose donde sea apropiado. Crear lazy loading system para images de learning content usando cached_network_image. Optimize provider dependencies para minimize rebuild cascades. Implementar image preloading strategy para improve UX.",
            "status": "pending",
            "testStrategy": "Monitorear memory usage durante navigation, verificar images se cargan on-demand, probar scroll performance en listas con imágenes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Optimizar animaciones Lottie y implementar estrategias de caching",
            "description": "Mejorar rendimiento de animaciones Lottie y establecer sistema de caché efectivo para reducir consumo de memoria",
            "dependencies": [
              1,
              2
            ],
            "details": "Optimize Lottie animations para 60fps playback usando composition optimization. Implementar const constructors en todos widgets where possible. Create comprehensive image caching strategy usando flutter_cache_manager. Monitor memory leaks usando Dart DevTools. Ensure total RAM usage stays <100MB y cold start <2s. Implement performance monitoring dashboard.",
            "status": "pending",
            "testStrategy": "Verificar 60fps en animaciones, confirmar RAM usage <100MB, medir cold start time, probar en dispositivos de gama baja",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on optimizar performance y memory usage."
      },
      {
        "id": "54",
        "title": "Finalizar preparación para production launch",
        "description": "Completar checklist final para submission a app stores incluyendo compliance, security y polish",
        "details": "Complete app store compliance checklist: metadata, screenshots, descriptions, ratings. Final security audit: no hardcoded secrets, proper certificate pinning, secure API communication. Polish UI: consistent spacing, proper loading states, error handling. Verify accessibility compliance. Test en production environment con real Supabase/OneSignal. Create launch plan con marketing timeline.",
        "testStrategy": "Ejecutar full QA checklist, verificar production environment functional, validar store requirements met",
        "priority": "high",
        "dependencies": [
          "43",
          "44",
          "45"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Completar checklist de compliance para app stores",
            "description": "Verificar que todos los requisitos de metadata, screenshots, descripciones y ratings estén completos y cumplan con las guidelines de App Store y Google Play",
            "dependencies": [
              43,
              44
            ],
            "details": "Revisar metadata completo en App Store Connect y Google Play Console. Verificar screenshots están en formatos correctos y muestran features principales. Validar descripciones optimizadas con keywords relevantes. Confirmar age rating y content rating apropiados. Verificar privacy policy URL funcional. Validar todos los assets required están subidos correctamente.",
            "status": "pending",
            "testStrategy": "Ejecutar checklist completo de requirements para ambas stores, verificar preview builds se muestran correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Realizar auditoría final de seguridad y certificados",
            "description": "Ejecutar security audit completo verificando no hay hardcoded secrets, certificate pinning correcto y comunicación API segura",
            "dependencies": [],
            "details": "Escanear codebase para hardcoded API keys o secrets. Verificar certificate pinning está implementado para Supabase y OneSignal. Probar comunicación API usa HTTPS exclusivamente. Revisar permissions solicitados son mínimos necesarios. Verificar obfuscation en production builds. Confirmar no hay debug logs en release. Validar data encryption en local storage.",
            "status": "pending",
            "testStrategy": "Usar herramientas de static analysis, probar man-in-the-middle attacks fallan, verificar production builds no exponen debug info",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Polish final de UI y testing en production environment",
            "description": "Pulir interfaz con spacing consistente, loading states y error handling, luego probar en production environment con servicios reales",
            "dependencies": [],
            "details": "Revisar spacing consistente en todas las pantallas según design system. Implementar loading states en todas las llamadas API. Verificar error handling muestra mensajes user-friendly. Confirmar accessibility compliance con screen readers. Probar app completa en production environment con Supabase y OneSignal reales. Verificar performance bajo condiciones reales. Crear launch plan con timeline de marketing.",
            "status": "pending",
            "testStrategy": "Testing manual completo en production environment, verificar accessibility con screen readers, performance testing con datos reales",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on finalizar preparación para production launch."
      },
      {
        "id": "55",
        "title": "Ejecutar submission a App Store y Google Play",
        "description": "Realizar submission final a las tiendas de aplicaciones con todos los assets y configuraciones necesarias",
        "details": "Submit iOS app a App Store Connect con: production build obfuscado, all required screenshots, app preview video, optimized description, proper categorization (Health & Fitness), age rating (4+). Submit Android app a Google Play Console con: production AAB, feature graphic, screenshots, content rating, privacy policy link. Monitor review process y respond a feedback si necesario.",
        "testStrategy": "Verificar submissions sin errores, probar builds funcionan en store review devices, monitor approval status",
        "priority": "high",
        "dependencies": [
          "54"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Preparar y subir aplicación iOS a App Store Connect",
            "description": "Configurar y subir la build de producción de iOS con todos los metadatos y assets requeridos para la revisión de Apple",
            "dependencies": [],
            "details": "Generar build de producción obfuscado para iOS usando flutter build ipa --release --obfuscate. Subir a App Store Connect via Xcode o Transporter. Configurar metadatos: título, descripción optimizada, palabras clave, categoría Health & Fitness, age rating 4+. Subir screenshots requeridos para todos los tamaños de pantalla iPhone. Añadir app preview video si disponible. Configurar pricing como gratuito con IAPs. Enviar para revisión.",
            "status": "pending",
            "testStrategy": "Verificar build se instala correctamente en dispositivos de prueba, validar todos los metadatos están completos, confirmar screenshots se ven correctos en App Store Connect",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Preparar y subir aplicación Android a Google Play Console",
            "description": "Configurar y subir el AAB de producción de Android con todos los assets y configuraciones necesarias para Google Play Store",
            "dependencies": [],
            "details": "Generar Android App Bundle (AAB) de producción usando flutter build appbundle --release --obfuscate. Subir a Google Play Console. Configurar store listing: título, descripción corta/larga, feature graphic, screenshots para phone/tablet. Configurar content rating completando cuestionario. Añadir privacy policy link. Configurar pricing como gratuito. Configurar countries de distribución. Enviar a revisión en track de producción.",
            "status": "pending",
            "testStrategy": "Probar AAB en dispositivos internos, verificar todos los assets se ven correctos en Play Console, confirmar content rating es apropiado",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Monitorear proceso de revisión y responder feedback",
            "description": "Supervisar el estado de las revisiones en ambas tiendas y responder rápidamente a cualquier feedback o rechazo",
            "dependencies": [
              1,
              2
            ],
            "details": "Monitorear App Store Connect y Google Play Console diariamente para updates del estado de revisión. Si hay rejection, analizar feedback detalladamente y crear plan de corrección. Responder a reviewers si necesario via Resolution Center. Preparar hotfixes si required. Documentar cualquier issue encontrado para futuras submissions. Notificar a stakeholders sobre timeline updates.",
            "status": "pending",
            "testStrategy": "Configurar notifications para cambios de estado, probar respuestas rápidas a rejections simulados, verificar comunicación con reviewers funciona",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on ejecutar submission a app store y google play."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-24T17:58:18.029Z",
      "taskCount": 55,
      "completedCount": 2,
      "tags": [
        "master"
      ]
    }
  }
}