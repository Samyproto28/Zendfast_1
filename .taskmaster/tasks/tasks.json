{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Configurar sistema de diseño Zendfast (colores, tipografía, espaciado)",
        "description": "Crear el sistema de diseño base con colores zen-inspirados, tipografías legibles y espaciado consistente para toda la aplicación",
        "details": "Implementar ZendfastColors con paleta: Teal principal (#069494), Verde secundario (#7fb069), Naranja para botón pánico (#ffb366). Configurar tipografías: Inter para headers, Source Sans Pro para cuerpo, Nunito Sans para énfasis emocional. Establecer espaciado base 8dp grid system. Crear ThemeData para Material 3 con elevaciones y radios de borde apropiados.",
        "testStrategy": "Verificar contraste WCAG 2.1 AA (4.5:1 mínimo), pruebas de snapshot visual para consistencia, validar tamaños de fuente legibles (16sp mínimo para cuerpo)",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar paleta de colores ZendfastColors con Material 3",
            "description": "Crear clase ZendfastColors con la paleta completa: Teal principal (#069494), Verde secundario (#7fb069), Naranja para botón pánico (#ffb366) y configurar ColorScheme para Material 3",
            "dependencies": [],
            "details": "Crear archivo lib/theme/colors.dart con clase ZendfastColors conteniendo colores primarios, secundarios, surface, background, error y sus variantes. Implementar ColorScheme.fromSeed() usando teal como color primario. Agregar colores semánticos específicos como panicButton, successColor, warningColor. Definir variaciones para light/dark theme. Asegurar compatibilidad con Material 3 color tokens.",
            "status": "done",
            "testStrategy": "Verificar contraste WCAG 2.1 AA mínimo 4.5:1 entre texto y fondo, probar visualización en dispositivos con diferentes pantallas, validar coherencia en light/dark themes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar tipografías Inter, Source Sans Pro y Nunito Sans",
            "description": "Establecer jerarquía tipográfica con Inter para headers, Source Sans Pro para texto de cuerpo y Nunito Sans para énfasis emocional, integrando con TextTheme de Material 3",
            "dependencies": [
              1
            ],
            "details": "Agregar fuentes a pubspec.yaml y assets/fonts/. Crear ZendfastTextStyles con estilos: displayLarge/Medium/Small (Inter), headlineLarge/Medium/Small (Inter), bodyLarge/Medium/Small (Source Sans Pro), labelLarge/Medium/Small (Nunito Sans). Configurar TextTheme con tamaños apropiados: headlines 24-32sp, body 16-18sp, labels 12-14sp. Implementar responsive typography scaling.",
            "status": "done",
            "testStrategy": "Verificar legibilidad con tamaño mínimo 16sp para texto de cuerpo, probar en diferentes tamaños de pantalla, validar carga correcta de fuentes custom",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Establecer sistema de espaciado 8dp grid y ThemeData completo",
            "description": "Implementar sistema de espaciado basado en grid de 8dp y crear ThemeData completo para Material 3 con elevaciones, radios de borde y componentes",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear ZendfastSpacing con valores: xs(4dp), s(8dp), m(16dp), l(24dp), xl(32dp), xxl(40dp). Implementar ZendfastTheme que combine colores, tipografías y espaciado en ThemeData. Configurar elevaciones Material 3: level0-5. Establecer border radius: small(4dp), medium(8dp), large(12dp), extraLarge(16dp). Configurar component themes: AppBar, Card, Button, TextField con estilos consistentes.",
            "status": "done",
            "testStrategy": "Verificar espaciado consistente en toda la app, probar elevaciones y sombras apropiadas, validar component themes aplicados correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on configurar sistema de diseño zendfast (colores, tipografía, espaciado)."
      },
      {
        "id": 2,
        "title": "Configurar base de datos Isar v3.1.0 con esquemas principales",
        "description": "Inicializar Isar con esquemas para FastingSession, UserProfile, HydrationLog y ContentItem con relaciones y índices optimizados",
        "details": "Instalar isar 3.1.0, isar_flutter_libs, build_runner. Crear esquemas @collection para: FastingSession (id, userId, startTime, endTime, durationMinutes, completed, interrupted, planType), UserProfile (id, weightKg, heightCm, dailyHydrationGoal calculado), HydrationLog (id, userId, amount, timestamp), ContentItem (id, title, contentType, category, url, isPremium). Configurar índices para consultas frecuentes (userId, timestamp). Implementar DatabaseService singleton.",
        "testStrategy": "Pruebas unitarias CRUD para cada colección, verificar migraciones funcionan, probar rendimiento con 1000+ registros",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencias de Isar y configurar build tools",
            "description": "Instalar las dependencias necesarias de Isar 3.1.0 y configurar las herramientas de construcción para Flutter",
            "dependencies": [],
            "details": "Agregar al pubspec.yaml: isar: ^3.1.0, isar_flutter_libs: ^3.1.0, path_provider: ^2.0.11. En dev_dependencies agregar: build_runner: ^2.2.1, isar_generator: ^3.1.0. Ejecutar flutter pub get para instalar dependencias. Configurar build.yaml si es necesario para optimizaciones de generación de código.",
            "status": "done",
            "testStrategy": "Verificar que flutter pub get se ejecuta sin errores y que todas las dependencias se instalan correctamente",
            "updatedAt": "2025-10-24T17:57:39.377Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear esquemas de colecciones con anotaciones @collection",
            "description": "Definir los modelos de datos FastingSession, UserProfile, HydrationLog y ContentItem con sus campos y tipos correspondientes",
            "dependencies": [
              1
            ],
            "details": "Crear lib/models/ con archivos: fasting_session.dart (id, userId, startTime, endTime, durationMinutes, completed, interrupted, planType), user_profile.dart (id, weightKg, heightCm, dailyHydrationGoal calculado), hydration_log.dart (id, userId, amount, timestamp), content_item.dart (id, title, contentType, category, url, isPremium). Usar anotaciones @collection, @Id(), @Index() para optimización. Definir relaciones entre entidades usando @Backlink() donde sea apropiado.",
            "status": "done",
            "testStrategy": "Ejecutar dart run build_runner build para generar código y verificar que no hay errores de compilación en los esquemas",
            "parentId": "undefined",
            "updatedAt": "2025-10-24T17:58:09.523Z"
          },
          {
            "id": 3,
            "title": "Implementar DatabaseService singleton con inicialización de Isar",
            "description": "Crear servicio singleton para manejar la conexión a la base de datos Isar y operaciones CRUD básicas",
            "dependencies": [
              2
            ],
            "details": "Crear lib/services/database_service.dart como singleton. Implementar método initializeDatabase() que abra Isar con todos los esquemas definidos. Crear métodos CRUD básicos para cada colección: createFastingSession(), getUserProfile(), logHydration(), getContentItems(). Configurar índices compuestos para consultas frecuentes (userId + timestamp). Manejar errores de inicialización y proporcionar fallbacks apropiados.",
            "status": "done",
            "testStrategy": "Pruebas unitarias para verificar inicialización correcta de la base de datos, operaciones CRUD básicas y manejo de errores",
            "parentId": "undefined",
            "updatedAt": "2025-10-24T17:58:18.007Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on configurar base de datos isar v3.1.0 con esquemas principales.",
        "updatedAt": "2025-10-24T17:58:18.007Z"
      },
      {
        "id": 3,
        "title": "Configurar cliente Supabase con autenticación y RLS",
        "description": "Establecer conexión con Supabase, configurar autenticación email/password y políticas Row Level Security para aislamiento de datos",
        "details": "Instalar supabase_flutter ^2.0.0. Configurar client con URL y anon key desde environment variables. Implementar AuthService con métodos signUp, signIn, signOut, resetPassword. Crear tablas en Supabase: user_profiles, fasting_sessions, hydration_logs, learning_content, analytics_events. Configurar RLS policies: usuarios solo acceden a sus datos. Implementar manejo de errores Supabase específicos.",
        "testStrategy": "Pruebas de integración para auth flows, verificar RLS bloquea acceso no autorizado, probar conexión offline/online",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar cliente Supabase y variables de entorno",
            "description": "Instalar y configurar el cliente Supabase con credenciales de entorno",
            "dependencies": [],
            "details": "Instalar supabase_flutter ^2.0.0 en pubspec.yaml. Crear archivo .env con SUPABASE_URL y SUPABASE_ANON_KEY. Configurar flutter_dotenv para cargar variables. Inicializar cliente Supabase en main.dart con credenciales de entorno. Configurar manejo seguro de API keys.",
            "status": "done",
            "testStrategy": "Verificar conexión exitosa con Supabase, probar carga de variables de entorno",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar AuthService con métodos de autenticación",
            "description": "Crear servicio de autenticación con todos los flujos requeridos",
            "dependencies": [
              1
            ],
            "details": "Crear AuthService class con métodos signUp, signIn, signOut, resetPassword. Implementar manejo de estados de autenticación con Stream. Configurar persistencia de sesión automática. Implementar validación de email y contraseña. Añadir manejo de errores específicos de Supabase Auth.",
            "status": "done",
            "testStrategy": "Probar todos los flujos de autenticación, verificar persistencia de sesión, validar manejo de errores",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear estructura de tablas en Supabase",
            "description": "Configurar todas las tablas necesarias en la base de datos",
            "dependencies": [
              1
            ],
            "details": "Crear tablas: user_profiles (id, user_id, name, preferences), fasting_sessions (id, user_id, start_time, end_time, duration), hydration_logs (id, user_id, amount, timestamp), learning_content (id, title, content, category), analytics_events (id, user_id, event_name, properties, timestamp). Configurar relaciones foreign key apropiadas.",
            "status": "done",
            "testStrategy": "Verificar creación correcta de tablas, probar relaciones entre tablas, validar constraints",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar políticas RLS para seguridad de datos",
            "description": "Implementar Row Level Security para aislamiento completo de datos de usuario",
            "dependencies": [
              3
            ],
            "details": "Habilitar RLS en todas las tablas de usuario. Crear políticas: usuarios solo pueden leer/escribir sus propios datos basado en auth.uid(). Configurar políticas específicas para user_profiles, fasting_sessions, hydration_logs, analytics_events. Crear políticas de lectura pública solo para learning_content.",
            "status": "done",
            "testStrategy": "Probar que usuarios no pueden acceder a datos de otros, verificar políticas funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar manejo de errores y testing de flujos",
            "description": "Configurar manejo robusto de errores y testing completo del sistema",
            "dependencies": [
              2,
              4
            ],
            "details": "Crear SupabaseErrorHandler para manejar errores específicos (network, auth, database). Implementar retry logic para operaciones fallidas. Crear tests de integración para auth flows completos. Probar escenarios offline/online. Implementar logging de errores para debugging.",
            "status": "done",
            "testStrategy": "Verificar manejo correcto de todos los tipos de error, probar resilience en conexiones pobres",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Dividir en setup de cliente Supabase, implementación de AuthService, configuración de tablas y RLS policies, manejo de errores específicos, y testing de flows de autenticación"
      },
      {
        "id": 4,
        "title": "Implementar servicio de fondo para persistencia del timer",
        "description": "Configurar flutter_background_service para mantener timer activo cuando app está cerrada o en background",
        "details": "Instalar flutter_background_service ^3.0.0. Configurar permisos Android (FOREGROUND_SERVICE, WAKE_LOCK) e iOS (background modes). Crear BackgroundTimerService que mantenga estado del ayuno en SharedPreferences. Implementar notificación persistente mostrando tiempo restante. Manejar reinicio del dispositivo y auto-start del servicio. Sincronizar estado con UI principal cuando app vuelve a foreground.",
        "testStrategy": "Probar timer continúa tras force-quit, verificar precisión ±5 segundos después de 16 horas, validar consumo batería <5% en 16h",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar dependencias y permisos del servicio de fondo",
            "description": "Instalar flutter_background_service y configurar todos los permisos necesarios para Android e iOS",
            "dependencies": [],
            "details": "Instalar flutter_background_service ^3.0.0 en pubspec.yaml. Configurar permisos Android: FOREGROUND_SERVICE, WAKE_LOCK, SYSTEM_ALERT_WINDOW en AndroidManifest.xml. Configurar iOS background modes en Info.plist: background-processing, background-fetch. Configurar workmanager para tareas periódicas. Agregar permisos de notificación local.",
            "status": "done",
            "testStrategy": "Verificar que la app puede ejecutar en background sin crashes, probar permisos funcionan en ambas plataformas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar BackgroundTimerService con persistencia",
            "description": "Crear servicio que mantenga el estado del timer activo usando SharedPreferences y notificaciones",
            "dependencies": [
              1
            ],
            "details": "Crear BackgroundTimerService class que implemente flutter_background_service. Usar SharedPreferences para persistir: start_time, duration, fasting_state. Implementar timer que actualice cada minuto en background. Crear notificación persistente mostrando tiempo restante formateado. Implementar auto-start del servicio tras reinicio del dispositivo usando boot receiver (Android) y background app refresh (iOS).",
            "status": "done",
            "testStrategy": "Probar que el timer continúa contando tras force-quit de la app, verificar notificación se actualiza correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Sincronizar estado entre servicio de fondo y UI principal",
            "description": "Implementar comunicación bidireccional entre el servicio de fondo y la interfaz de usuario",
            "dependencies": [
              2
            ],
            "details": "Crear TimerSyncService para manejar comunicación entre background service y UI. Implementar stream listeners para detectar cuando app vuelve a foreground. Sincronizar estado desde SharedPreferences al TimerProvider de Riverpod. Manejar casos edge: diferencias de tiempo, estados inconsistentes, recovery automático. Implementar heartbeat mechanism para validar que background service está activo.",
            "status": "done",
            "testStrategy": "Verificar sincronización correcta cuando app vuelve a foreground, probar precisión del timer ±5 segundos después de períodos largos",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar servicio de fondo para persistencia del timer."
      },
      {
        "id": 5,
        "title": "Configurar OneSignal para notificaciones push",
        "description": "Integración completa de OneSignal para notificaciones push con templates de ayuno, hidratación y engagement, incluyendo deep linking y persistencia de historial. Sistema dual con fallback de notificaciones locales.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "✅ IMPLEMENTACIÓN COMPLETA: OneSignalService con templates completos (inicio/hitos/finalización ayuno, hidratación, re-engagement), LocalNotificationService como fallback funcional SIN Firebase/Apple Developer, NotificationProvider con Riverpod para estado, DeepLinkHandler configurado (zendfast:// scheme), PushNotification model en Isar para historial, permisos Android/iOS configurados, documentación completa en ONESIGNAL_SETUP.md. Sistema listo para producción con 30 minutos de configuración externa (Firebase + Apple Developer).",
        "testStrategy": "✅ Sistema funcional: notificaciones locales funcionan inmediatamente, OneSignal configurado para activación rápida, deep linking implementado para navegación automática, persistencia de historial en base de datos local, templates probados para todos los casos de uso de ayuno e hidratación.",
        "subtasks": [
          {
            "id": 5,
            "title": "Implementar sistema de fallback con notificaciones locales",
            "description": "Crear LocalNotificationService como alternativa funcional que no requiere configuración externa",
            "dependencies": [
              4
            ],
            "details": "Implementar LocalNotificationService usando flutter_local_notifications para funcionar sin Firebase/Apple Developer. Crear templates locales equivalentes para ayuno e hidratación. Configurar programación de notificaciones con timezone support. Implementar cancelación y gestión de notificaciones programadas. Permitir funcionalidad inmediata durante desarrollo y MVP.",
            "status": "done",
            "testStrategy": "Verificar que las notificaciones locales funcionan sin configuración externa y cubren todos los casos de uso básicos"
          },
          {
            "id": 6,
            "title": "Crear modelos de datos y persistencia para historial de notificaciones",
            "description": "Implementar PushNotification model en Isar para almacenar historial y estado de notificaciones",
            "dependencies": [
              5
            ],
            "details": "Crear PushNotification model con campos: notificationId, title, body, type, receivedAt, isRead, actionUrl, fastingSessionId. Integrar con DatabaseService existente para persistencia en Isar. Implementar guardado automático cuando se reciben notificaciones. Crear queries para historial y notificaciones no leídas.",
            "status": "done",
            "testStrategy": "Verificar que las notificaciones se guardan correctamente en la base de datos y se pueden consultar"
          },
          {
            "id": 7,
            "title": "Crear providers de Riverpod para gestión de estado de notificaciones",
            "description": "Implementar NotificationProvider y NotificationServiceProvider para manejo reactivo del estado",
            "dependencies": [
              6
            ],
            "details": "Crear NotificationProvider para gestionar estado de notificaciones activas, contador de no leídas, y streams de OneSignal. Implementar NotificationServiceProvider para decidir entre OneSignal y LocalNotificationService según configuración. Integrar con el router para navegación desde deep links.",
            "status": "done",
            "testStrategy": "Verificar que el estado de notificaciones se actualiza reactivamente en la UI y la navegación funciona"
          },
          {
            "id": 1,
            "title": "Configurar SDK de OneSignal en el proyecto Flutter",
            "description": "Instalar y configurar el SDK de OneSignal en el proyecto Flutter con las dependencias necesarias",
            "dependencies": [],
            "details": "Añadir onesignal_flutter ^5.0.0 al pubspec.yaml. Configurar OneSignal app ID en las variables de entorno. Añadir REST API key para comunicación con OneSignal. Inicializar OneSignal en main.dart con la configuración básica. Verificar que la instalación sea correcta con logs de debug.",
            "status": "done",
            "testStrategy": "Verificar que OneSignal se inicializa correctamente sin errores en los logs de debug",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar permisos de notificaciones por plataforma",
            "description": "Establecer permisos necesarios para notificaciones push en iOS y Android",
            "dependencies": [
              1
            ],
            "details": "Para iOS: añadir capabilities de notification y remote-notification en Runner.xcodeproj. Configurar Background Modes para notificaciones remotas. Para Android: añadir permisos INTERNET, VIBRATE y WAKE_LOCK en AndroidManifest.xml. Configurar notification channels para Android 8+. Implementar solicitud de permisos en tiempo de ejecución.",
            "status": "done",
            "testStrategy": "Probar que se solicitan permisos correctamente en ambas plataformas y que las notificaciones llegan",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar templates de notificaciones para ayuno e hidratación",
            "description": "Crear templates predefinidos para diferentes tipos de notificaciones del ayuno y recordatorios",
            "dependencies": [
              2
            ],
            "details": "Crear NotificationService wrapper para OneSignal con métodos específicos. Implementar templates para: inicio de ayuno, hitos de progreso (4h, 8h, 12h, 16h), finalización de ayuno, recordatorios de hidratación, y mensajes de re-engagement. Configurar segmentación de usuarios basada en tipo de plan de ayuno. Personalizar mensajes según el progreso del usuario.",
            "status": "done",
            "testStrategy": "Verificar que cada template se envía correctamente con el contenido apropiado según el contexto del usuario",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar manejo de deep links desde notificaciones",
            "description": "Configurar navegación automática a pantallas específicas cuando el usuario toca una notificación",
            "dependencies": [
              3
            ],
            "details": "Configurar deep linking scheme en iOS (Info.plist) y Android (AndroidManifest.xml). Implementar handler de notificaciones que detecte cuando la app se abre desde una notificación. Crear routing automático a pantallas específicas: dashboard de ayuno, pantalla de hidratación, configuración, etc. Manejar casos cuando la app está cerrada, en background o en foreground. Pasar datos adicionales a través de la notificación.",
            "status": "done",
            "testStrategy": "Probar que las notificaciones abren las pantallas correctas en todos los estados de la app (cerrada, background, foreground)",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implementar sistema de autenticación con Supabase Auth",
        "description": "Crear flujos completos de registro, login y logout con validación de email y manejo de estados de sesión",
        "details": "Crear AuthService con métodos async para signUp, signIn, signOut usando Supabase Auth. Implementar validación email format, password strength (8+ caracteres). Crear Riverpod authStateProvider que exponga User? y isAuthenticated. Manejar estados loading, error, success. Implementar auto-login si sesión válida existe. Crear pantallas LoginScreen y RegisterScreen con formularios responsive.",
        "testStrategy": "Pruebas unitarias para validaciones, pruebas de integración para flows completos, verificar sesión persiste tras reinicio app",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Supabase Auth y crear servicio base de autenticación",
            "description": "Configurar la instancia de Supabase en el proyecto Flutter e implementar la clase AuthService con los métodos básicos de autenticación",
            "dependencies": [],
            "details": "Instalar dependencias supabase_flutter. Configurar SUPABASE_URL y SUPABASE_ANON_KEY en variables de entorno. Crear clase AuthService con SupabaseClient instance. Implementar métodos async signUp(email, password), signIn(email, password), signOut(), getCurrentUser(). Agregar validaciones básicas de email format usando RegExp y password strength (mínimo 8 caracteres). Manejar SupabaseException y retornar Result<User, AuthError> custom types.",
            "status": "done",
            "testStrategy": "Pruebas unitarias para validaciones de email y password. Pruebas de integración para métodos de Auth con mocks de Supabase. Verificar manejo correcto de errores.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar estado global de autenticación con Riverpod",
            "description": "Crear providers de Riverpod para manejar el estado de autenticación y sesión del usuario en toda la aplicación",
            "dependencies": [
              1
            ],
            "details": "Crear authStateProvider usando StateNotifierProvider que exponga AuthState{User? user, bool isLoading, String? error, bool isAuthenticated}. Implementar AuthStateNotifier que utilice AuthService y escuche cambios de sesión via Supabase.auth.onAuthStateChange. Crear computed provider isAuthenticatedProvider que retorne bool. Implementar auto-login verificando sesión existente al iniciar app. Manejar estados de loading durante operaciones async.",
            "status": "done",
            "testStrategy": "Pruebas unitarias para AuthStateNotifier. Probar que isAuthenticated se actualiza correctamente. Verificar auto-login funciona tras reinicio de app.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear pantallas de Login y Registro con formularios validados",
            "description": "Desarrollar las interfaces de usuario para login y registro con validación en tiempo real y manejo de estados",
            "dependencies": [
              2
            ],
            "details": "Crear LoginScreen y RegisterScreen con formularios usando TextFormField y GlobalKey<FormState>. Implementar validación en tiempo real para email y password con visual feedback. Agregar botones con loading states que consumen authStateProvider. Implementar navigation entre pantallas y redirect automático tras login exitoso. Diseño responsive con constraints para diferentes tamaños de pantalla. Agregar error messages user-friendly y loading indicators durante auth operations.",
            "status": "done",
            "testStrategy": "Pruebas de widget para pantallas de login/registro. Verificar validación funciona correctamente. Probar navigation flows y estados de loading/error.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de autenticación con supabase auth."
      },
      {
        "id": 7,
        "title": "Crear modelo FastingSession en Isar",
        "description": "Definir esquema completo para sesiones de ayuno con campos para tracking, estado y sincronización",
        "details": "Crear @collection class FastingSession con campos: Id id (auto-increment), String userId, DateTime startTime, DateTime? endTime, int durationMinutes, bool completed, bool interrupted, String? planType, DateTime createdAt, DateTime updatedAt, int? syncVersion. Agregar métodos helper para calcular elapsed time, progress percentage, isActive. Implementar toJson/fromJson para sync con Supabase.",
        "testStrategy": "Pruebas unitarias para cálculos de tiempo, verificar serialización JSON correcta, probar queries por userId y dateRange",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir esquema y anotaciones de la clase FastingSession",
            "description": "Crear la estructura básica de la clase FastingSession con todas las anotaciones Isar requeridas y campos principales",
            "dependencies": [],
            "details": "Crear archivo fasting_session.dart con @collection class FastingSession. Definir campos: Id id (auto-increment), String userId, DateTime startTime, DateTime? endTime, int durationMinutes, bool completed, bool interrupted, String? planType, DateTime createdAt, DateTime updatedAt, int? syncVersion. Agregar imports necesarios de Isar y anotaciones @Index para userId y timestamp.",
            "status": "done",
            "testStrategy": "Verificar que el esquema compile correctamente y genere código Isar sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar métodos helper para cálculos de tiempo",
            "description": "Agregar métodos de utilidad para calcular tiempo transcurrido, porcentaje de progreso y estado activo de la sesión",
            "dependencies": [
              1
            ],
            "details": "Implementar getters y métodos: Duration get elapsedTime (calcula tiempo desde startTime), double get progressPercentage (elapsed/duration * 100), bool get isActive (startTime != null && endTime == null), bool get isCompleted (completed == true). Manejar casos edge como sesiones interrumpidas y cálculos con endTime null.",
            "status": "done",
            "testStrategy": "Pruebas unitarias para cada método calculando escenarios diversos: sesiones activas, completadas, interrumpidas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar serialización JSON para sincronización con Supabase",
            "description": "Crear métodos toJson y fromJson para permitir sincronización bidireccional con la base de datos Supabase",
            "dependencies": [
              1
            ],
            "details": "Implementar Map<String, dynamic> toJson() convirtiendo todos los campos a formato JSON compatible con Supabase. Crear factory FastingSession.fromJson(Map<String, dynamic> json) manejando conversiones de DateTime y campos nullable. Asegurar compatibilidad con campos syncVersion para control de versiones.",
            "status": "done",
            "testStrategy": "Verificar serialización correcta round-trip (toJson -> fromJson), validar compatibilidad con formato Supabase",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: definición del esquema Isar con anotaciones y campos principales, implementación de métodos helper para cálculos de tiempo y estado, y configuración de serialización JSON para sincronización con Supabase"
      },
      {
        "id": 8,
        "title": "Desarrollar TimerService con lógica de ayuno",
        "description": "Implementar servicio central para gestionar estado del timer, inicio/pausa/finalización de ayunos con persistencia",
        "details": "Crear TimerService como singleton con Stream<FastingState> para reactive updates. Implementar métodos: startFast(planType), pauseFast(), resumeFast(), completeFast(), interruptFast(). Usar Timer.periodic para updates cada segundo. Persistir estado en Isar y background service. Manejar edge cases: cambio de timezone, reinicio de dispositivo. Implementar FastingState enum (idle, fasting, paused, completed).",
        "testStrategy": "Probar precisión de timer, verificar estado persiste tras app kill, validar transiciones de estado correctas",
        "priority": "high",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar FastingState enum y TimerService singleton base",
            "description": "Crear la estructura fundamental del TimerService incluyendo el enum FastingState y la configuración básica del singleton",
            "dependencies": [],
            "details": "Crear FastingState enum con valores (idle, fasting, paused, completed). Implementar TimerService como singleton con Stream<FastingState> para reactive updates. Configurar estructura básica de la clase con propiedades necesarias: currentState, startTime, duration, planType. Establecer constructor privado y getInstance() method para singleton pattern.",
            "status": "done",
            "testStrategy": "Probar que singleton retorna misma instancia, verificar estado inicial es idle, validar stream emite cambios correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar métodos de control del timer y Timer.periodic",
            "description": "Implementar todos los métodos de control del ayuno y el sistema de actualización automática cada segundo",
            "dependencies": [
              1
            ],
            "details": "Implementar métodos: startFast(planType), pauseFast(), resumeFast(), completeFast(), interruptFast(). Crear Timer.periodic que actualiza cada segundo y emite nuevos estados. Manejar lógica de transiciones entre estados válidos. Calcular tiempo transcurrido y restante. Implementar auto-completion cuando timer llega a cero.",
            "status": "done",
            "testStrategy": "Probar precisión del timer con updates cada segundo, verificar transiciones de estado correctas, validar métodos responden apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar persistencia con Isar y manejo de edge cases",
            "description": "Implementar persistencia del estado en Isar y manejar casos especiales como cambios de timezone y reinicios",
            "dependencies": [
              2
            ],
            "details": "Integrar TimerService con Isar para persistir estado del timer y FastingSession. Implementar saveState() y loadState() methods. Manejar edge cases: cambio de timezone (recalcular times), reinicio de dispositivo (restaurar estado desde DB), background service integration. Implementar recovery logic para estados inconsistentes.",
            "status": "done",
            "testStrategy": "Probar estado persiste tras app kill, verificar recovery después de reinicio, validar manejo correcto de timezone changes",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en: implementación del singleton TimerService con Stream para actualizaciones reactivas, desarrollo de lógica de timer con Timer.periodic y control de estados, integración con persistencia Isar y manejo de casos edge como cambios de timezone, y configuración de background service integration"
      },
      {
        "id": 9,
        "title": "Crear pantalla de selección de planes de ayuno",
        "description": "Diseñar UI para elegir entre planes predefinidos (12/12, 14/10, 16/8, 18/6, 24h, 48h) con descripción y nivel de dificultad",
        "details": "Crear PlanSelectionScreen con ListView de FastingPlanCard widgets. Mostrar para cada plan: nombre, duración ayuno/comida, nivel dificultad (principiante/intermedio/avanzado), descripción beneficios, recomendado para (pérdida grasa/autofagia). Implementar selección visual con Material 3 selection states. Crear FastingPlan model con datos predefinidos. Guardar selección en UserProfile.",
        "testStrategy": "Verificar UI responsive en diferentes tamaños pantalla, probar selección persiste, validar accesibilidad con TalkBack/VoiceOver",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo FastingPlan y datos predefinidos",
            "description": "Implementar la estructura de datos para los planes de ayuno con toda la información necesaria para mostrar en la UI",
            "dependencies": [],
            "details": "Crear clase FastingPlan con propiedades: nombre, duración de ayuno, duración de comida, nivel de dificultad (enum), descripción de beneficios, recomendado para (pérdida de grasa/autofagia), icono. Definir lista de planes predefinidos: 12/12, 14/10, 16/8, 18/6, 24h, 48h con sus respectivos datos completos. Incluir validaciones de datos y métodos de serialización JSON.",
            "status": "pending",
            "testStrategy": "Verificar que todos los planes tienen datos completos, probar serialización/deserialización JSON, validar enum values correctos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar widget FastingPlanCard con Material 3",
            "description": "Crear componente reutilizable para mostrar información de cada plan de ayuno con estados de selección visual",
            "dependencies": [
              1
            ],
            "details": "Crear FastingPlanCard widget que muestre nombre del plan, duración ayuno/comida, nivel de dificultad con badge colorido, descripción de beneficios y para qué está recomendado. Implementar estados visuales de Material 3: normal, hover, pressed, selected. Usar Card con elevation y border radius apropiados. Agregar animaciones suaves de transición entre estados (250ms). Soportar temas claro y oscuro.",
            "status": "pending",
            "testStrategy": "Probar estados visuales funcionan correctamente, verificar animaciones fluidas, validar accesibilidad con semantic labels",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar PlanSelectionScreen con selección y persistencia",
            "description": "Crear pantalla completa con lista de planes, manejo de selección y guardado en UserProfile",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear PlanSelectionScreen con ListView de FastingPlanCard widgets. Implementar selección single-choice con estado visual claro. Agregar AppBar con título y botón confirmar. Manejar selección con StatefulWidget o Riverpod provider. Guardar plan seleccionado en UserProfile y persistir en storage local. Implementar navegación de regreso con resultado. Agregar loading states durante guardado.",
            "status": "pending",
            "testStrategy": "Verificar selección funciona correctamente, probar persistencia de datos, validar UI responsive en diferentes tamaños de pantalla",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del modelo FastingPlan con datos predefinidos, desarrollo del widget FastingPlanCard con Material 3 design y estados de selección, e implementación de la pantalla completa con persistencia de selección"
      },
      {
        "id": 10,
        "title": "Desarrollar pantalla principal FastingHomeScreen",
        "description": "Crear UI principal mostrando timer grande, progreso del ayuno, botones de control y estado actual",
        "details": "Crear FastingHomeScreen con timer central (48sp, bold, color dinámico según estado). Mostrar progress ring circular o linear bar. Implementar botones Start/Stop/Pause con estados visuales claros. Mostrar información contextual: tiempo transcurrido/restante, fase actual (ayuno/comida), próximo hito. Usar Riverpod fastingTimerProvider para estado reactivo. Agregar animaciones suaves (250ms transitions).",
        "testStrategy": "Probar UI actualiza en tiempo real, verificar botones responden correctamente, validar animaciones fluidas 60fps",
        "priority": "high",
        "dependencies": [
          "8",
          "9",
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar componente de timer central con diseño visual dinámico",
            "description": "Crear el componente principal del timer que mostrará el tiempo transcurrido/restante con tipografía grande y colores que cambien según el estado del ayuno",
            "dependencies": [],
            "details": "Implementar widget de timer central con texto de 48sp en fuente bold. Aplicar colores dinámicos según estado: verde para ayuno activo, azul para ventana de comida, gris para pausado. Mostrar formato hh:mm:ss. Integrar con fastingTimerProvider de Riverpod para actualizaciones reactivas en tiempo real. Usar AnimatedDefaultTextStyle para transiciones suaves de color.",
            "status": "pending",
            "testStrategy": "Verificar que el timer se actualiza cada segundo, probar cambios de color según estado, validar formato de tiempo correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar indicador de progreso circular y botones de control",
            "description": "Crear el anillo de progreso circular alrededor del timer y implementar los botones de Start/Stop/Pause con estados visuales claros",
            "dependencies": [
              1
            ],
            "details": "Implementar CircularProgressIndicator customizado que muestre progreso del ayuno actual. Crear botones de control con estados visuales distintos: Start (verde), Pause (amarillo), Stop (rojo). Usar IconButton con Material 3 design y elevated button style. Agregar haptic feedback en button presses. Implementar lógica para mostrar/ocultar botones según estado actual.",
            "status": "pending",
            "testStrategy": "Probar que botones responden correctamente, verificar estados visuales apropiados, validar haptic feedback funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar información contextual y animaciones de transición",
            "description": "Añadir información contextual sobre la fase actual del ayuno, próximos hitos y implementar animaciones suaves para todas las transiciones",
            "dependencies": [
              1,
              2
            ],
            "details": "Mostrar información contextual: fase actual (ayuno/ventana de comida), tiempo transcurrido vs restante, próximo hito temporal. Crear widgets informativos con Typography.bodyMedium. Implementar AnimatedSwitcher y AnimatedContainer para transiciones de 250ms. Agregar subtle micro-interactions y state changes animations. Usar Curves.easeInOut para transiciones naturales.",
            "status": "pending",
            "testStrategy": "Verificar animaciones fluidas a 60fps, probar información contextual se actualiza correctamente, validar transiciones suaves entre estados",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: implementación del componente timer central con tipografía dinámica y colores por estado, desarrollo del indicador de progreso circular y botones de control con estados visuales, e integración de información contextual con animaciones de transición suaves"
      },
      {
        "id": 11,
        "title": "Implementar botón de pánico como FloatingActionButton",
        "description": "Crear botón pánico persistente que aparece solo durante ayuno activo para apoyo emocional en momentos de antojos",
        "details": "Crear PanicButton como FloatingActionButton naranja (#ffb366) de 64×64dp con icono corazón o SOS. Mostrar solo cuando fastingState == fasting. Implementar animación pulse sutil (no distractiva). Posicionar en bottom-right con elevation 8dp. Al tap, abrir PanicModal con opciones: frases motivacionales, meditación respiración, opción 'No puedo continuar'. Trackear eventos panic_button_used en analytics.",
        "testStrategy": "Verificar botón solo visible durante ayuno, probar animación no afecta rendimiento, validar analytics tracking",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente PanicButton con FloatingActionButton",
            "description": "Implementar el componente visual del botón de pánico como FloatingActionButton con estilo específico",
            "dependencies": [],
            "details": "Crear widget PanicButton que extienda FloatingActionButton con color naranja (#ffb366), tamaño 64×64dp, icono de corazón o SOS. Posicionar en bottom-right de la pantalla con elevation 8dp. Implementar visibilidad condicional basada en fastingState == fasting usando Consumer/Riverpod.",
            "status": "pending",
            "testStrategy": "Verificar que el botón se muestra solo durante ayuno activo y tiene el estilo visual correcto",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar animación pulse sutil para el botón",
            "description": "Agregar animación de pulso no distractiva al FloatingActionButton para atraer atención sin ser molesto",
            "dependencies": [
              1
            ],
            "details": "Implementar AnimationController con Tween para crear efecto pulse sutil. Usar Transform.scale con values entre 1.0 y 1.1, duración 1.5-2 segundos, repeat infinito. Aplicar CurvedAnimation con Curves.easeInOut para transición suave. Optimizar para no afectar rendimiento usando SingleTickerProviderStateMixin.",
            "status": "pending",
            "testStrategy": "Probar que la animación no afecta el rendimiento y es visualmente apropiada",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar analytics tracking para eventos del botón",
            "description": "Implementar seguimiento de analytics cuando el usuario interactúa con el botón de pánico",
            "dependencies": [
              1
            ],
            "details": "Agregar evento 'panic_button_used' al AnalyticsService existente. Incluir metadata: timestamp, duración actual del ayuno, tipo de ayuno activo. Llamar analytics tracking en onPressed callback del FloatingActionButton. Usar patrón fire-and-forget para no bloquear UI. Considerar batching de eventos si es necesario.",
            "status": "pending",
            "testStrategy": "Verificar que los eventos se registran correctamente en analytics sin afectar la experiencia de usuario",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del componente FloatingActionButton con estilo específico y visibilidad condicional, implementación de animación pulse sutil no intrusiva, e integración de analytics tracking para eventos de uso"
      },
      {
        "id": 12,
        "title": "Crear modal de pánico con contenido motivacional",
        "description": "Desarrollar overlay que se muestra al presionar botón pánico con quotes motivacionales y opciones de apoyo",
        "details": "Crear PanicModal como full-screen overlay con blur background. Mostrar frase motivacional aleatoria de categories: motivation, anti_binge, calm. Incluir botones: 'Meditar 5 min', 'Continuar ayuno', 'No puedo seguir'. Implementar repository MotivationalPhrasesRepository que fetch desde Supabase o cache local. Agregar ilustraciones calm/zen. Usar Material 3 modal design patterns.",
        "testStrategy": "Probar modal aparece rápidamente, verificar frases cargan offline, validar UX no es intrusiva pero efectiva",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar PanicModal con diseño full-screen overlay",
            "description": "Crear el componente PanicModal como full-screen overlay con blur background siguiendo patrones de Material 3 modal design",
            "dependencies": [],
            "details": "Crear PanicModal widget que ocupe toda la pantalla con blur background effect. Implementar diseño responsivo con padding apropiado. Usar Material 3 modal design patterns con elevation y animaciones de entrada/salida. Agregar ilustraciones calm/zen en la parte superior. Configurar dismiss behavior y accessibility features. Asegurar que el modal se muestre correctamente sobre todo el contenido existente.",
            "status": "pending",
            "testStrategy": "Probar que el modal aparece rápidamente al activarse, verificar blur effect funciona correctamente, validar diseño responsivo en diferentes tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar MotivationalPhrasesRepository para gestión de frases",
            "description": "Implementar repositorio que gestione frases motivacionales desde Supabase con cache local para acceso offline",
            "dependencies": [
              1
            ],
            "details": "Crear MotivationalPhrasesRepository con métodos: getRandomPhrase(category), loadPhrasesFromSupabase(), cachePhrasesLocally(). Implementar model MotivationalPhrase con campos: id, text, category (motivation, anti_binge, calm), language. Configurar cache local usando Shared Preferences o Hive para acceso offline. Implementar fallback phrases en caso de no connectivity. Manejar categorización y filtrado de frases según contexto.",
            "status": "pending",
            "testStrategy": "Verificar frases cargan desde Supabase correctamente, probar funcionamiento offline con cache local, validar categorización funciona apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar botones de acción y lógica de respuesta del modal",
            "description": "Crear botones de acción 'Meditar 5 min', 'Continuar ayuno', 'No puedo seguir' con navegación y lógica correspondiente",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar tres botones principales con Material 3 styling: 'Meditar 5 min' (navega a timer meditación), 'Continuar ayuno' (cierra modal y continúa timer), 'No puedo seguir' (pausa/termina sesión con confirmación). Agregar ripple effects y estados hover/pressed. Implementar NavigationService calls para routing apropiado. Manejar estados de loading durante acciones. Integrar analytics tracking para user actions en panic modal.",
            "status": "pending",
            "testStrategy": "Probar navegación de botones funciona correctamente, verificar confirmaciones para acciones destructivas, validar UX no es intrusiva pero efectiva",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: implementación del modal full-screen con blur background y Material 3 design, desarrollo del repositorio de frases motivacionales con cache local y conexión Supabase, y creación de botones de acción con navegación y lógica de respuesta"
      },
      {
        "id": 13,
        "title": "Implementar animación de respiración 4-4-8 con Lottie",
        "description": "Crear pantalla de meditación guiada con animación visual para técnica de respiración 4-4-8 (inhalar-mantener-exhalar)",
        "details": "Instalar lottie ^2.7.0. Crear MeditationScreen con Lottie widget mostrando círculo/pulmones que expande (4s inhale), mantiene (4s hold), contrae (8s exhale). Agregar text overlay con instrucciones 'Inhala', 'Mantén', 'Exhala'. Implementar contador de ciclos completados. Botones: 'Parar meditación', 'Continuar ayuno', 'No puedo seguir'. Asset Lottie <100KB para rendimiento. Colores teal/verde zen.",
        "testStrategy": "Verificar animación 60fps en dispositivos mid-range, probar timing preciso 4-4-8, validar transiciones suaves",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar dependencia Lottie y configurar assets",
            "description": "Agregar la dependencia lottie 2.7.0 al proyecto y preparar los assets de animación necesarios para la respiración",
            "dependencies": [],
            "details": "Ejecutar 'flutter pub add lottie:^2.7.0' para instalar la dependencia. Crear carpeta assets/animations/ y agregar archivo breathing_animation.json con animación de círculo/pulmones que expande y contrae. El asset debe ser menor a 100KB para optimizar rendimiento. Configurar pubspec.yaml para incluir los assets. Usar colores teal/verde zen (#4DB6AC, #66BB6A) en la animación.",
            "status": "pending",
            "testStrategy": "Verificar que la dependencia se instala correctamente y que el asset Lottie se carga sin errores en la aplicación",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear MeditationScreen con widget Lottie y controles de tiempo",
            "description": "Desarrollar la pantalla principal de meditación con la animación Lottie y lógica de timing para el patrón 4-4-8",
            "dependencies": [
              1
            ],
            "details": "Crear MeditationScreen como StatefulWidget. Implementar Lottie.asset() widget para mostrar animación. Desarrollar controlador de timing con tres fases: inhalar (4s), mantener (4s), exhalar (8s). Usar AnimationController para sincronizar timing con animación Lottie. Agregar overlay de texto que muestre 'Inhala', 'Mantén', 'Exhala' según fase actual. Implementar contador de ciclos completados con display visible.",
            "status": "pending",
            "testStrategy": "Probar que la animación se reproduce correctamente con timing preciso de 4-4-8 segundos y que el texto overlay cambia apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar botones de control y navegación",
            "description": "Agregar botones de control para gestionar la sesión de meditación y navegar según las decisiones del usuario",
            "dependencies": [
              2
            ],
            "details": "Implementar tres botones en la parte inferior de la pantalla: 'Parar meditación' (detiene animación y regresa a pantalla anterior), 'Continuar ayuno' (completa meditación y regresa al timer), 'No puedo seguir' (abre modal de soporte o interrumpe ayuno). Usar colores consistentes con el tema zen (teal/verde). Agregar confirmaciones para acciones destructivas. Integrar con el sistema de navegación existente y FastingState management.",
            "status": "pending",
            "testStrategy": "Verificar que todos los botones funcionan correctamente y navegan a las pantallas apropiadas sin errores",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: instalación de Lottie dependency y configuración de assets, creación de MeditationScreen con widget Lottie y controles de timing para patrón 4-4-8, e implementación de botones de control con navegación apropiada"
      },
      {
        "id": 14,
        "title": "Crear biblioteca de frases motivacionales",
        "description": "Desarrollar repository y modelo para gestionar frases motivacionales categorizadas para el botón pánico",
        "details": "Crear MotivationalPhrase model con fields: id, phraseText, category (motivation/anti_binge/calm), language. Implementar MotivationalPhrasesRepository con métodos: getRandomByCategory(), getAllByLanguage(). Seed data con 15+ frases en español cubrir categories. Implementar cache local en Isar para offline access. Sync desde Supabase motivational_phrases table. Manejar fallbacks si no hay conexión.",
        "testStrategy": "Verificar frases random no se repiten consecutivamente, probar funciona offline, validar sync bidireccional",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear modelo MotivationalPhrase y configurar base de datos",
            "description": "Implementar el modelo de datos para frases motivacionales con todos los campos necesarios y configurar la estructura en Isar y Supabase",
            "dependencies": [],
            "details": "Crear MotivationalPhrase model con campos: id (String), phraseText (String), category (enum: motivation/anti_binge/calm), language (String, default 'es'). Definir schema Isar con índices apropiados por category y language. Crear tabla motivational_phrases en Supabase con misma estructura. Implementar serialización/deserialización JSON para sync.",
            "status": "pending",
            "testStrategy": "Verificar modelo se guarda/recupera correctamente en Isar, probar serialización JSON, validar constraints de campos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar MotivationalPhrasesRepository con métodos core",
            "description": "Desarrollar repository con métodos principales para gestionar frases motivacionales incluyendo obtención aleatoria y filtrado por idioma",
            "dependencies": [
              1
            ],
            "details": "Implementar MotivationalPhrasesRepository con métodos: getRandomByCategory(category) que evite repetir última frase, getAllByLanguage(language), addPhrase(), deletePhrase(), syncFromSupabase(). Usar Isar queries optimizadas. Implementar lógica anti-repetición guardando última frase mostrada. Manejar cache local y fallbacks cuando no hay datos.",
            "status": "pending",
            "testStrategy": "Probar getRandomByCategory no repite frases consecutivamente, verificar filtrado por idioma funciona, validar métodos CRUD",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Poblar base de datos y configurar sincronización",
            "description": "Crear seed data con frases motivacionales en español y implementar sincronización automática con Supabase",
            "dependencies": [
              2
            ],
            "details": "Crear seed data con 15+ frases en español distribuidas en categories: 5+ motivation, 5+ anti_binge, 5+ calm. Implementar auto-sync desde Supabase motivational_phrases table al iniciar app. Configurar sync bidireccional cuando usuario agrega frases custom. Implementar fallback a frases hardcoded si no hay conexión ni datos locales. Manejar errores de red gracefully.",
            "status": "pending",
            "testStrategy": "Verificar seed data se carga correctamente, probar funciona offline con frases locales, validar sync bidireccional con Supabase",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del modelo MotivationalPhrase y configuración de base de datos local/remota, implementación del repositorio con métodos core y lógica anti-repetición, y poblado de base de datos con seed data y configuración de sincronización"
      },
      {
        "id": 15,
        "title": "Implementar gestión de sesiones (completar/interrumpir ayuno)",
        "description": "Desarrollar lógica para finalizar ayunos correctamente, guardar métricas y actualizar historial del usuario",
        "details": "Extender TimerService con completeFast() e interruptFast() methods. Al completar: marcar session.completed = true, calcular duration final, save to Isar, trigger metrics recalculation, mostrar congratulations UI, sync to Supabase. Al interrumpir: marcar interrupted = true, save partial session, preguntar razón (opcional), no penalizar métricas severamente. Implementar SessionManager para orchestrate estos flows.",
        "testStrategy": "Verificar sessions se guardan correctamente, probar sync funciona, validar métricas se actualizan apropiadamente",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Extender TimerService con métodos completeFast() e interruptFast()",
            "description": "Implementar los métodos principales en TimerService para gestionar la finalización e interrupción de ayunos con toda la lógica de negocio requerida",
            "dependencies": [],
            "details": "Agregar completeFast() method que marque session.completed = true, calcule duration final y trigger todos los flows de completion. Implementar interruptFast() method que marque session.interrupted = true, guarde partial session y maneje el flow de interrupción. Ambos métodos deben actualizar el estado interno del TimerService y notificar a los listeners apropiados.",
            "status": "done",
            "testStrategy": "Verificar que ambos métodos actualicen correctamente el estado de la sesión, probar que se calculan las duraciones apropiadamente y validar que los listeners son notificados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar persistencia y sincronización de sesiones",
            "description": "Desarrollar la lógica para guardar sesiones completadas/interrumpidas en Isar y sincronizar con Supabase",
            "dependencies": [
              1
            ],
            "details": "Al completar ayuno: guardar session en Isar con completed=true y duration final, trigger recalculation de métricas, sync a Supabase. Al interrumpir: guardar partial session con interrupted=true, opcional reason field, no penalizar métricas severamente. Implementar error handling para sync failures y retry logic apropiado.",
            "status": "done",
            "testStrategy": "Probar que las sesiones se guardan correctamente en Isar, verificar sync a Supabase funciona, validar que métricas se actualizan apropiadamente tras completion",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear SessionManager para orchestrar flows y UI de completion",
            "description": "Desarrollar SessionManager central que coordine los flows de completion/interrupción y mostrar UI apropiada",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar SessionManager que orchestrate calls a TimerService y maneje UI flows. Para completion: mostrar congratulations UI con estadísticas del ayuno completado. Para interrupción: mostrar dialog preguntando razón opcional con opciones predefinidas. Coordinar con navigation para transitions apropiadas y state management.",
            "status": "done",
            "testStrategy": "Verificar que SessionManager coordina correctamente los flows, probar que congratulations UI aparece tras completion exitoso, validar que interruption dialog funciona apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: extensión de TimerService con métodos de finalización y cálculo de métricas, implementación de persistencia y sincronización de sesiones completadas/interrumpidas, y creación de SessionManager para orchestrar flows y UI de completion"
      },
      {
        "id": 16,
        "title": "Crear modelo UserProfile con cálculo de hidratación",
        "description": "Implementar perfil de usuario con peso, altura y cálculo automático de meta diaria de hidratación",
        "details": "Crear @collection UserProfile con fields: String id (auth user id), double weightKg, int? heightCm, int dailyHydrationGoal (computed), DateTime createdAt, DateTime updatedAt. Implementar getter que calcula hydration goal: weightKg * 32 ml. Crear UserProfileRepository con CRUD operations y sync con Supabase user_profiles table. Manejar conversiones unidades si necesario (kg/lbs).",
        "testStrategy": "Verificar cálculo hidratación correcto (ej: 70kg = 2240ml), probar updates se sincronizan, validar datos persisten",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definir esquema UserProfile con campos básicos",
            "description": "Crear la clase UserProfile con decorador @collection de Isar y definir todos los campos necesarios para el perfil de usuario",
            "dependencies": [],
            "details": "Implementar @collection class UserProfile con campos: String id (auth user id), double weightKg, int? heightCm, DateTime createdAt, DateTime updatedAt. Configurar índices apropiados y relaciones con auth user. Definir constraints de validación para peso y altura.",
            "status": "pending",
            "testStrategy": "Verificar que el schema se crea correctamente, probar validaciones de campos, confirmar índices funcionan",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar cálculo automático de meta de hidratación",
            "description": "Agregar getter dailyHydrationGoal que calcule automáticamente la meta diaria basada en el peso del usuario",
            "dependencies": [
              1
            ],
            "details": "Implementar getter int get dailyHydrationGoal que calcule weightKg * 32 ml. Manejar casos edge como peso nulo o inválido. Agregar método helper para convertir entre unidades (kg/lbs) si es necesario. Documentar fórmula utilizada.",
            "status": "pending",
            "testStrategy": "Verificar cálculo correcto (ej: 70kg = 2240ml), probar casos edge con pesos extremos, validar conversiones de unidades",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear UserProfileRepository con operaciones CRUD y sync Supabase",
            "description": "Implementar repositorio completo para manejar operaciones de base de datos local y sincronización con Supabase",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear UserProfileRepository con métodos: create, read, update, delete, getByUserId. Implementar sync bidireccional con tabla user_profiles de Supabase. Manejar conflictos de sincronización y offline storage. Agregar toJson/fromJson para serialización.",
            "status": "pending",
            "testStrategy": "Probar CRUD operations funcionan correctamente, verificar sync con Supabase, validar manejo de conflictos y offline persistence",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: definición del esquema UserProfile con campos básicos y validaciones, implementación de cálculo automático de meta de hidratación basado en peso, y creación del repositorio con operaciones CRUD y sincronización Supabase"
      },
      {
        "id": 17,
        "title": "Desarrollar servicio de hidratación (HydrationService)",
        "description": "Implementar lógica para tracking de ingesta de agua, metas diarias y cálculo de progreso",
        "details": "Crear HydrationService con métodos: logWater(amount), getTodayProgress(), getDailyGoal(), resetDaily(). Implementar HydrationLog model: id, userId, amount, timestamp, glassSize. Calcular progreso como percentage: totalToday / dailyGoal * 100. Manejar timezone changes y reset automático daily a medianoche. Integrar con UserProfile para goal dinámico.",
        "testStrategy": "Probar logging agua actualiza progreso correctamente, verificar reset diario funciona, validar cálculos precisos",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar modelo HydrationLog y esquema de base de datos",
            "description": "Crear el modelo de datos HydrationLog con todos los campos necesarios para el tracking de hidratación",
            "dependencies": [],
            "details": "Definir HydrationLog model con campos: id (String), userId (String), amount (double), timestamp (DateTime), glassSize (int). Configurar esquema en Isar database con indexes apropiados para queries por userId y timestamp. Implementar métodos de serialización/deserialización. Agregar validaciones para amount > 0 y glassSize válido (150-500ml). Configurar relación con UserProfile.",
            "status": "pending",
            "testStrategy": "Verificar modelo se persiste correctamente en Isar, probar queries por userId y fecha, validar constraints de datos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar métodos core del HydrationService",
            "description": "Implementar la lógica principal del servicio de hidratación con todos los métodos requeridos",
            "dependencies": [
              1
            ],
            "details": "Crear HydrationService con métodos: logWater(amount, glassSize) que persiste nuevo HydrationLog, getTodayProgress() que suma amount del día actual, getDailyGoal() que obtiene meta desde UserProfile, resetDaily() que limpia logs antiguos. Implementar cálculo de progreso como percentage: totalToday / dailyGoal * 100. Manejar timezone correctamente usando DateTime.now() local.",
            "status": "pending",
            "testStrategy": "Probar logWater actualiza progreso, verificar getTodayProgress suma correctamente, validar cálculo de percentage preciso",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar reset automático diario y integración con UserProfile",
            "description": "Configurar el sistema de reset automático nocturno y conectar con el perfil de usuario para metas dinámicas",
            "dependencies": [
              2
            ],
            "details": "Implementar WorkManager job para reset diario a medianoche (00:00 local time). Crear listener para timezone changes que recalcula next reset time. Integrar con UserProfile para obtener dailyGoal dinámico basado en peso/actividad. Implementar background task que limpia logs antiguos (>30 días) para optimizar storage. Agregar notification opcional para recordatorio de hidratación.",
            "status": "pending",
            "testStrategy": "Verificar reset automático funciona a medianoche, probar timezone changes no rompen reset, validar integración con UserProfile actualiza metas",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: implementación del modelo HydrationLog y esquema de base de datos, desarrollo de métodos core del servicio de hidratación con cálculos de progreso, e implementación de reset automático diario y integración con UserProfile"
      },
      {
        "id": 18,
        "title": "Crear WaterButton widget para logging rápido",
        "description": "Desarrollar botón flotante para registrar ingesta de agua con un tap, mostrando progreso visual",
        "details": "Crear WaterButton como FloatingActionButton 56×56dp en bottom-left corner. Color azul/teal. Al tap: log glass default (250ml), mostrar ripple animation + haptic feedback, update progress instantáneamente. Implementar debouncing para evitar double-taps. Mostrar badge con progreso percentage. Long-press para ajustar glass size. Considerar accessibility labels para screen readers.",
        "testStrategy": "Verificar no hay double-logging, probar haptic feedback funciona, validar accesibilidad con VoiceOver/TalkBack",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente WaterButton base con FloatingActionButton",
            "description": "Implementar el widget base WaterButton como FloatingActionButton con diseño y posicionamiento específico",
            "dependencies": [],
            "details": "Crear archivo water_button.dart con StatefulWidget WaterButton. Implementar FloatingActionButton con tamaño 56×56dp, color azul/teal, posicionado en bottom-left corner. Agregar icono de gota de agua. Configurar shape circular y elevation apropiada. Implementar onPressed callback básico para navegación o logging.",
            "status": "pending",
            "testStrategy": "Verificar tamaño correcto del botón, posicionamiento bottom-left, color azul/teal aplicado correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar funcionalidad de logging y feedback visual",
            "description": "Agregar lógica de logging de agua con animaciones, haptic feedback y debouncing",
            "dependencies": [
              1
            ],
            "details": "Integrar con HydrationService para logWater(250ml) al tap. Implementar ripple animation con InkWell/Material. Agregar HapticFeedback.lightImpact() al tap. Implementar debouncing con Timer para evitar double-taps (300ms delay). Mostrar feedback visual temporal como SnackBar o toast indicando cantidad logged.",
            "status": "pending",
            "testStrategy": "Probar no hay double-logging con taps rápidos, verificar haptic feedback funciona en dispositivo, validar ripple animation visible",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar badge de progreso y long-press para ajustar cantidad",
            "description": "Implementar badge visual con porcentaje de progreso y funcionalidad long-press para configurar tamaño de vaso",
            "dependencies": [
              2
            ],
            "details": "Crear Badge widget overlay mostrando percentage de progreso diario. Posicionar badge en top-right del FAB. Implementar GestureDetector con onLongPress para mostrar dialog de glass size selection (150ml, 250ml, 500ml). Agregar accessibility labels con Semantics widget para screen readers. Update badge automáticamente cuando progress cambia via Stream/StateNotifier.",
            "status": "pending",
            "testStrategy": "Verificar badge muestra porcentaje correcto, probar long-press abre dialog configuración, validar accesibilidad con VoiceOver/TalkBack",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del componente FloatingActionButton base con diseño específico, implementación de funcionalidad de logging con feedback visual y háptico, y agregado de badge de progreso con long-press para configuración"
      },
      {
        "id": 19,
        "title": "Implementar indicador de progreso de hidratación",
        "description": "Crear widget visual que muestre progreso diario de hidratación como barra o círculo con meta dinámica",
        "details": "Crear HydrationProgressIndicator widget como linear progress bar o circular indicator. Mostrar: current intake / daily goal con colors: azul para progreso, verde cuando completado (≥100%). Agregar text overlay con ml consumed y ml remaining. Actualizar en tiempo real via Riverpod hydrationProvider. Implementar animaciones smooth para changes. Considerar diferentes visual styles según contexto (dashboard vs home).",
        "testStrategy": "Verificar progreso actualiza instantáneamente tras log, probar animaciones fluidas, validar cálculos visuales correctos",
        "priority": "low",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear widget HydrationProgressIndicator básico",
            "description": "Desarrollar el componente base del indicador de progreso de hidratación con estructura inicial y estilos",
            "dependencies": [],
            "details": "Crear StatelessWidget HydrationProgressIndicator que reciba currentIntake y dailyGoal como parámetros. Implementar LinearProgressIndicator con BorderRadius personalizado. Definir colores: azul (#2196F3) para progreso normal, verde (#4CAF50) cuando ≥100%. Configurar height de 12dp y width responsivo. Agregar Container wrapper con padding y margin apropiados para diferentes contextos (dashboard vs home).",
            "status": "pending",
            "testStrategy": "Verificar widget se renderiza correctamente con diferentes valores de progreso, probar colores cambian según porcentaje",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Agregar text overlay y cálculos visuales",
            "description": "Implementar superposición de texto mostrando ml consumidos y restantes con formateo apropiado",
            "dependencies": [
              1
            ],
            "details": "Agregar Stack widget con Positioned text overlay en el centro del progress bar. Mostrar formato '{currentMl}ml / {goalMl}ml' o '{remainingMl}ml restantes' según preferencia. Implementar helper methods: calculatePercentage(), formatMlText(), getRemainingMl(). Usar TextStyle con fontSize 12sp, fontWeight medium, color blanco con shadow para legibilidad. Responsive text que se ajuste al ancho disponible.",
            "status": "pending",
            "testStrategy": "Probar cálculos matemáticos son correctos, verificar texto legible en diferentes tamaños de pantalla",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar Riverpod y animaciones en tiempo real",
            "description": "Conectar el indicador con hydrationProvider para actualizaciones en tiempo real y agregar animaciones fluidas",
            "dependencies": [
              2
            ],
            "details": "Convertir a ConsumerWidget y escuchar hydrationProvider.currentDailyIntake y dailyGoal. Implementar AnimatedContainer con Duration(milliseconds: 500) y Curves.easeInOut para smooth transitions. Agregar TweenAnimationBuilder para animar cambios de valor progresivamente. Configurar AnimationController para pulse effect cuando se alcanza 100%. Implementar didUpdateWidget para detectar cambios y triggear animaciones apropiadas.",
            "status": "pending",
            "testStrategy": "Verificar actualizaciones en tiempo real funcionan instantáneamente, probar animaciones son fluidas sin lag",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del widget base del indicador de progreso con styling apropiado, implementación de text overlay y cálculos visuales de progreso, e integración con Riverpod para actualizaciones en tiempo real con animaciones"
      },
      {
        "id": 20,
        "title": "Desarrollar pantalla de onboarding con flujo de 6 pasos",
        "description": "Crear experiencia de primera vez con splash, introducción, registro, cuestionario, paywall y recomendación detox",
        "details": "Crear OnboardingCoordinator con PageView de 6 screens: SplashScreen (logo + loading), IntroScreen (beneficios app), RegisterScreen (email/password), QuestionnaireScreen (peso, altura, experiencia), PaywallScreen (Superwall), DetoxRecommendationScreen (48h plan opcional). Implementar navigation entre steps con progress indicator. Guardar answers en UserProfile. Usar go_router para deep linking. Permitir skip en algunos steps.",
        "testStrategy": "Probar flujo completo funciona, verificar datos se guardan correctamente, validar navigation y back handling",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del OnboardingCoordinator y navegación",
            "description": "Implementar el coordinador principal del onboarding con PageView y sistema de navegación entre las 6 pantallas",
            "dependencies": [],
            "details": "Crear OnboardingCoordinator que maneje PageViewController con 6 screens. Implementar navegación forward/backward con botones Next/Previous. Agregar progress indicator (6 dots o barra de progreso). Configurar go_router para deep linking a pasos específicos. Implementar lógica para skip opcional en ciertos steps. Manejar state management con Riverpod para current step y user progress.",
            "status": "done",
            "testStrategy": "Probar navegación entre steps funciona correctamente, verificar progress indicator actualiza, validar deep linking y skip functionality",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar las 6 pantallas del flujo de onboarding",
            "description": "Crear todas las pantallas individuales: Splash, Intro, Register, Questionnaire, Paywall y DetoxRecommendation",
            "dependencies": [
              1
            ],
            "details": "Implementar SplashScreen con logo animado y loading indicator. Crear IntroScreen mostrando beneficios de la app con ilustraciones. Desarrollar RegisterScreen con formulario email/password y validación. Construir QuestionnaireScreen para capturar peso, altura y experiencia previa. Integrar PaywallScreen con Superwall SDK para suscripciones. Diseñar DetoxRecommendationScreen con plan detox de 48h opcional.",
            "status": "done",
            "testStrategy": "Probar cada pantalla renderiza correctamente, verificar formularios validan datos, validar integración Superwall funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar persistencia de datos y finalización del onboarding",
            "description": "Guardar respuestas del usuario en UserProfile y completar el flujo de onboarding",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar guardado de registration data (email/password) en authentication service. Persistir questionnaire answers (peso, altura, experiencia) en UserProfile usando Isar database. Guardar paywall decisions y subscription status. Implementar completion callback que marque onboarding como terminado y navigate a main app. Manejar error states y retry logic para failed saves.",
            "status": "done",
            "testStrategy": "Verificar datos se guardan correctamente en UserProfile, probar completion flow lleva a main app, validar error handling para failed saves",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de la estructura de navegación OnboardingCoordinator con PageView y progress indicator, desarrollo de las 6 pantallas individuales con sus funcionalidades específicas, e implementación de persistencia de datos y finalización del flujo"
      },
      {
        "id": 21,
        "title": "Implementar plan de detox de 48 horas (opcional)",
        "description": "Crear pantalla y lógica para protocolo detox carnívoro pre-ayuno para reducir antojos iniciales",
        "details": "Crear DetoxScreen con countdown timer 48h separado del main timer. Mostrar lista allowed foods: carne, huevos, pescado, caldo de hueso, sal, agua. Implementar daily check-ins (morning/evening) para log adherence. Crear DetoxService paralelo a TimerService. Al completar: unlock fasting plans con congratulations screen. Permitir skip con warning message. Trackear completion rate para analytics.",
        "testStrategy": "Verificar timer detox independiente del main timer, probar check-ins funcionan, validar completion unlock plans",
        "priority": "low",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear DetoxScreen con countdown timer de 48 horas",
            "description": "Desarrollar la pantalla principal del plan de detox con un temporizador de 48 horas independiente del timer principal de ayuno",
            "dependencies": [],
            "details": "Crear DetoxScreen widget con countdown timer específico para 48 horas. Implementar DetoxTimer separado del TimerService principal. Mostrar tiempo restante en formato HH:MM:SS con diseño visual atractivo. Incluir botón para pausar/reanudar detox y opción skip con mensaje de advertencia. Configurar navegación desde plan selection hacia DetoxScreen.",
            "status": "pending",
            "testStrategy": "Verificar timer detox funciona independientemente del timer principal, probar pausa/reanudación, validar precisión del countdown",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lista de alimentos permitidos y check-ins diarios",
            "description": "Mostrar lista de alimentos permitidos durante el detox y sistema de seguimiento diario con check-ins matutinos y vespertinos",
            "dependencies": [
              1
            ],
            "details": "Crear sección de alimentos permitidos: carne, huevos, pescado, caldo de hueso, sal, agua con iconos visuales. Implementar daily check-ins con formularios simples para morning/evening adherence logging. Crear DetoxCheckIn widget con preguntas básicas sobre adherencia y estado anímico. Almacenar datos en Isar para tracking posterior.",
            "status": "pending",
            "testStrategy": "Probar check-ins se registran correctamente, verificar lista alimentos es clara y accesible, validar persistencia de datos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear DetoxService y pantalla de finalización con unlock de planes",
            "description": "Desarrollar servicio de gestión del detox y pantalla de congratulaciones que desbloquea los planes de ayuno",
            "dependencies": [
              2
            ],
            "details": "Implementar DetoxService paralelo a TimerService para gestionar estado del detox. Al completar 48h: mostrar congratulations screen, unlock fasting plans con animación, trackear completion rate en analytics. Crear DetoxCompletionScreen con celebración visual y botón para continuar a fasting plans. Integrar analytics para medir adherencia y tasas de completion.",
            "status": "pending",
            "testStrategy": "Verificar completion desbloquea correctamente los planes, probar analytics tracking funciona, validar flujo completo detox-to-fasting",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de DetoxScreen con countdown timer independiente de 48 horas, implementación de lista de alimentos permitidos y sistema de check-ins diarios, y desarrollo de DetoxService con pantalla de finalización y unlocking de planes"
      },
      {
        "id": 22,
        "title": "Crear MetricsService para cálculo de estadísticas",
        "description": "Implementar servicio que calcule streak, horas totales, tasa de completación y análisis de patrones del usuario",
        "details": "Crear MetricsService con métodos: calculateStreak(), getTotalHours(), getCompletionRate(), getLongestFast(), getPatterns(). Streak = días consecutivos con ayunos completados. Completion rate = completed sessions / total sessions. Patterns = análisis best days/times para start fasts. Usar Isar queries optimizadas con indices. Cache calculations en user_metrics table para performance.",
        "testStrategy": "Verificar cálculos matemáticos correctos, probar performance con large datasets, validar cache updates apropiadamente",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del MetricsService con métodos principales",
            "description": "Implementar la clase MetricsService con todos los métodos principales definidos y su estructura básica",
            "dependencies": [],
            "details": "Crear archivo metrics_service.dart en lib/services/. Definir clase MetricsService con métodos calculateStreak(), getTotalHours(), getCompletionRate(), getLongestFast(), getPatterns(). Implementar constructor que reciba dependencias necesarias como FastingRepository e Isar database. Crear interfaces/tipos para responses de cada método. Establecer documentación básica para cada método explicando qué calculan y qué retornan.",
            "status": "pending",
            "testStrategy": "Crear unit tests básicos verificando que métodos existen y retornan tipos correctos. Probar instanciación del service sin errores.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de cálculo para streak y métricas temporales",
            "description": "Desarrollar algoritmos de cálculo para streak de días consecutivos, horas totales y ayuno más largo",
            "dependencies": [
              1
            ],
            "details": "Implementar calculateStreak() que consulte ayunos completados ordenados por fecha y calcule días consecutivos actuales. Implementar getTotalHours() sumando duración de todas las sesiones completadas. Implementar getLongestFast() encontrando sesión con mayor duración. Usar Isar queries optimizadas con filtros por fechas y estados. Manejar edge cases como ayunos que cruzan medianoche y diferentes zonas horarias.",
            "status": "pending",
            "testStrategy": "Probar cálculos con datasets conocidos y verificar resultados matemáticos. Testear edge cases como primer ayuno, ayunos interrumpidos, cambios de fecha.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar análisis de patrones y sistema de cache",
            "description": "Desarrollar cálculo de tasa de completación, análisis de patrones de usuario y sistema de cache para performance",
            "dependencies": [
              2
            ],
            "details": "Implementar getCompletionRate() calculando completed sessions / total sessions con filtros temporales. Implementar getPatterns() analizando mejores días de semana y horas para iniciar ayunos basado en historical data. Crear tabla user_metrics en Isar para cache de cálculos pesados con timestamps. Implementar invalidación de cache cuando se agregan nuevos datos. Optimizar queries con índices apropiados en fechas y user_id.",
            "status": "pending",
            "testStrategy": "Verificar cálculos de completion rate con diferentes scenarios. Probar performance con datasets grandes (1000+ registros). Validar que cache se actualiza correctamente tras nuevos ayunos.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de la estructura base del MetricsService con métodos principales, implementación de algoritmos de cálculo para streak y métricas temporales, y desarrollo de análisis de patrones con sistema de cache para performance"
      },
      {
        "id": 23,
        "title": "Desarrollar MetricsDashboardScreen con widgets visuales",
        "description": "Crear pantalla principal de métricas mostrando streak actual, total de horas ayunadas y tasa de éxito",
        "details": "Crear MetricsDashboardScreen con cards para: current streak (con fire icon), total hours fasted, completion rate (percentage), longest fast. Implementar MetricCard widget reusable con title, value, icon, trend indicator. Usar Material 3 card design con elevation y colors apropiados. Agregar subtle animations para value changes. Considerar charts library para future enhancements.",
        "testStrategy": "Verificar métricas se actualizan en tiempo real, probar UI responsive en diferentes screen sizes, validar accesibilidad",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente MetricCard reutilizable con Material 3",
            "description": "Desarrollar widget reutilizable MetricCard que mostrará métricas individuales con diseño Material 3",
            "dependencies": [],
            "details": "Implementar MetricCard widget con propiedades: title (String), value (String), icon (IconData), trend (opcional TrendIndicator). Usar Material 3 Card con elevation apropiada, esquinas redondeadas y colores del theme. Agregar soporte para iconos con color dinámico. Implementar TrendIndicator enum (up, down, stable) con íconos y colores correspondientes. Hacer responsive para diferentes screen sizes.",
            "status": "pending",
            "testStrategy": "Probar renderizado correcto en diferentes sizes, verificar Material 3 styling, validar accesibilidad y color contrast",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de cálculo de métricas en tiempo real",
            "description": "Desarrollar providers y servicios para calcular métricas de ayuno dinámicamente",
            "dependencies": [
              1
            ],
            "details": "Crear MetricsCalculatorService con métodos: getCurrentStreak(), getTotalHoursFasted(), getCompletionRate(), getLongestFast(). Implementar Riverpod providers para estado reactivo de métricas. Calcular streak actual basado en ayunos consecutivos completados. Sumar total de horas de todas las sesiones completadas. Calcular completion rate como porcentaje de ayunos completados vs iniciados. Integrar con FastingSessionRepository para datos actualizados.",
            "status": "pending",
            "testStrategy": "Verificar cálculos matemáticos correctos, probar actualización reactiva con Riverpod, validar rendimiento con datasets grandes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear MetricsDashboardScreen con layout y animaciones",
            "description": "Ensamblar pantalla principal de métricas usando MetricCards con animaciones suaves",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear MetricsDashboardScreen con AppBar y body en GridView o Column layout. Instanciar 4 MetricCards: Current Streak (🔥 icon), Total Hours Fasted, Completion Rate (%), Longest Fast. Conectar con metrics providers para datos reactivos. Implementar AnimatedBuilder para transiciones suaves (250ms) cuando cambian valores. Agregar pull-to-refresh functionality. Usar Theme.colorScheme para colores consistentes. Hacer responsive con breakpoints para tablets.",
            "status": "pending",
            "testStrategy": "Probar layout responsive en diferentes devices, verificar animaciones fluidas 60fps, validar pull-to-refresh funciona correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación del componente MetricCard reutilizable con Material 3 design, implementación de lógica de cálculo de métricas en tiempo real, y desarrollo de la pantalla principal con layout y animaciones"
      },
      {
        "id": 24,
        "title": "Implementar calendario heatmap para historial visual",
        "description": "Crear vista de calendario que muestre días con ayunos completados, interrumpidos o sin actividad",
        "details": "Crear CalendarHeatmapWidget usando table_calendar ^3.0.9 o custom implementation. Color coding: verde para completed fasts, naranja para interrupted, gris para no sessions. Implementar tap en day para mostrar session details en modal. Agregar legend explicando colors. Navigation entre meses. Load data efficiently para date ranges. Considerar different intensities basado en duration/success.",
        "testStrategy": "Verificar colores reflejan datos correctamente, probar navigation meses funciona, validar performance con year data",
        "priority": "low",
        "dependencies": [
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar estructura básica del CalendarHeatmapWidget",
            "description": "Crear el widget base del calendario heatmap con navegación entre meses y estructura de datos para los ayunos",
            "dependencies": [],
            "details": "Crear CalendarHeatmapWidget usando table_calendar ^3.0.9 o implementación custom. Configurar navigation entre meses con botones prev/next. Definir estructura de datos para mapear dates a session states. Implementar básico calendar layout sin color coding aún. Configurar calendar configuration con firstDay, lastDay, y calendarFormat apropiados.",
            "status": "pending",
            "testStrategy": "Verificar navegación entre meses funciona correctamente, probar que calendario se renderiza sin errores, validar estructura básica",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de color coding para estados de ayuno",
            "description": "Desarrollar la lógica de colores para mostrar visualmente los diferentes estados de ayuno en cada día del calendario",
            "dependencies": [
              1
            ],
            "details": "Implementar color coding system: verde para completed fasts, naranja para interrupted, gris para no sessions. Crear helper methods para determinar color basado en session data. Considerar diferentes intensities basado en duration/success rate. Implementar efficient data loading para date ranges para evitar performance issues. Crear CalendarDay widget customizado para mostrar colors apropiados.",
            "status": "pending",
            "testStrategy": "Verificar colores reflejan datos de ayuno correctamente, probar performance con datos de un año completo, validar intensidades visuales",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar interactividad y leyenda explicativa",
            "description": "Implementar funcionalidad de tap en días del calendario para mostrar detalles y agregar leyenda explicativa de colores",
            "dependencies": [
              2
            ],
            "details": "Implementar tap en day para mostrar session details en modal popup con información completa del ayuno. Crear leyenda explicando color meanings (verde=completado, naranja=interrumpido, gris=sin actividad). Diseñar SessionDetailsModal con duration, start/end times, notes si available. Posicionar leyenda en bottom o top del calendario. Implementar animaciones smooth para modal transitions.",
            "status": "pending",
            "testStrategy": "Probar que tap en días abre modal con información correcta, verificar leyenda es clara y visible, validar animaciones fluidas",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: implementación de la estructura básica del CalendarHeatmapWidget con navegación, desarrollo del sistema de color coding para estados de ayuno, y agregado de interactividad con modales de detalles"
      },
      {
        "id": 25,
        "title": "Crear modelo ContentItem para biblioteca de aprendizaje",
        "description": "Implementar esquema para artículos, videos y estudios educativos sobre ayuno intermitente",
        "details": "Crear @collection ContentItem con fields: String id, String title, ContentType type (article/video/study), Category category (basics/science/tips/success_stories), String contentUrl, String? thumbnailUrl, String description, int? durationMinutes, bool isPremium, DateTime createdAt. Implementar enums para type y category. Agregar métodos helper para isVideo, isArticle. Sync con Supabase learning_content table.",
        "testStrategy": "Verificar schema correctamente definido, probar serialization para sync, validar queries por category y type",
        "priority": "medium",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear enums ContentType y Category para clasificación",
            "description": "Implementar los enums necesarios para clasificar el contenido educativo por tipo y categoría",
            "dependencies": [],
            "details": "Crear enum ContentType con valores article, video, study. Crear enum Category con valores basics, science, tips, success_stories. Asegurar que ambos enums sean serializables para JSON y compatibles con Isar database. Documentar cada valor del enum con comentarios explicativos.",
            "status": "pending",
            "testStrategy": "Verificar que todos los valores de enum se serialicen correctamente a JSON y se puedan deserializar sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar clase ContentItem con decoradores Isar",
            "description": "Crear la clase principal ContentItem con todos los campos requeridos y anotaciones de Isar",
            "dependencies": [
              1
            ],
            "details": "Crear @collection class ContentItem con campos: String id, String title, ContentType type, Category category, String contentUrl, String? thumbnailUrl, String description, int? durationMinutes, bool isPremium, DateTime createdAt. Agregar métodos helper isVideo() e isArticle(). Implementar toJson() y fromJson() para sincronización con Supabase.",
            "status": "pending",
            "testStrategy": "Probar serialización/deserialización JSON, verificar que métodos helper devuelvan valores correctos, validar que campos opcionales manejen null apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar sincronización con tabla learning_content de Supabase",
            "description": "Establecer la conexión y sincronización bidireccional entre ContentItem local y la tabla learning_content remota",
            "dependencies": [
              2
            ],
            "details": "Crear ContentItemRepository con métodos sync, fetchFromSupabase, uploadToSupabase. Implementar mapping entre campos locales de Isar y columnas de Supabase. Manejar conflictos de sincronización y estrategia de merge. Configurar listeners para cambios remotos y locales.",
            "status": "pending",
            "testStrategy": "Verificar que datos se sincronicen correctamente en ambas direcciones, probar manejo de errores de red, validar que conflictos se resuelvan apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de enums y estructura de clasificación de contenido, implementación de la clase ContentItem con anotaciones Isar, y configuración de sincronización bidireccional con Supabase"
      },
      {
        "id": 26,
        "title": "Desarrollar ContentService para gestión de contenido educativo",
        "description": "Implementar servicio para fetching, caching y gestión de favoritos para contenido de aprendizaje",
        "details": "Crear ContentService con métodos: fetchContent(), getByCategory(), getFavorites(), toggleFavorite(), cacheForOffline(). Implementar smart caching: articles cache full content for offline, videos cache metadata only. Manejar favorites como separate Isar collection o field en ContentItem. Sync favorites con Supabase. Implementar search functionality para find content.",
        "testStrategy": "Probar caching funciona offline, verificar favorites sync entre devices, validar search performance",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar estructura base del ContentService",
            "description": "Crear la clase ContentService con métodos principales y configuración inicial para gestión de contenido educativo",
            "dependencies": [],
            "details": "Crear archivo content_service.dart con clase ContentService. Implementar métodos base: fetchContent(), getByCategory(), getFavorites(), toggleFavorite(), cacheForOffline(). Configurar dependency injection con Riverpod. Definir interfaces y tipos de datos para ContentItem. Implementar error handling básico y logging.",
            "status": "pending",
            "testStrategy": "Crear unit tests para cada método público del servicio, verificar dependency injection funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de caching inteligente",
            "description": "Desarrollar lógica de caching diferenciado para artículos completos y metadata de videos usando Isar",
            "dependencies": [
              1
            ],
            "details": "Implementar smart caching: artículos guardan contenido completo para lectura offline, videos solo metadata (título, duración, thumbnail). Usar Isar para persistencia local. Crear ContentCache model con campos: id, type, fullContent, metadata, timestamp, expirationDate. Implementar cleanup automático de cache expirado. Manejar límites de storage.",
            "status": "pending",
            "testStrategy": "Probar caching funciona offline, verificar diferenciación entre tipos de contenido, validar cleanup automático",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar gestión de favoritos y funcionalidad de búsqueda",
            "description": "Desarrollar sistema de favoritos con sincronización Supabase y funcionalidad de búsqueda de contenido",
            "dependencies": [
              2
            ],
            "details": "Crear FavoriteContent collection en Isar o field en ContentItem. Implementar toggleFavorite() con sync bidireccional a Supabase. Desarrollar search functionality con filtros por categoría, tipo, favoritos. Implementar indexing para búsqueda rápida. Manejar offline/online state para favorites sync. Agregar debounce para search queries.",
            "status": "pending",
            "testStrategy": "Probar favorites sync entre devices, verificar search performance con datasets grandes, validar funcionamiento offline",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: implementación de la estructura base del ContentService con métodos principales, desarrollo de sistema de caching inteligente diferenciado por tipo de contenido, e implementación de gestión de favoritos con funcionalidad de búsqueda"
      },
      {
        "id": 27,
        "title": "Crear LearningHomeScreen para exploración de contenido",
        "description": "Desarrollar pantalla principal de aprendizaje con navegación por categorías y contenido featured",
        "details": "Crear LearningHomeScreen con TabBar para categories: Básicos, Ciencia, Tips, Historias Éxito. Implementar ContentListView con ContentCard widgets mostrando thumbnail, title, duration, premium badge. Agregar search bar en app bar. Featured content section en top. Pull-to-refresh para update content. Manejar empty states y loading states elegantemente.",
        "testStrategy": "Verificar navigation entre tabs funciona, probar pull-to-refresh, validar empty states y loading states",
        "priority": "medium",
        "dependencies": [
          "26"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de LearningHomeScreen con TabBar",
            "description": "Implementar la pantalla principal de aprendizaje con navegación por pestañas para las categorías: Básicos, Ciencia, Tips, Historias de Éxito",
            "dependencies": [],
            "details": "Crear LearningHomeScreen como StatefulWidget. Implementar TabBar con 4 tabs: Básicos, Ciencia, Tips, Historias Éxito. Configurar TabController y TabBarView. Agregar AppBar con título 'Aprendizaje' y integrar search bar. Establecer estructura base del layout con TabBar en la parte superior y contenido dinámico en TabBarView.",
            "status": "pending",
            "testStrategy": "Verificar que la navegación entre tabs funciona correctamente y que el search bar se muestra en el AppBar",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar ContentListView y ContentCard widgets",
            "description": "Desarrollar componentes reutilizables para mostrar listas de contenido con cards que incluyan thumbnail, título, duración y badge premium",
            "dependencies": [
              1
            ],
            "details": "Crear ContentCard widget que muestre: thumbnail (NetworkImage con placeholder), título del contenido, duración formateada, premium badge condicional. Implementar ContentListView que use ListView.builder para renderizar ContentCards. Agregar padding y spacing apropiados. Manejar tap gestures en cards para navegación. Optimizar performance con const constructors donde sea posible.",
            "status": "pending",
            "testStrategy": "Probar que las cards se renderizan correctamente con todos los elementos visuales y que responden a tap gestures",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Agregar featured content section y estados de loading/empty",
            "description": "Implementar sección de contenido destacado en la parte superior y manejar estados vacíos y de carga con pull-to-refresh",
            "dependencies": [
              2
            ],
            "details": "Crear FeaturedContentSection como widget separado que muestre contenido destacado en un carousel horizontal. Implementar RefreshIndicator wrapper para pull-to-refresh functionality. Crear EmptyStateWidget para cuando no hay contenido disponible. Implementar LoadingStateWidget con shimmer effects durante carga. Agregar logic para alternar entre estados según data availability.",
            "status": "pending",
            "testStrategy": "Verificar que pull-to-refresh actualiza el contenido, validar que empty states y loading states se muestran apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de la estructura base con TabBar para categorías, implementación de ContentListView y ContentCard widgets reutilizables, y agregado de featured content section con estados de loading/empty"
      },
      {
        "id": 28,
        "title": "Integrar youtube_player_flutter para reproducción de videos",
        "description": "Implementar reproductor de video embebido para contenido educativo de YouTube con controles nativos",
        "details": "Instalar youtube_player_flutter ^8.0.0. Crear VideoPlayerScreen que extraiga video ID desde URL y muestre YoutubePlayer widget. Implementar fullscreen mode, autoplay settings, quality selection. Manejar estados: loading, playing, paused, error. Fallback a external browser si embedding fails. Considerar Picture-in-Picture para premium users. Trackear video completion para analytics.",
        "testStrategy": "Probar playback en iOS y Android, verificar fullscreen funciona, validar external fallback cuando needed",
        "priority": "low",
        "dependencies": [
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar y configurar youtube_player_flutter SDK",
            "description": "Instalar el paquete youtube_player_flutter v8.0.0 y configurar los permisos necesarios para reproducción de video",
            "dependencies": [],
            "details": "Agregar youtube_player_flutter: ^8.0.0 al pubspec.yaml. Configurar permisos de internet en Android manifest y iOS Info.plist. Importar el paquete en los archivos necesarios. Verificar compatibilidad con la versión actual de Flutter del proyecto.",
            "status": "pending",
            "testStrategy": "Verificar que el paquete se instala correctamente sin conflictos de dependencias y que los permisos están configurados apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear VideoPlayerScreen con extracción de video ID",
            "description": "Implementar pantalla de reproductor que extraiga el ID del video desde URL de YouTube y renderice el widget YoutubePlayer",
            "dependencies": [
              1
            ],
            "details": "Crear VideoPlayerScreen widget que reciba URL de YouTube como parámetro. Implementar función para extraer video ID usando regex o parsing de URL. Configurar YoutubePlayer widget con video ID extraído. Implementar UI básica con controles de reproducción. Manejar casos edge como URLs inválidas o formatos no soportados.",
            "status": "pending",
            "testStrategy": "Probar extracción de video ID con diferentes formatos de URL de YouTube y verificar que el reproductor carga correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar controles avanzados y manejo de estados",
            "description": "Agregar funcionalidades de pantalla completa, autoplay, calidad y manejo completo de estados del reproductor",
            "dependencies": [
              2
            ],
            "details": "Implementar modo fullscreen con rotación automática. Configurar opciones de autoplay y selección de calidad. Manejar estados: loading, playing, paused, error con UI apropiada. Implementar fallback a navegador externo cuando embedding falla. Considerar Picture-in-Picture para usuarios premium. Agregar tracking de completado de video para analytics.",
            "status": "pending",
            "testStrategy": "Verificar que fullscreen funciona en ambas plataformas, probar fallback a navegador externo y validar tracking de eventos de reproducción",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: instalación y configuración del SDK youtube_player_flutter, creación de VideoPlayerScreen con extracción de video ID, e implementación de controles avanzados con manejo de estados"
      },
      {
        "id": 29,
        "title": "Implementar sistema de favoritos para contenido",
        "description": "Desarrollar funcionalidad para guardar artículos y videos favoritos con sincronización entre dispositivos",
        "details": "Extender ContentItem con isFavorite field boolean. Implementar FavoritesRepository con addFavorite(), removeFavorite(), getFavorites(). UI: heart icon en ContentCard que toggle favorite state con animation. Crear FavoritesScreen para ver saved content. Sync favorites con Supabase usando junction table user_content_favorites. Manejar conflicts si same user modifica favorites en multiple devices.",
        "testStrategy": "Verificar favorites persisten tras reinicio, probar sync entre devices funciona, validar conflict resolution",
        "priority": "low",
        "dependencies": [
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extender modelo ContentItem e implementar FavoritesRepository",
            "description": "Modificar el modelo ContentItem para incluir el campo isFavorite y crear el repositorio de favoritos con métodos básicos",
            "dependencies": [],
            "details": "Agregar campo boolean isFavorite al modelo ContentItem. Crear FavoritesRepository con métodos addFavorite(), removeFavorite() y getFavorites(). Implementar almacenamiento local usando Isar para persistir estado de favoritos. Configurar Riverpod provider para gestionar estado de favoritos en la aplicación.",
            "status": "pending",
            "testStrategy": "Verificar que los favoritos se persisten correctamente en Isar, probar que los métodos del repositorio funcionan sin errores y validar que el estado se mantiene tras reinicio de la app",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar UI de favoritos con ícono heart y pantalla FavoritesScreen",
            "description": "Crear interfaz de usuario para marcar favoritos con ícono de corazón animado y pantalla dedicada para ver contenido guardado",
            "dependencies": [
              1
            ],
            "details": "Agregar ícono heart a ContentCard que permita toggle del estado favorito con animación suave. Implementar FavoritesScreen que muestre lista de contenido favorito con filtros por tipo. Configurar navegación hacia FavoritesScreen desde drawer o tab bar. Añadir estados vacíos cuando no hay favoritos guardados.",
            "status": "pending",
            "testStrategy": "Probar que la animación del corazón funciona correctamente, verificar que FavoritesScreen muestra el contenido adecuado y validar que la navegación funciona sin problemas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sincronización de favoritos con Supabase y resolución de conflictos",
            "description": "Configurar sincronización de favoritos entre dispositivos usando Supabase y manejar conflictos cuando el mismo usuario modifica favoritos en múltiples dispositivos",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear tabla user_content_favorites en Supabase como junction table. Implementar FavoritesSyncService que sincronice favoritos locales con servidor. Manejar conflictos usando timestamp de última modificación, priorizando cambios más recientes. Implementar sync automático en background y manual pull-to-refresh en FavoritesScreen.",
            "status": "pending",
            "testStrategy": "Verificar sincronización funciona entre múltiples dispositivos, probar resolución de conflictos cuando se modifican favoritos simultáneamente y validar que sync en background no afecta rendimiento",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: extensión del modelo ContentItem y creación del repositorio de favoritos, implementación de UI con ícono heart y pantalla dedicada, y configuración de sincronización con resolución de conflictos"
      },
      {
        "id": 30,
        "title": "Crear ProfileScreen para gestión de configuración",
        "description": "Desarrollar pantalla de perfil con edición de peso, configuración de tema y preferencias de notificaciones",
        "details": "Crear ProfileScreen con sections: User Info (weight, height editing), Hydration (goal adjustment, glass size), Notifications (toggles por type), Theme (light/dark/system toggle), Account (logout, export data). Implementar form validation para weight/height. Usar TextFormField con input formatters. Settings persisten en UserProfile y SharedPreferences. Agregar confirmation dialogs para destructive actions.",
        "testStrategy": "Probar validaciones form funcionan, verificar settings persisten correctamente, validar confirmation dialogs",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de ProfileScreen con navegación",
            "description": "Implementar la estructura básica de la pantalla de perfil con AppBar, navegación y layout principal con secciones definidas",
            "dependencies": [],
            "details": "Crear archivo profile_screen.dart en lib/screens/. Implementar Scaffold con AppBar personalizado. Crear estructura de secciones usando Column y Card widgets: User Info, Hydration, Notifications, Theme, Account. Agregar navegación desde BottomNavigationBar. Implementar scroll behavior con SingleChildScrollView.",
            "status": "pending",
            "testStrategy": "Verificar navegación funciona correctamente, probar scroll en diferentes tamaños de pantalla, validar estructura visual",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar secciones de User Info y Hydration con validaciones",
            "description": "Desarrollar formularios para edición de peso/altura y configuración de hidratación con validación de inputs",
            "dependencies": [
              1
            ],
            "details": "Implementar User Info section con TextFormField para weight y height usando input formatters (números decimales). Agregar validación: peso 30-300kg, altura 100-250cm. Crear Hydration section con slider para goal adjustment (1-5L) y selector para glass size (150ml, 200ml, 250ml, 300ml). Conectar con UserProfile model para persistir cambios.",
            "status": "pending",
            "testStrategy": "Probar validaciones de formulario funcionan, verificar persistencia de datos, validar input formatters",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar secciones Theme, Notifications y Account con confirmaciones",
            "description": "Desarrollar configuraciones de tema, notificaciones y acciones de cuenta con diálogos de confirmación",
            "dependencies": [
              2
            ],
            "details": "Crear Theme section con radio buttons para light/dark/system. Implementar Notifications section con switches para diferentes tipos de notificaciones (ayuno, hidratación, recordatorios). Crear Account section con botones para logout y export data. Agregar confirmation dialogs para acciones destructivas usando AlertDialog. Persistir configuraciones en SharedPreferences.",
            "status": "pending",
            "testStrategy": "Verificar cambios de tema se aplican correctamente, probar toggles de notificaciones, validar confirmation dialogs para acciones destructivas",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de la estructura base de ProfileScreen con navegación, implementación de secciones User Info y Hydration con validaciones, y desarrollo de configuraciones Theme/Notifications/Account con confirmaciones"
      },
      {
        "id": 31,
        "title": "Configurar Superwall para monetización y paywall",
        "description": "Integrar Superwall SDK para presentación de paywall, A/B testing y gestión de suscripciones premium",
        "details": "Instalar superwall_flutter SDK. Configurar API keys y experiment IDs. Crear SuperwallService wrapper con métodos: presentPaywall(), checkSubscriptionStatus(), restorePurchases(). Implementar paywall triggers: después onboarding, al acceder premium features. Configurar productos: monthly/yearly subscriptions. Setup webhook endpoint para subscription events. Trackear conversion events para optimization.",
        "testStrategy": "Verificar paywall se presenta correctamente, probar purchase flow completo, validar subscription status sync",
        "priority": "medium",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrar SDK de Superwall en Flutter",
            "description": "Instalar y configurar el SDK superwall_flutter en el proyecto con las dependencias necesarias",
            "dependencies": [],
            "details": "Agregar superwall_flutter SDK al pubspec.yaml. Configurar API keys y experiment IDs en la aplicación. Inicializar Superwall en main.dart con las credenciales apropiadas. Configurar permisos necesarios para iOS y Android. Verificar que la inicialización sea exitosa y el SDK esté correctamente integrado.",
            "status": "pending",
            "testStrategy": "Verificar que el SDK se inicializa sin errores y que las credenciales son válidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear SuperwallService wrapper con métodos core",
            "description": "Desarrollar servicio wrapper que encapsule la funcionalidad de Superwall con métodos principales",
            "dependencies": [
              1
            ],
            "details": "Crear clase SuperwallService con métodos presentPaywall(), checkSubscriptionStatus(), restorePurchases(). Implementar manejo de estados de suscripción y respuestas del paywall. Integrar con el sistema de gestión de estado de la aplicación. Manejar errores y casos edge apropiadamente.",
            "status": "pending",
            "testStrategy": "Probar cada método individualmente y verificar respuestas correctas del SDK",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar triggers de paywall y configurar productos",
            "description": "Configurar cuándo y cómo se presenta el paywall, y establecer productos de suscripción",
            "dependencies": [
              2
            ],
            "details": "Implementar triggers para mostrar paywall después del onboarding y al acceder a features premium. Configurar productos de suscripción monthly/yearly en Superwall dashboard. Integrar triggers con la navegación de la app y flujos de usuario. Configurar A/B testing para diferentes presentaciones de paywall.",
            "status": "pending",
            "testStrategy": "Verificar que el paywall se presenta en los momentos correctos y que los productos están disponibles",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar webhooks y tracking de eventos de conversión",
            "description": "Establecer endpoint para webhooks de Superwall y implementar tracking de eventos de conversión",
            "dependencies": [
              3
            ],
            "details": "Setup webhook endpoint en el backend para recibir eventos de subscription de Superwall. Implementar manejo de eventos como subscription_started, subscription_cancelled, subscription_renewed. Configurar tracking de conversion events para optimization del paywall. Integrar con analytics para monitorear performance de conversión.",
            "status": "pending",
            "testStrategy": "Probar que los webhooks reciben eventos correctamente y que el tracking de conversión funciona",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en integración del SDK Superwall, configuración de productos y suscripciones, implementación de triggers de paywall, y manejo de webhooks para eventos de suscripción"
      },
      {
        "id": 32,
        "title": "Implementar gating de features premium",
        "description": "Desarrollar sistema para restringir funcionalidades avanzadas a usuarios con suscripción activa",
        "details": "Crear SubscriptionManager con checkIsPremium() method. Implementar isPremiumProvider en Riverpod que exponga boolean status. Features premium: custom fasting plans, detailed analytics, meditation library, ad-free experience. Crear PremiumFeatureGate widget que wrappea premium content y muestra upsell si not subscribed. Implementar graceful fallbacks para free users.",
        "testStrategy": "Verificar gating funciona correctamente, probar upsell flows, validar fallbacks para free users apropiados",
        "priority": "low",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear SubscriptionManager y provider de estado premium",
            "description": "Implementar el sistema base de gestión de suscripciones con SubscriptionManager y provider Riverpod para verificar estado premium del usuario",
            "dependencies": [],
            "details": "Crear clase SubscriptionManager con método checkIsPremium() que verifique estado de suscripción actual. Implementar isPremiumProvider en Riverpod que exponga boolean status del estado premium. Configurar lógica de verificación de suscripción activa y gestión de estados de error. Integrar con sistema de autenticación existente para verificar permisos de usuario.",
            "status": "pending",
            "testStrategy": "Verificar checkIsPremium() retorna estado correcto, probar provider actualiza apropiadamente cuando cambia suscripción",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar PremiumFeatureGate widget universal",
            "description": "Crear widget reutilizable que envuelva contenido premium y gestione automáticamente la visualización de upsell o contenido según estado de suscripción",
            "dependencies": [
              1
            ],
            "details": "Implementar PremiumFeatureGate widget que reciba child widget y gestione display condicional. Si usuario no es premium, mostrar pantalla de upsell con call-to-action. Si es premium, mostrar contenido original. Diseñar UI atractiva para upsell con beneficios claramente explicados. Incluir navegación a pantalla de suscripción desde el gate.",
            "status": "pending",
            "testStrategy": "Probar widget muestra upsell para usuarios free y contenido para premium, verificar navegación a suscripción funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar gating en features premium específicas",
            "description": "Aplicar PremiumFeatureGate a todas las funcionalidades premium identificadas y configurar fallbacks apropiados para usuarios gratuitos",
            "dependencies": [
              2
            ],
            "details": "Integrar PremiumFeatureGate en: custom fasting plans (mostrar solo planes básicos), detailed analytics (limitar métricas mostradas), meditation library (acceso limitado), ad-free experience (mostrar ads apropiadamente). Configurar graceful fallbacks que no rompan experiencia de usuario free. Implementar tracking de eventos cuando usuarios interactúan con gates premium.",
            "status": "pending",
            "testStrategy": "Verificar cada feature premium está correctamente protegida, probar fallbacks funcionan sin errores, validar tracking analytics",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de SubscriptionManager y provider de estado premium, desarrollo de PremiumFeatureGate widget universal, e implementación de gating en features específicas con fallbacks"
      },
      {
        "id": 33,
        "title": "Configurar programación de notificaciones con OneSignal",
        "description": "Implementar sistema para programar notificaciones automáticas de ayuno, hidratación y engagement",
        "details": "Crear NotificationScheduler service con métodos: scheduleFastingNotifications(), scheduleHydrationReminders(), scheduleEngagementNotifications(). Trigger notifications en: fast start, milestones (4h, 8h, 12h, 16h), completion, water reminders cada 2h, re-engagement si inactive >24h. Usar OneSignal scheduled notifications API. Implementar user preferences para disable specific types. Handle timezone changes.",
        "testStrategy": "Verificar notifications llegan en tiempos correctos, probar user preferences respetadas, validar timezone handling",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear servicio base NotificationScheduler",
            "description": "Implementar la clase NotificationScheduler con la estructura básica y métodos principales para programación de notificaciones",
            "dependencies": [],
            "details": "Crear NotificationScheduler service class con métodos scheduleFastingNotifications(), scheduleHydrationReminders(), scheduleEngagementNotifications(). Implementar manejo de OneSignal scheduled notifications API. Configurar estructura base para scheduling con validaciones de tiempo y parámetros.",
            "status": "pending",
            "testStrategy": "Verificar que el servicio se inicializa correctamente y los métodos base están definidos sin errores",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar templates y programación de notificaciones de ayuno",
            "description": "Crear templates de notificaciones para eventos de ayuno y programar automáticamente según milestone",
            "dependencies": [
              1
            ],
            "details": "Implementar scheduleFastingNotifications() con templates para fast start, milestones (4h, 8h, 12h, 16h) y completion. Configurar OneSignal scheduled send times basado en user fast schedule. Implementar lógica para cancelar notifications si fast es interrumpido.",
            "status": "pending",
            "testStrategy": "Probar que notifications se programan en tiempos correctos para cada milestone de ayuno",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar sistema de preferencias de usuario para notificaciones",
            "description": "Implementar gestión de preferencias para permitir al usuario deshabilitar tipos específicos de notificaciones",
            "dependencies": [
              1
            ],
            "details": "Crear UserNotificationPreferences model con flags para fasting, hydration, engagement notifications. Implementar storage en SharedPreferences/UserDefaults. Modificar NotificationScheduler para respetar user preferences antes de schedule. Crear UI settings para toggle preferences.",
            "status": "pending",
            "testStrategy": "Verificar que preferences se guardan correctamente y notifications respetan configuración de usuario",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar manejo de cambios de zona horaria y notificaciones de hidratación",
            "description": "Gestionar cambios de timezone y implementar recordatorios automáticos de hidratación cada 2 horas",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementar timezone change detection y re-scheduling de notifications existentes. Crear scheduleHydrationReminders() con intervals de 2 horas durante horas activas. Implementar scheduleEngagementNotifications() para re-engagement después 24h inactividad. Manejar timezone conversions para OneSignal API.",
            "status": "pending",
            "testStrategy": "Probar timezone changes actualiza schedules correctamente y hydration reminders llegan cada 2 horas",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Dividir en subtareas específicas para programación de notificaciones: configurar servicio de scheduling, implementar templates de notificaciones, manejar preferencias de usuario y gestionar cambios de zona horaria"
      },
      {
        "id": 34,
        "title": "Implementar deep linking para notificaciones",
        "description": "Configurar navigation directa a pantallas específicas cuando usuario tapa notificaciones push",
        "details": "Configurar go_router con routes para deep links. Implementar NotificationHandler que parse notification data y route appropriately: fast_milestone -> /home, hydration_reminder -> /home (focus water button), learning_content -> /learning/article/:id. Configurar Universal Links (iOS) y App Links (Android) con domain verification. Host apple-app-site-association y assetlinks.json en https://zendfast.app/.well-known/.",
        "testStrategy": "Probar deep links funcionan desde notifications, verificar Universal/App Links setup, validar routing correcto",
        "priority": "low",
        "dependencies": [
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar go_router con rutas para deep links",
            "description": "Configurar el sistema de routing de go_router para manejar enlaces profundos y navegación directa desde notificaciones push",
            "dependencies": [],
            "details": "Extender la configuración actual de go_router para incluir rutas específicas para deep links: /home para fast_milestone, /home con parámetro focus para hydration_reminder, y /learning/article/:id para learning_content. Modificar el router principal para detectar y parsear parámetros de deep linking. Implementar fallbacks para rutas inválidas que redirijan al home. Configurar route guards si es necesario para verificar autenticación antes de navegar.",
            "status": "pending",
            "testStrategy": "Verificar que todas las rutas de deep linking funcionan correctamente, probar navegación desde diferentes puntos de entrada, validar fallbacks para rutas inválidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar NotificationHandler para parsing de datos",
            "description": "Desarrollar la lógica para interceptar y procesar notificaciones push, extrayendo datos relevantes para routing",
            "dependencies": [
              1
            ],
            "details": "Crear NotificationHandler service que intercepte notificaciones cuando la app se abre desde notification tap. Parsear el payload de la notificación para extraer tipo (fast_milestone, hydration_reminder, learning_content) y datos adicionales como article_id. Implementar mapping entre tipos de notificación y rutas correspondientes. Manejar casos edge como datos malformados o tipos desconocidos. Integrar con el router configurado en subtask anterior para ejecutar navegación apropiada.",
            "status": "pending",
            "testStrategy": "Probar parsing correcto de diferentes tipos de notificaciones, verificar manejo de datos malformados, validar routing ejecuta correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Universal Links y App Links con verificación de dominio",
            "description": "Implementar Universal Links para iOS y App Links para Android con verificación de dominio en zendfast.app",
            "dependencies": [
              2
            ],
            "details": "Configurar Universal Links en iOS agregando associated domains en capabilities y creando apple-app-site-association file. Para Android, configurar App Links en AndroidManifest.xml con intent filters y crear assetlinks.json. Hostear ambos archivos en https://zendfast.app/.well-known/ directory. Implementar domain verification process para ambas plataformas. Configurar URL schemes que coincidan con las rutas definidas en go_router. Testear que links externos abren la app correctamente.",
            "status": "pending",
            "testStrategy": "Verificar Universal Links funcionan en dispositivos iOS, probar App Links en Android, validar archivos de verificación son accesibles en dominio",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en configuración de routing con go_router, implementación de NotificationHandler para parsing, y setup de Universal/App Links con verificación de dominio"
      },
      {
        "id": 35,
        "title": "Desarrollar SyncManager para sincronización bidireccional",
        "description": "Implementar sistema robusto de sincronización entre Isar local y Supabase con resolución de conflictos",
        "details": "Crear SyncManager con métodos: fullSync(), incrementalSync(), conflictResolution(). Estrategia: last-write-wins usando timestamps. Sync triggers: app foreground, wifi connect, manual refresh, timer eventos. Implement exponential backoff para retry failed syncs. Queue local changes durante offline periods. Sync entities: FastingSession, HydrationLog, UserProfile, ContentFavorites. Handle partial sync failures gracefully.",
        "testStrategy": "Probar sync funciona offline->online, verificar conflict resolution, validar no data loss durante sync failures",
        "priority": "high",
        "dependencies": [
          "7",
          "16",
          "17",
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear clase SyncManager con arquitectura base y métodos principales",
            "description": "Implementar la estructura fundamental del SyncManager con los métodos core para sincronización",
            "dependencies": [],
            "details": "Crear clase SyncManager en lib/services/sync/ con métodos: fullSync(), incrementalSync(), conflictResolution(). Definir interfaces ISyncable para entidades. Implementar SyncState enum (idle, syncing, error). Crear SyncResult class para retornos. Configurar dependency injection con Riverpod. Implementar singleton pattern para acceso global.",
            "status": "pending",
            "testStrategy": "Probar instanciación correcta, verificar métodos están definidos, validar singleton funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de cola offline y triggers de sincronización",
            "description": "Desarrollar mecanismo para queuing de cambios locales y triggers automáticos de sync",
            "dependencies": [
              1
            ],
            "details": "Crear SyncQueue para almacenar cambios offline usando Isar. Implementar SyncTrigger enum (appForeground, wifiConnect, manual, timer). Configurar listeners para app lifecycle y connectivity changes. Implementar timer periódico (configurable). Crear PendingChange model con operationType (create/update/delete), entityType, data, timestamp. Manejar prioridades de sync.",
            "status": "pending",
            "testStrategy": "Probar cola persiste cambios offline, verificar triggers se ejecutan correctamente, validar orden de procesamiento",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar resolución de conflictos y manejo de errores con retry",
            "description": "Implementar estrategia last-write-wins y sistema robusto de manejo de errores con exponential backoff",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar ConflictResolver con estrategia last-write-wins usando updatedAt timestamps. Crear RetryManager con exponential backoff (base 2s, max 60s, max 5 retries). Manejar partial sync failures gracefully manteniendo progreso. Implementar SyncError types (network, conflict, validation). Crear recovery mechanisms para data corruption. Logging detallado para debugging.",
            "status": "pending",
            "testStrategy": "Probar resolución de conflictos con timestamps, verificar retry logic funciona, validar recovery de errores parciales",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de la arquitectura base del SyncManager con métodos principales, implementación de sistema de cola offline y triggers de sincronización, y desarrollo de resolución de conflictos con manejo robusto de errores"
      },
      {
        "id": 36,
        "title": "Configurar Sentry para monitoreo de errores",
        "description": "Integrar Sentry SDK para tracking automático de crashes, errores y performance monitoring en producción",
        "details": "Instalar sentry_flutter ^7.0.0. Configurar DSN y environment (dev/prod). Wrap runApp en Sentry.init(). Implementar custom error boundaries para graceful error handling. Setup source maps upload para readable stack traces. Configure performance monitoring para detectar slow frames, large widget builds. Implement user context attachment (user ID, subscription status). Setup release tracking.",
        "testStrategy": "Verificar errores se reportan a Sentry, probar source maps funcionan, validar performance monitoring activo",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar setup inicial de Sentry SDK",
            "description": "Instalar Sentry Flutter SDK, configurar DSN y environments, y realizar integración básica",
            "dependencies": [],
            "details": "Instalar sentry_flutter ^7.0.0 en pubspec.yaml. Crear archivo sentry_config.dart para manejar DSN y environment variables (development/production). Configurar Sentry.init() wrapper alrededor de runApp() en main.dart. Implementar custom error boundaries para graceful error handling. Configurar diferentes DSN para dev/prod environments usando flavors.",
            "status": "pending",
            "testStrategy": "Verificar que los errores se reportan correctamente a Sentry dashboard, probar que environments se diferencian correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar source maps y contexto de usuario",
            "description": "Implementar upload de source maps para stack traces legibles y configurar contexto de usuario",
            "dependencies": [
              1
            ],
            "details": "Setup source maps upload automático para builds de release que permita readable stack traces en Sentry. Implementar user context attachment incluyendo user ID, subscription status, y metadata relevante. Configurar Sentry tags para categorizar errores por tipo de usuario (free/premium). Implementar breadcrumbs para tracking de user journey antes del error.",
            "status": "pending",
            "testStrategy": "Probar que los stack traces son legibles en production builds, validar que el contexto de usuario aparece en los reportes de error",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar performance monitoring y release tracking",
            "description": "Implementar monitoreo de performance y configurar tracking de releases automático",
            "dependencies": [
              1
            ],
            "details": "Configure performance monitoring para detectar slow frames, large widget builds, y slow navigation transitions. Implementar custom performance transactions para operaciones críticas como login, data sync, y screen loads. Setup release tracking automático con CI/CD integration para trackear cuando nuevas versiones causan regressions. Configurar alertas automáticas para performance degradation y crash rate increases.",
            "status": "pending",
            "testStrategy": "Verificar que performance metrics aparecen en Sentry dashboard, probar que releases se trackean automáticamente, validar alertas funcionan correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en setup inicial de Sentry SDK, configuración de source maps y contexto de usuario, y configuración de performance monitoring y alertas"
      },
      {
        "id": 37,
        "title": "Implementar testing de accesibilidad WCAG 2.1 AA",
        "description": "Asegurar cumplimiento de estándares de accesibilidad con contraste de colores, tamaños de toque y etiquetas semánticas",
        "details": "Verificar color contrast 4.5:1 mínimo para todos text/background combinations. Implementar touch targets 44×44dp minimum para todas interactive elements. Agregar Semantics labels a todos widgets: buttons, images, progress indicators. Implement focus navigation correcta para keyboard/switch users. Test con TalkBack (Android) y VoiceOver (iOS). Use Accessibility Scanner para automated testing.",
        "testStrategy": "Usar Accessibility Scanner en todas screens, manual testing con screen readers, verificar keyboard navigation",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar herramientas de testing de accesibilidad automatizado",
            "description": "Instalar y configurar Accessibility Scanner y otras herramientas automatizadas para testing de WCAG 2.1 AA",
            "dependencies": [],
            "details": "Configurar Accessibility Scanner para Android y Accessibility Inspector para iOS. Integrar flutter_accessibility_service package. Configurar CI/CD pipeline para ejecutar automated accessibility tests. Crear script de testing que verifique color contrast ratios automáticamente usando contrast ratio checking tools. Configurar semantic analysis automatizado para detectar missing labels.",
            "status": "pending",
            "testStrategy": "Verificar que las herramientas detecten correctamente violaciones de accesibilidad conocidas y generen reportes útiles",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar validación de contraste de colores y tamaños táctiles",
            "description": "Verificar y corregir ratios de contraste 4.5:1 mínimo y touch targets de 44×44dp para todos los elementos interactivos",
            "dependencies": [
              1
            ],
            "details": "Auditar todos los color combinations en la app para asegurar contrast ratio 4.5:1 mínimo. Crear ColorContrastValidator utility class. Revisar y ajustar touch targets para buttons, FABs, y interactive elements a minimum 44×44dp. Implementar TouchTargetValidator para verificar sizing. Crear accessibility_theme.dart con colores WCAG compliant. Documentar color palette accessible en design system.",
            "status": "pending",
            "testStrategy": "Usar contrast checking tools para validar todos los pares de colores, medir touch targets físicamente en dispositivos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar etiquetas semánticas y testing con screen readers",
            "description": "Agregar semantic labels completas y realizar testing exhaustivo con TalkBack y VoiceOver",
            "dependencies": [
              2
            ],
            "details": "Agregar semantic labels a todos widgets usando Semantics widget: buttons, images, progress indicators, input fields. Implementar focus navigation correcta con FocusNode management. Crear AccessibilityLabels class para centralizar strings. Testing manual completo con TalkBack (Android) y VoiceOver (iOS) en todas las pantallas principales. Documentar accessibility navigation flows. Implementar keyboard navigation support completo.",
            "status": "pending",
            "testStrategy": "Testing manual extensivo con screen readers reales, validar keyboard navigation funciona completamente, verificar semantic tree structure",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: configuración de herramientas de testing automatizado, implementación de validación de contraste y tamaños táctiles, y agregado de etiquetas semánticas con testing manual de screen readers"
      },
      {
        "id": 38,
        "title": "Implementar tema claro/oscuro con toggle del sistema",
        "description": "Desarrollar soporte completo para temas claro y oscuro con detección automática del sistema y toggle manual",
        "details": "Crear ZendfastTheme.lightTheme y ZendfastTheme.darkTheme usando Material 3 ColorScheme. Dark theme: surface #1E1E1E, background #121212, manteniendo brand colors teal/green. Implementar ThemeModeProvider (light/dark/system) con persistence en SharedPreferences. Crear ThemeToggle widget con SegmentedButton. Verificar legibilidad en ambos themes, especialmente timer display y panic button.",
        "testStrategy": "Verificar theme persiste tras restart, probar auto-detection sistema funciona, validar legibilidad ambos themes",
        "priority": "low",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear esquemas de colores Material 3 para temas claro y oscuro",
            "description": "Implementar ZendfastTheme.lightTheme y ZendfastTheme.darkTheme usando Material 3 ColorScheme con los colores específicos definidos",
            "dependencies": [],
            "details": "Crear clase ZendfastTheme con propiedades lightTheme y darkTheme. Dark theme debe usar surface #1E1E1E, background #121212, manteniendo brand colors teal/green. Light theme usar colores Material 3 por defecto con brand colors personalizados. Configurar todos los tokens de color necesarios para consistencia visual.",
            "status": "pending",
            "testStrategy": "Verificar que ambos themes renderizan correctamente, validar contraste adecuado en todos los componentes",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar ThemeModeProvider con persistencia en SharedPreferences",
            "description": "Desarrollar provider para gestionar estado del tema (light/dark/system) con almacenamiento persistente",
            "dependencies": [
              1
            ],
            "details": "Crear ThemeModeProvider usando Riverpod que maneje tres estados: light, dark, system. Implementar persistencia con SharedPreferences para mantener preferencia del usuario entre sesiones. Incluir detección automática del tema del sistema y actualización reactiva cuando el usuario cambia tema en configuración del dispositivo.",
            "status": "pending",
            "testStrategy": "Probar que preferencia persiste tras restart de app, verificar detección automática del sistema funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear widget ThemeToggle con SegmentedButton y verificar legibilidad",
            "description": "Desarrollar interfaz de usuario para alternar entre temas y validar legibilidad en ambos modos",
            "dependencies": [
              2
            ],
            "details": "Crear ThemeToggle widget usando SegmentedButton con opciones Claro/Oscuro/Sistema. Integrar con ThemeModeProvider para cambios reactivos. Realizar pruebas exhaustivas de legibilidad especialmente en timer display y panic button. Ajustar colores si es necesario para mantener accesibilidad.",
            "status": "pending",
            "testStrategy": "Validar legibilidad en timer display y panic button en ambos themes, verificar que toggle funciona correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de esquemas de colores Material 3, implementación de ThemeModeProvider con persistencia, y creación de widget ThemeToggle con verificación de legibilidad"
      },
      {
        "id": 39,
        "title": "Crear assets de Lottie para animación de respiración",
        "description": "Diseñar o adquirir animación Lottie optimizada para meditación 4-4-8 con visual zen-inspirado",
        "details": "Adquirir o crear Lottie animation file (<100KB) que muestre breathing pattern: círculo/pulmones expanding (4s), holding (4s), contracting (8s). Colors: teal/green palette matching app theme. Animation debe loop infinitely hasta user stops. Considerar subtle particles o light effects para enhanced meditation experience. Store en assets/animations/breathing.json.",
        "testStrategy": "Verificar animación smooth 60fps en mid-range devices, probar timing preciso 4-4-8, validar file size <100KB",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Investigar y seleccionar assets de animación Lottie existentes",
            "description": "Buscar en repositorios como LottieFiles, Freepik y GitHub animaciones de respiración que cumplan con los requisitos del proyecto",
            "dependencies": [],
            "details": "Explorar LottieFiles.com, Freepik y repositorios open-source para encontrar animaciones de respiración compatibles. Evaluar calidad, tamaño de archivo (<100KB), compatibilidad con palette teal/verde, y timing personalizable para patrón 4-4-8. Documentar opciones viables con URLs y licencias.",
            "status": "pending",
            "testStrategy": "Verificar que animaciones encontradas tengan licencia apropiada, tamaño <100KB y sean editables",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Diseñar animación Lottie personalizada para respiración 4-4-8",
            "description": "Crear desde cero una animación Lottie optimizada específicamente para el patrón de respiración 4-4-8 con diseño zen-inspirado",
            "dependencies": [
              1
            ],
            "details": "Usar After Effects con plugin Bodymovin para crear animación de círculo/pulmones expandiendo (4s), manteniendo (4s), contrayendo (8s). Aplicar palette teal (#069494) y verde (#7fb069). Agregar partículas sutiles y efectos de luz. Optimizar para loop infinito y export como .json <100KB.",
            "status": "pending",
            "testStrategy": "Verificar timing preciso 4-4-8 segundos, smooth loop infinito, tamaño archivo <100KB",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar y probar animación Lottie en la aplicación",
            "description": "Implementar la animación seleccionada en la aplicación Flutter y optimizar su rendimiento en dispositivos de gama media",
            "dependencies": [
              2
            ],
            "details": "Guardar archivo en assets/animations/breathing.json. Implementar con paquete lottie en Flutter. Configurar controles de play/pause/stop. Optimizar rendering para 60fps en dispositivos mid-range. Implementar preloading para evitar delays. Añadir fallback si animación falla al cargar.",
            "status": "pending",
            "testStrategy": "Probar performance 60fps en dispositivos gama media, verificar controles funcionan correctamente, validar smooth playback",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: investigación y selección de assets existentes, diseño de animación personalizada para patrón 4-4-8, e integración y optimización en la aplicación Flutter"
      },
      {
        "id": 40,
        "title": "Configurar flavors de Flutter (development/production)",
        "description": "Establecer entornos separados para desarrollo y producción con configuraciones y APIs específicas",
        "details": "Configurar Android flavors en build.gradle: development (app ID suffix .dev), production (release config). Configurar iOS schemes separados. Crear AppConfig class que lea environment variables (ENV=dev/prod) y returne appropriate Supabase URLs, API keys, debug settings. Implementar run commands con --flavor y --dart-define. Setup CI/CD para build both flavors automaticamente.",
        "testStrategy": "Verificar builds generan different app IDs, probar environment configs correctas por flavor, validar CI builds",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar Android flavors en build.gradle",
            "description": "Configurar flavors de Android para development y production con diferentes app IDs y configuraciones de build",
            "dependencies": [],
            "details": "Modificar android/app/build.gradle para agregar productFlavors: development con applicationIdSuffix '.dev' y debuggable true, production con configuración de release. Configurar buildTypes apropiados para cada flavor. Establecer diferentes iconos de app y nombres para distinguir environments. Configurar proguard y obfuscación solo para production.",
            "status": "pending",
            "testStrategy": "Verificar que se generan APKs con diferentes app IDs, probar instalación simultánea de ambos flavors, validar configuraciones específicas por environment",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar iOS schemes y configuraciones",
            "description": "Establecer schemes separados en Xcode para development y production con diferentes bundle IDs y configuraciones",
            "dependencies": [],
            "details": "Crear schemes en Xcode: ZendFast-Dev y ZendFast-Prod con diferentes bundle identifiers. Configurar diferentes Info.plist para cada scheme con URLs de API y configuraciones específicas. Establecer diferentes iconos y nombres de app. Configurar signing certificates apropiados para cada environment. Actualizar ios/Runner.xcodeproj con las configuraciones necesarias.",
            "status": "pending",
            "testStrategy": "Verificar builds generan diferentes bundle IDs, probar instalación simultánea en device, validar configuraciones específicas se aplican correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar AppConfig class para environment management",
            "description": "Crear sistema centralizado de configuración que lea environment variables y provea configuraciones específicas por flavor",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear lib/core/config/app_config.dart que lea dart-define variables (ENV=dev/prod). Implementar singleton pattern con métodos: getSupabaseUrl(), getSupabaseAnonKey(), isDebugMode(), getAppName(). Crear factory constructors para cada environment. Configurar flutter run commands con --flavor y --dart-define. Documentar comandos: 'flutter run --flavor development --dart-define=ENV=dev' y 'flutter run --flavor production --dart-define=ENV=prod'.",
            "status": "pending",
            "testStrategy": "Verificar AppConfig retorna configuraciones correctas por environment, probar comandos de run con diferentes flavors, validar variables de environment se leen correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en configuración específica por plataforma: setup de Android flavors y build.gradle, configuración de iOS schemes, e implementación de AppConfig para manejo de environment variables"
      },
      {
        "id": 41,
        "title": "Implementar obfuscación de código para producción",
        "description": "Configurar obfuscación de código Dart para proteger propiedad intelectual en builds de producción",
        "details": "Agregar --obfuscate y --split-debug-info flags a production builds. Configurar symbol file upload a Sentry para crash deobfuscation. Setup ProGuard rules para Android release builds con minification enabled. Configure Xcode release settings para iOS optimization. Store symbol files securely para future debugging. Document build commands para CI/CD.",
        "testStrategy": "Verificar production builds están obfuscados, probar Sentry puede deobfuscar crashes, validar app performance no degraded",
        "priority": "low",
        "dependencies": [
          "36",
          "40"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar flags de obfuscación en builds de Flutter",
            "description": "Implementar configuración de obfuscación para builds de producción usando flags --obfuscate y --split-debug-info",
            "dependencies": [],
            "details": "Modificar scripts de build para agregar --obfuscate y --split-debug-info=/path/to/symbols/ a comandos flutter build. Configurar diferentes paths para Android e iOS. Actualizar build.yaml y scripts de CI/CD para incluir estos flags automáticamente en production builds. Documentar ubicación de symbol files generados.",
            "status": "pending",
            "testStrategy": "Verificar que builds de producción generan archivos obfuscados y symbol files se crean correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar ProGuard y optimizaciones nativas",
            "description": "Implementar reglas ProGuard para Android y configuraciones de optimización para iOS",
            "dependencies": [
              1
            ],
            "details": "Crear proguard-rules.pro con reglas específicas para Flutter y dependencias del proyecto. Habilitar minifyEnabled true en android/app/build.gradle para release builds. Configurar Xcode release settings para iOS optimization incluyendo SWIFT_OPTIMIZATION_LEVEL y DEAD_CODE_STRIPPING. Testear que apps funcionan correctamente tras obfuscación.",
            "status": "pending",
            "testStrategy": "Probar builds de release en dispositivos reales para validar funcionamiento tras obfuscación y minificación",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar symbol files con Sentry para crash deobfuscation",
            "description": "Configurar subida automática de symbol files a Sentry para poder deobfuscar crashes en producción",
            "dependencies": [
              1,
              2
            ],
            "details": "Instalar sentry-cli y configurar upload de debug symbols automático. Configurar sentry.properties con tokens y project info. Agregar scripts post-build para subir symbol files a Sentry tras cada release build. Implementar storage seguro de symbol files localmente para debugging futuro. Documentar proceso completo en CI/CD pipeline.",
            "status": "pending",
            "testStrategy": "Generar crash intencional en build obfuscado y verificar que Sentry puede deobfuscar el stack trace correctamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: configuración de flags de obfuscación en builds Flutter, implementación de ProGuard y optimizaciones nativas, e integración de symbol files con Sentry para crash deobfuscation"
      },
      {
        "id": 42,
        "title": "Configurar CI/CD con Codemagic",
        "description": "Establecer pipeline automatizado para testing, building y deployment a app stores",
        "details": "Crear codemagic.yaml con workflows para iOS/Android production builds. Configure triggers: push to main -> production build, PR -> run tests only. Setup environment variables: Supabase keys, signing certificates, App Store Connect keys. Implement automated testing, obfuscated builds, symbol upload to Sentry. Configure deployment a TestFlight (iOS) y Internal testing (Android). Setup Slack notifications para build status.",
        "testStrategy": "Verificar CI runs sin errores, probar deployments automáticos funcionan, validar notifications apropiadas",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar workflows básicos en codemagic.yaml",
            "description": "Crear archivo codemagic.yaml con workflows para iOS y Android, configurando triggers para push a main y pull requests",
            "dependencies": [],
            "details": "Crear codemagic.yaml en la raíz del proyecto. Definir workflows separados para iOS y Android con triggers: push to main -> production build, PR -> run tests only. Configurar scripts de build para Flutter con --release flag. Establecer artefactos de output para IPA y APK.",
            "status": "pending",
            "testStrategy": "Verificar que los workflows se ejecuten correctamente al hacer push y PR, validar que generen artefactos apropiados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar variables de entorno y certificados",
            "description": "Setup de environment variables, signing certificates y keys necesarios para builds de producción",
            "dependencies": [
              1
            ],
            "details": "Configurar variables de entorno en Codemagic: SUPABASE_URL, SUPABASE_ANON_KEY, SENTRY_DSN. Subir certificados iOS (provisioning profiles, distribution certificate) y Android (keystore, key.properties). Configurar App Store Connect API key para deployment automático.",
            "status": "pending",
            "testStrategy": "Probar que las variables se resuelvan correctamente durante el build, verificar signing funciona sin errores",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar testing automatizado en pipeline",
            "description": "Configurar ejecución automática de tests unitarios y de integración en el pipeline CI/CD",
            "dependencies": [
              1
            ],
            "details": "Agregar step de testing en workflows que ejecute 'flutter test' antes del build. Configurar code coverage reporting. Implementar tests que validen funcionalidad crítica antes de deployment. Configurar pipeline para fallar si tests no pasan.",
            "status": "pending",
            "testStrategy": "Verificar que tests corran automáticamente en cada build, validar que pipeline falle con tests rotos",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar deployment automático a stores",
            "description": "Setup de deployment automático a TestFlight para iOS e Internal Testing para Android con builds obfuscados",
            "dependencies": [
              2
            ],
            "details": "Configurar deployment a TestFlight usando App Store Connect API. Setup Google Play Console para Android Internal Testing. Implementar obfuscation con --obfuscate flag. Configurar upload de símbolos de debug a Sentry para crash reporting. Establecer versionado automático.",
            "status": "pending",
            "testStrategy": "Probar deployment completo end-to-end, verificar que apps aparezcan en TestFlight e Internal Testing",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configurar notificaciones Slack para build status",
            "description": "Implementar notificaciones automáticas a Slack para reportar estado de builds exitosos y fallidos",
            "dependencies": [
              4
            ],
            "details": "Configurar Slack webhook en Codemagic para canal de desarrollo. Implementar notificaciones para: build started, build success con links a artifacts, build failed con logs de error. Configurar diferentes mensajes para production builds vs test runs.",
            "status": "pending",
            "testStrategy": "Verificar que notificaciones lleguen correctamente a Slack para todos los estados de build",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Crear subtareas para cada aspecto del pipeline: configuración de workflows, setup de environment variables y certificados, configuración de testing automatizado, deployment automation, y notificaciones de build status"
      },
      {
        "id": 43,
        "title": "Preparar assets para App Store (iOS)",
        "description": "Crear screenshots, iconos, video preview y descripción optimizada para App Store submission",
        "details": "Crear 5 screenshots por device size requerido (6.5\" iPhone, 5.5\" iPhone, iPad opcional): timer activo, panic modal, metrics dashboard, learning content, profile. Crear app icon 1024×1024 PNG zen-inspired. Grabar app preview video 15-30s mostrando core flow. Escribir App Store description optimizada con keywords 'intermittent fasting, IF tracker, meditation'. Preparar keywords string <100 chars.",
        "testStrategy": "Verificar screenshots cumplen guidelines App Store, probar video preview <30s, validar description compelling",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear screenshots para diferentes tamaños de dispositivos iOS",
            "description": "Generar capturas de pantalla optimizadas para App Store mostrando las funcionalidades principales de la aplicación",
            "dependencies": [],
            "details": "Crear 5 screenshots por cada tamaño de dispositivo requerido (6.5\" iPhone, 5.5\" iPhone, iPad opcional) mostrando: timer activo, panic modal, metrics dashboard, learning content, y profile. Usar herramientas como Simulator de Xcode o dispositivos reales para capturar pantallas de alta calidad. Asegurar que las capturas muestren la interfaz completa sin elementos debug y con datos realistas.",
            "status": "pending",
            "testStrategy": "Verificar que screenshots cumplan con las guidelines de App Store, validar resolución correcta para cada tamaño de dispositivo, confirmar que muestran funcionalidades clave de manera atractiva",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Diseñar icono de aplicación y crear video preview",
            "description": "Crear el icono oficial de la aplicación y producir un video promocional para el App Store",
            "dependencies": [],
            "details": "Diseñar app icon de 1024×1024 PNG con inspiración zen, utilizando la paleta de colores de la aplicación (teal/green). Grabar app preview video de 15-30 segundos mostrando el flujo principal: abrir app, iniciar timer, mostrar breathing animation, y dashboard de métricas. Usar herramientas como QuickTime para grabación y herramientas de edición para optimizar el video.",
            "status": "pending",
            "testStrategy": "Verificar que el icono cumple con los estándares de Apple, probar que el video preview dura menos de 30 segundos, validar que muestra el core flow de manera efectiva",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Escribir descripción y metadata optimizada para App Store",
            "description": "Crear contenido de marketing optimizado para mejorar la visibilidad en App Store",
            "dependencies": [],
            "details": "Escribir App Store description optimizada incluyendo keywords relevantes como 'intermittent fasting', 'IF tracker', 'meditation'. Crear título atractivo y subtitle que resalten los beneficios principales. Preparar keywords string de menos de 100 caracteres para maximizar discoverabilidad. Incluir información sobre funcionalidades clave, beneficios del ayuno intermitente, y características de meditación.",
            "status": "pending",
            "testStrategy": "Validar que la descripción es compelling y clara, verificar que keywords están bien distribuidos, confirmar que el contenido cumple con las políticas de App Store",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de screenshots para diferentes tamaños de dispositivos, diseño de icono y video preview, y redacción de descripción optimizada para App Store"
      },
      {
        "id": 44,
        "title": "Preparar assets para Google Play Store (Android)",
        "description": "Crear screenshots, feature graphic, descripción y metadata para Google Play Store submission",
        "details": "Crear screenshots para phone (1080×1920) mostrando key features. Diseñar feature graphic 1024×500 con app name y key visual. Escribir short description <80 chars y full description <4000 chars con HTML formatting. Preparar promotional video (YouTube URL). Configure age rating, content rating, privacy policy URL. Setup internal testing track para beta users.",
        "testStrategy": "Verificar assets cumplen Play Store requirements, probar descriptions son compelling, validar metadata correcto",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear screenshots y assets visuales para Google Play Store",
            "description": "Desarrollar screenshots de teléfono y feature graphic siguiendo las especificaciones de Google Play Store",
            "dependencies": [],
            "details": "Crear screenshots para teléfono (1080×1920) mostrando características clave de la app: pantalla de ayuno activo, modal de pánico, dashboard de métricas, contenido de aprendizaje y perfil de usuario. Diseñar feature graphic de 1024×500 con nombre de la app y visual clave que represente el concepto de ayuno intermitente y zen. Usar paleta de colores teal/verde consistente con el tema de la app.",
            "status": "pending",
            "testStrategy": "Verificar que todos los screenshots cumplan con las dimensiones exactas requeridas por Google Play Store, validar que las imágenes sean de alta calidad y muestren claramente las funcionalidades principales de la app",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Escribir descripciones y metadata optimizada para Google Play Store",
            "description": "Crear descripciones corta y completa con formato HTML y optimización SEO para Google Play Store",
            "dependencies": [],
            "details": "Escribir descripción corta de menos de 80 caracteres que capture la esencia de la app de ayuno intermitente. Crear descripción completa de menos de 4000 caracteres con formato HTML que incluya características principales, beneficios del ayuno intermitente, funcionalidades de meditación y tracker. Incluir keywords relevantes como 'ayuno intermitente', 'tracker IF', 'meditación', 'wellness'. Configurar categorías apropiadas y tags de contenido.",
            "status": "pending",
            "testStrategy": "Verificar que las descripciones sean atractivas y convincentes, validar que el conteo de caracteres esté dentro de los límites, probar que las keywords estén bien integradas de forma natural",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar clasificaciones y setup de testing interno",
            "description": "Completar configuración de age rating, content rating, privacy policy y configurar track de testing interno",
            "dependencies": [
              1,
              2
            ],
            "details": "Configurar age rating apropiado para la app de wellness (probablemente Everyone o Teen). Establecer content rating para aplicaciones de salud y bienestar. Añadir URL de privacy policy válida. Preparar video promocional para YouTube si es necesario. Configurar internal testing track en Google Play Console para beta users, incluyendo lista de testers y instrucciones de testing. Revisar todos los aspectos de compliance y metadata antes de submission.",
            "status": "pending",
            "testStrategy": "Validar que todos los ratings y clasificaciones sean apropiados para el contenido de la app, verificar que la privacy policy sea accesible y completa, probar que el internal testing track funcione correctamente con usuarios beta",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de screenshots y assets visuales, redacción de descripciones optimizada, y configuración de clasificaciones con testing interno"
      },
      {
        "id": 45,
        "title": "Crear documentación legal (Privacy Policy y Terms of Service)",
        "description": "Desarrollar documentos legales GDPR/CCPA compliant para cumplimiento regulatorio y app store requirements",
        "details": "Crear Privacy Policy cubriendo: data collected (email, weight, sessions, device info), usage purposes, third-party services (Supabase, OneSignal, Superwall, Sentry), user rights (export, deletion), retention periods. Crear Terms of Service cubriendo: medical disclaimers, subscription terms, user responsibilities, liability limitations. Host en https://zendfast.app/privacy y /terms. Implementar acceptance flow en onboarding.",
        "testStrategy": "Verificar documentos legalmente sound, probar URLs accessible, validar acceptance flow funciona",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear Privacy Policy GDPR/CCPA compliant",
            "description": "Desarrollar documento de Privacy Policy que cumpla con regulaciones GDPR y CCPA para la aplicación de ayuno intermitente",
            "dependencies": [],
            "details": "Crear Privacy Policy cubriendo: datos recolectados (email, peso, sesiones de ayuno, información del dispositivo), propósitos de uso, servicios de terceros (Supabase, OneSignal, Superwall, Sentry), derechos del usuario (exportar datos, eliminación), períodos de retención de datos. Debe incluir secciones sobre cookies, analytics, notificaciones push y manejo de datos de salud. Redactar en lenguaje claro y accesible para usuarios.",
            "status": "pending",
            "testStrategy": "Revisar documento con consultor legal para compliance GDPR/CCPA, verificar cobertura completa de todos los datos recolectados y servicios utilizados",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear Terms of Service con disclaimers médicos",
            "description": "Desarrollar documento de Terms of Service incluyendo disclaimers médicos y términos de suscripción para la aplicación",
            "dependencies": [],
            "details": "Crear Terms of Service cubriendo: disclaimers médicos (la app no reemplaza consejos médicos, consultar profesional antes de comenzar ayuno), términos de suscripción (billing, cancelaciones, reembolsos), responsabilidades del usuario, limitaciones de responsabilidad de la empresa, términos de uso aceptable, política de terminación de cuenta. Incluir jurisdicción aplicable y resolución de disputas.",
            "status": "pending",
            "testStrategy": "Validar disclaimers médicos son suficientes para protección legal, revisar términos de suscripción con app stores, verificar compliance con regulaciones locales",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de hosting y acceptance flow",
            "description": "Configurar hosting de documentos legales en URLs públicas e implementar flujo de aceptación en onboarding",
            "dependencies": [
              1,
              2
            ],
            "details": "Hostear documentos en https://zendfast.app/privacy y https://zendfast.app/terms con design responsive y navegación clara. Implementar acceptance flow en onboarding screen donde usuarios deben aceptar Privacy Policy y Terms antes de continuar. Guardar timestamp de aceptación en UserProfile. Agregar enlaces a documentos en settings screen y footer de la app. Implementar versioning para futuras actualizaciones de términos.",
            "status": "pending",
            "testStrategy": "Probar URLs son accesibles públicamente, verificar acceptance flow bloquea acceso sin aceptación, validar timestamps se guardan correctamente, probar responsive design en diferentes dispositivos",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de Privacy Policy GDPR/CCPA compliant, desarrollo de Terms of Service con disclaimers médicos, e implementación de hosting y acceptance flow"
      },
      {
        "id": 46,
        "title": "Implementar testing de performance con métricas específicas",
        "description": "Desarrollar suite de pruebas para validar rendimiento de timer, consumo de batería y fluidez de animaciones",
        "details": "Crear performance tests para: timer accuracy (±5s en 16h), battery consumption (<5% en 16h background), app launch time (<2s cold start), animation frame rate (60fps para Lottie), memory usage monitoring. Usar Flutter DevTools Timeline para profiling. Test en target devices: Pixel 6, iPhone 13. Implement automated performance regression testing en CI.",
        "testStrategy": "Ejecutar performance tests en CI, verificar métricas meet requirements, probar en physical devices",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar herramientas de testing de performance y métricas base",
            "description": "Establecer el framework de testing de performance con Flutter DevTools y configurar métricas base para timer accuracy, battery consumption, app launch time, frame rate y memory usage",
            "dependencies": [],
            "details": "Configurar Flutter DevTools Timeline para profiling. Implementar PerformanceTestSuite con métodos para medir timer accuracy (±5s en 16h), battery consumption (<5% en 16h background), app launch time (<2s cold start), animation frame rate (60fps para Lottie) y memory usage monitoring. Crear TestMetricsCollector para capturar y almacenar datos de performance.",
            "status": "pending",
            "testStrategy": "Verificar que todas las herramientas de medición funcionan correctamente y capturan métricas precisas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar tests específicos para cada métrica de performance",
            "description": "Desarrollar tests individuales para validar cada aspecto de performance: timer accuracy, battery usage, launch time, animation smoothness y memory consumption",
            "dependencies": [
              1
            ],
            "details": "Crear TimerAccuracyTest para validar precisión de ±5s en 16h, BatteryConsumptionTest para verificar <5% consumption en background, AppLaunchTest para cold start <2s, AnimationFrameRateTest para 60fps en Lottie animations, MemoryUsageTest para monitoring. Implementar thresholds y assertions para cada métrica. Configurar test execution en target devices: Pixel 6, iPhone 13.",
            "status": "pending",
            "testStrategy": "Ejecutar cada test individualmente y verificar que los thresholds de performance se cumplan en dispositivos objetivo",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar automated performance regression testing en CI",
            "description": "Configurar pipeline de CI para ejecutar performance tests automáticamente y detectar regresiones de performance en cada deployment",
            "dependencies": [
              2
            ],
            "details": "Integrar PerformanceTestSuite en CI pipeline (GitHub Actions o similar). Configurar automated execution en cada PR y merge. Implementar PerformanceReportGenerator para generar reportes comparativos. Configurar alerts para performance regressions que excedan thresholds. Establecer baseline metrics y trending analysis. Implementar fail conditions cuando performance degrada significativamente.",
            "status": "pending",
            "testStrategy": "Verificar que CI ejecuta performance tests correctamente, detecta regresiones y genera reportes útiles para el equipo",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: configuración de herramientas de testing y métricas base, implementación de tests específicos para cada métrica, e integración de testing automatizado en CI"
      },
      {
        "id": 47,
        "title": "Desarrollar Edge Functions en Supabase",
        "description": "Crear funciones serverless para cálculo de métricas, scheduling de notificaciones y webhook handling",
        "details": "Crear Edge Functions: calculate-user-metrics (recalcula streak/hours tras session), schedule-notifications (OneSignal API calls), sync-user-data (conflict resolution), handle-superwall-webhook (subscription events), backup-data (GDPR export), track-analytics-event (custom events). Usar Deno runtime. Implement error handling y logging. Deploy via Supabase CLI. Setup monitoring y alertas.",
        "testStrategy": "Probar functions respond correctly, verificar error handling, validar webhook security signatures",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear Edge Function calculate-user-metrics para recálculo de métricas",
            "description": "Desarrollar función serverless que recalcula streak y horas totales de ayuno después de cada sesión completada",
            "dependencies": [],
            "details": "Implementar calculate-user-metrics.ts usando Deno runtime. La función debe recibir userId y sessionId, consultar Supabase para obtener todas las sesiones del usuario, calcular streak actual (días consecutivos), sumar horas totales ayunadas, y actualizar UserProfile. Incluir validación de datos de entrada, manejo de errores con try-catch, y logging detallado. Configurar CORS headers y autenticación JWT.",
            "status": "pending",
            "testStrategy": "Probar función responde correctamente con datos válidos, verificar cálculos de streak son precisos, validar manejo de errores con datos inválidos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar Edge Functions para notificaciones y webhooks",
            "description": "Crear funciones schedule-notifications para OneSignal y handle-superwall-webhook para eventos de suscripción",
            "dependencies": [
              1
            ],
            "details": "Implementar schedule-notifications.ts que use OneSignal API para enviar notificaciones programadas basadas en horarios de ayuno del usuario. Crear handle-superwall-webhook.ts para procesar eventos de Superwall (subscription_started, subscription_expired, etc.) y actualizar UserProfile accordingly. Incluir verificación de signatures de webhook, rate limiting, y error handling robusto con códigos HTTP apropiados.",
            "status": "pending",
            "testStrategy": "Verificar notificaciones se envían correctamente, probar webhook security signatures son válidas, validar rate limiting funciona",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar Edge Functions de utilidad y deploy completo",
            "description": "Crear funciones sync-user-data, backup-data, track-analytics-event y configurar deployment con monitoring",
            "dependencies": [
              1,
              2
            ],
            "details": "Desarrollar sync-user-data.ts para resolución de conflictos durante sincronización, backup-data.ts para exportación GDPR de datos del usuario, y track-analytics-event.ts para eventos personalizados de analytics. Configurar deployment usando Supabase CLI con environment variables apropiadas. Setup monitoring con alertas para errores, timeouts y usage metrics. Documentar todas las funciones con ejemplos de uso.",
            "status": "pending",
            "testStrategy": "Probar todas las funciones deploy correctamente, verificar monitoring captura errores, validar backup GDPR exporta datos completos",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de función calculate-user-metrics, desarrollo de funciones para notificaciones y webhooks, e implementación de funciones de utilidad con deployment completo"
      },
      {
        "id": 48,
        "title": "Configurar esquemas de base de datos Supabase con RLS",
        "description": "Crear tablas, policies, triggers y seed data para backend completo con seguridad row-level",
        "details": "Crear tablas: user_profiles, fasting_sessions, hydration_logs, learning_content, motivational_phrases, analytics_events, user_metrics. Configurar RLS policies: users access solo own data, public read para content tables. Crear triggers: auto-update metrics on session complete, cleanup old analytics. Seed data: fasting plans, learning content, motivational phrases español. Setup database migrations con versioning.",
        "testStrategy": "Verificar RLS policies bloquean unauthorized access, probar triggers funcionan, validar seed data correcta",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Diseñar esquemas de base de datos principales",
            "description": "Crear esquemas SQL para todas las tablas principales del sistema con tipos de datos, constrainsts y relaciones apropiadas",
            "dependencies": [],
            "details": "Crear esquemas SQL para user_profiles (id, user_id, weight_kg, height_cm, daily_hydration_goal, created_at, updated_at), fasting_sessions (id, user_id, start_time, end_time, duration_minutes, plan_type, completed, interrupted, created_at), hydration_logs (id, user_id, amount_ml, timestamp, created_at), learning_content (id, title, content_type, category, content_url, is_premium, order_index, created_at), motivational_phrases (id, phrase_text, category, language, created_at), analytics_events (id, user_id, event_name, event_data, timestamp, created_at), user_metrics (id, user_id, total_fasts, total_duration_hours, streak_days, last_fast_date, created_at, updated_at). Incluir primary keys, foreign keys, indexes y constraints de validación.",
            "status": "done",
            "testStrategy": "Verificar que todos los esquemas se crean sin errores, validar constraints funcionan correctamente, probar que las relaciones entre tablas son válidas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar políticas de seguridad RLS",
            "description": "Implementar Row Level Security policies para controlar acceso a datos por usuario y contenido público",
            "dependencies": [
              1
            ],
            "details": "Habilitar RLS en todas las tablas. Crear políticas para user_profiles, fasting_sessions, hydration_logs, user_metrics: usuarios solo pueden acceder a sus propios datos usando auth.uid() = user_id. Para learning_content y motivational_phrases: acceso público de lectura para contenido no premium, acceso premium solo para usuarios autenticados con plan activo. Para analytics_events: solo insert permitido para propietarios. Configurar políticas de admin para operaciones de mantenimiento.",
            "status": "done",
            "testStrategy": "Probar que usuarios no pueden acceder a datos de otros usuarios, verificar que contenido público es accesible, validar que contenido premium requiere autenticación apropiada",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear triggers automáticos para métricas",
            "description": "Implementar triggers de base de datos para actualizar automáticamente métricas de usuario y limpieza de datos",
            "dependencies": [
              1
            ],
            "details": "Crear trigger update_user_metrics_on_fast_complete que se ejecute después de UPDATE en fasting_sessions cuando completed=true: incrementar total_fasts, sumar duration a total_duration_hours, actualizar streak_days y last_fast_date en user_metrics. Crear trigger cleanup_old_analytics que se ejecute diariamente para eliminar analytics_events más antiguos de 90 días. Crear trigger update_timestamps que actualice updated_at en user_profiles y user_metrics automáticamente.",
            "status": "done",
            "testStrategy": "Verificar que métricas se actualizan correctamente al completar ayunos, probar que cleanup funciona sin afectar datos recientes, validar que timestamps se actualizan automáticamente",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configurar sistema de migraciones",
            "description": "Establecer estructura de migraciones versionadas para manejo de cambios de esquema en producción",
            "dependencies": [],
            "details": "Crear directorio supabase/migrations/ con archivos numerados secuencialmente (001_initial_schema.sql, 002_add_rls_policies.sql, etc.). Configurar Supabase CLI para manejar migraciones automáticamente. Crear scripts para aplicar migraciones: up.sql para aplicar cambios, down.sql para rollback. Implementar migration_history table para tracking de versiones aplicadas. Documentar proceso de deployment de migraciones en README.",
            "status": "done",
            "testStrategy": "Probar que migraciones se aplican en orden correcto, verificar rollback funciona apropiadamente, validar que migration_history mantiene estado consistente",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Poblar base de datos con datos iniciales",
            "description": "Insertar datos semilla para planes de ayuno, contenido educativo y frases motivacionales en español",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear seed data para learning_content: artículos sobre beneficios del ayuno intermitente, guías de hidratación, técnicas de mindfulness (mínimo 20 artículos). Poblar motivational_phrases con 100+ frases motivacionales en español categorizadas por momento (inicio, durante, finalización ayuno). Crear fasting plans predefinidos: 16:8, 18:6, 20:4, 24h con descripciones y recomendaciones. Insertar contenido premium marcado apropiadamente. Usar archivos CSV/JSON para facilitar mantenimiento.",
            "status": "done",
            "testStrategy": "Verificar que todos los datos se insertan correctamente, probar que contenido aparece en aplicación, validar que categorización funciona apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Testing exhaustivo de seguridad y funcionalidad",
            "description": "Realizar pruebas completas de políticas RLS, triggers y integridad de datos",
            "dependencies": [
              2,
              3,
              5
            ],
            "details": "Crear suite de tests para validar RLS policies: intentar acceso no autorizado entre usuarios, verificar escalación de privilegios no es posible, probar bypass de seguridad. Testear triggers con datos reales: completar múltiples ayunos y verificar métricas, probar edge cases como interrupciones. Realizar load testing con 1000+ registros simultáneos. Usar herramientas como pgTAP para tests automatizados de base de datos. Documentar todos los casos de prueba y resultados.",
            "status": "done",
            "testStrategy": "Ejecutar suite completa de tests de seguridad sin fallos, verificar performance bajo carga, validar que no hay vulnerabilidades de acceso a datos",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Dividir en diseño de esquemas de base de datos, configuración de políticas RLS, creación de triggers automáticos, setup de migraciones, seeding de datos iniciales, y testing de seguridad"
      },
      {
        "id": 49,
        "title": "Implementar sistema de migración de datos",
        "description": "Desarrollar estrategia para migrar esquemas Isar y Supabase sin pérdida de datos de usuarios",
        "details": "Crear DatabaseMigrationService para Isar schema changes con version tracking en SharedPreferences. Implement migration scripts para add/rename fields manteniendo data integrity. Para Supabase: crear SQL migrations files con timestamps, usar Supabase CLI para apply. Implement rollback procedures y testing en development. Create data export/import functionality para user portability (GDPR).",
        "testStrategy": "Probar migrations no pierden data, verificar rollbacks funcionan, validar export/import data integrity",
        "priority": "low",
        "dependencies": [
          "2",
          "48"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear DatabaseMigrationService para Isar",
            "description": "Implementar servicio de migración para manejar cambios de esquema en base de datos Isar con versionado",
            "dependencies": [],
            "details": "Crear DatabaseMigrationService con version tracking en SharedPreferences. Implementar métodos para detectar cambios de esquema, aplicar migrations step-by-step, y mantener backward compatibility. Incluir logging detallado de migration process y error handling robusto para fallos durante migración.",
            "status": "pending",
            "testStrategy": "Probar migrations con diferentes versiones de esquema, verificar data integrity se mantiene, validar version tracking funciona correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar sistema de migraciones SQL para Supabase",
            "description": "Desarrollar infraestructura para manejar migraciones de base de datos Supabase con timestamping y rollbacks",
            "dependencies": [
              1
            ],
            "details": "Crear SQL migration files con timestamps únicos. Configurar Supabase CLI integration para aplicar migrations automáticamente. Implementar rollback procedures con scripts de reversión. Crear migration tracking table en Supabase para monitorear estado de migrations aplicadas.",
            "status": "pending",
            "testStrategy": "Probar migrations en entorno de desarrollo, verificar rollbacks funcionan correctamente, validar no hay pérdida de datos durante proceso",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar funcionalidad de export/import de datos de usuario",
            "description": "Crear sistema para exportar e importar datos de usuario completos para portabilidad y cumplimiento GDPR",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar DataExportService que genere JSON completo de user data desde Isar y Supabase. Crear DataImportService para restaurar datos en nueva instalación o después de migration. Incluir validación de data integrity, encriptación de exports sensibles, y UI para gestionar export/import process.",
            "status": "pending",
            "testStrategy": "Verificar export incluye todos los datos de usuario, probar import restaura datos correctamente, validar integridad de datos post-import",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: creación de DatabaseMigrationService para Isar, implementación de sistema de migraciones SQL para Supabase, y desarrollo de funcionalidad de export/import de datos"
      },
      {
        "id": 50,
        "title": "Crear suite de testing E2E completa",
        "description": "Desarrollar pruebas end-to-end cubriendo flujos críticos de usuario con integration_test",
        "details": "Usar integration_test package para E2E tests. Cubrir critical paths: onboarding flow completo, start/complete fast, panic button durante ayuno, water logging, session completion con metrics update. Test offline scenarios: app funciona sin internet, sync recovery on reconnect. Mock external services (Supabase, OneSignal) para deterministic testing. Run en CI con emulators.",
        "testStrategy": "Ejecutar E2E tests en CI pipeline, verificar critical paths covered, probar offline functionality",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar framework de testing E2E con integration_test",
            "description": "Instalar y configurar el package integration_test de Flutter para ejecutar pruebas end-to-end con emuladores",
            "dependencies": [],
            "details": "Agregar integration_test dependency al pubspec.yaml. Crear directorio integration_test/ con estructura básica. Configurar test runner para Android y iOS emulators. Implementar helper functions para navigation, form filling, y assertions. Configurar CI pipeline para ejecutar tests automáticamente con emulators.",
            "status": "pending",
            "testStrategy": "Verificar que tests básicos ejecuten correctamente en emulators locales y CI",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar tests de flujos críticos de usuario",
            "description": "Crear pruebas E2E para onboarding, inicio/finalización de ayuno, botón de pánico, logging de agua y completion de sesiones",
            "dependencies": [
              1
            ],
            "details": "Desarrollar test cases para: onboarding flow completo desde registro hasta primera sesión, start/complete fast workflow con timers, panic button durante ayuno activo, water logging functionality, session completion con metrics update. Implementar page objects pattern para maintainability. Usar realistic test data y user scenarios.",
            "status": "pending",
            "testStrategy": "Ejecutar todos los critical paths y verificar que cubren los escenarios de usuario más importantes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar testing offline y mocking de servicios externos",
            "description": "Crear tests para funcionalidad offline y mock de Supabase/OneSignal para pruebas determinísticas",
            "dependencies": [
              2
            ],
            "details": "Implementar tests offline: app funciona sin internet, data persiste localmente, sync recovery cuando reconnect. Mock Supabase responses para authentication, data sync, y RLS policies. Mock OneSignal para push notifications testing. Crear deterministic test scenarios con controlled network conditions. Implementar network simulation para edge cases.",
            "status": "pending",
            "testStrategy": "Verificar que la app funciona completamente offline y que el sync recovery funciona correctamente al reconectarse",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: configuración de framework E2E con integration_test, implementación de tests de flujos críticos, e implementación de testing offline con mocking de servicios"
      },
      {
        "id": 51,
        "title": "Implementar beta testing con usuarios reales",
        "description": "Configurar programa de beta testing con 20 usuarios para validar funcionalidad y recopilar feedback",
        "details": "Setup TestFlight (iOS) y Google Play Internal Testing (Android) tracks. Recruit 20 beta testers via social media/forums. Crear beta testing guidelines y feedback form (Google Forms/Typeform). Implement in-app feedback widget para easy bug reporting. Collect metrics: session completion rates, crash frequency, feature usage. Iterate basado en feedback antes production launch.",
        "testStrategy": "Verificar beta distributions funcionan, probar feedback collection effective, validar metrics tracking",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar distribución de beta en TestFlight y Google Play Console",
            "description": "Configurar las plataformas de distribución beta para iOS y Android, estableciendo los tracks internos necesarios para el programa de beta testing",
            "dependencies": [],
            "details": "Configurar TestFlight para iOS creando un nuevo grupo de beta testers y subiendo la build de la app. Para Android, configurar Google Play Internal Testing track y subir la APK/AAB. Establecer configuraciones de distribución, límites de usuarios, y configurar metadata necesaria para ambas plataformas. Verificar que las builds se distribuyan correctamente a los testers.",
            "status": "pending",
            "testStrategy": "Verificar que las builds se suban correctamente, probar descarga e instalación en dispositivos de prueba, validar configuraciones de distribución",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Reclutar 20 beta testers y crear guidelines de testing",
            "description": "Reclutar usuarios beta a través de redes sociales y foros, y crear documentación y formularios para el programa de beta testing",
            "dependencies": [
              1
            ],
            "details": "Crear strategy de reclutamiento via Twitter, Reddit, Discord y foros relevantes de ayuno intermitente. Crear beta testing guidelines document explicando objetivos, duración del programa, y expectativas. Desarrollar feedback form usando Google Forms o Typeform con secciones para bugs, sugerencias de features, y experiencia general. Establecer canal de comunicación directo con beta testers (Discord/Slack).",
            "status": "pending",
            "testStrategy": "Verificar que el proceso de reclutamiento genere suficientes candidatos calificados, probar formularios de feedback funcionan correctamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar widget de feedback in-app y sistema de métricas",
            "description": "Desarrollar widget de feedback integrado en la app y sistema de recolección de métricas para monitorear el comportamiento de los beta testers",
            "dependencies": [
              2
            ],
            "details": "Implementar FeedbackWidget como floating button o drawer item que abra modal para reportar bugs o sugerencias. Integrar con feedback form API o envío directo por email. Implementar analytics tracking para métricas clave: session completion rates, crash frequency usando Crashlytics, feature usage con custom events, user retention. Crear dashboard para monitorear métricas en tiempo real durante beta period.",
            "status": "pending",
            "testStrategy": "Probar widget de feedback envía reports correctamente, verificar métricas se capturan accurately, validar dashboard muestra datos en tiempo real",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: configuración de distribución beta en plataformas, reclutamiento de testers y creación de guidelines, e implementación de feedback collection y métricas"
      },
      {
        "id": 52,
        "title": "Configurar monitoreo de app con analytics custom",
        "description": "Implementar tracking de eventos críticos para product insights y funnel analysis",
        "details": "Implementar custom analytics events: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown. Usar Supabase analytics_events table y/o third-party service (Mixpanel/Amplitude). Create analytics dashboard para track: completion rates por plan type, panic button usage correlation, conversion funnels. Implement privacy-compliant tracking (no PII).",
        "testStrategy": "Verificar events se logean correctamente, probar analytics dashboard functional, validar privacy compliance",
        "priority": "low",
        "dependencies": [
          "48"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar tracking de eventos analíticos básicos",
            "description": "Crear servicio de analytics e implementar tracking de eventos críticos como fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed",
            "dependencies": [],
            "details": "Crear AnalyticsService class que maneje tracking de eventos. Implementar métodos para cada evento crítico: trackFastingStarted(), trackFastingCompleted(), trackFastingInterrupted(), trackPanicButtonUsed(), trackMeditationCompleted(). Configurar parámetros relevantes para cada evento (duration, planType, userId). Implementar queue local para eventos offline y sync cuando hay conexión. Asegurar compliance con privacidad (no enviar PII directamente).",
            "status": "pending",
            "testStrategy": "Verificar que eventos se registran correctamente en diferentes escenarios, probar funcionamiento offline/online, validar que no se envía información personal identificable",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar backend analytics con Supabase y servicio tercero",
            "description": "Configurar tabla analytics_events en Supabase e integrar servicio de analytics de terceros como Mixpanel o Amplitude para almacenamiento y procesamiento",
            "dependencies": [
              1
            ],
            "details": "Crear tabla analytics_events en Supabase con campos: event_name, user_id (hash), properties (JSONB), timestamp, session_id. Configurar RLS policies para seguridad. Integrar Mixpanel o Amplitude SDK para analytics avanzados. Implementar doble tracking: eventos críticos a Supabase para control directo, eventos de engagement a third-party para análisis profundo. Configurar batching y retry logic para optimizar performance.",
            "status": "pending",
            "testStrategy": "Verificar inserción correcta en Supabase, probar integración con servicio tercero, validar políticas de seguridad y batching de eventos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear dashboard de analytics y métricas de conversión",
            "description": "Desarrollar dashboard para visualizar métricas clave: completion rates por plan, uso de panic button, conversion funnels y premium conversions",
            "dependencies": [
              2
            ],
            "details": "Crear dashboard web usando Supabase queries para mostrar: completion rates por tipo de plan de ayuno, correlación de uso del panic button con abandono, funnel de conversión desde gratuito a premium, métricas de paywall_shown vs premium_conversion. Implementar gráficos temporales, filtros por fecha y segmentación de usuarios. Configurar métricas clave: CAC, LTV, retention rates, churn analysis. Incluir alertas automáticas para métricas críticas.",
            "status": "pending",
            "testStrategy": "Verificar precisión de cálculos de métricas, probar filtros y visualizaciones funcionan correctamente, validar alertas se disparan apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en implementación de tracking de eventos, configuración de analytics backend (Supabase/terceros), y creación de dashboard para visualización de métricas"
      },
      {
        "id": 53,
        "title": "Optimizar performance y memory usage",
        "description": "Realizar optimizaciones finales para asegurar fluidez en dispositivos de gama media y bajo consumo de memoria",
        "details": "Profile app con Flutter DevTools para identify bottlenecks. Optimize Riverpod providers para avoid unnecessary rebuilds. Implement lazy loading para learning content images. Optimize Lottie animations para smooth playback. Use const constructors where possible. Implement image caching strategies. Monitor memory leaks con Dart DevTools. Target: <100MB RAM usage, 60fps animations, <2s cold start.",
        "testStrategy": "Ejecutar performance profiling, verificar memory usage within targets, probar en low-end devices",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Realizar profiling y análisis de rendimiento con Flutter DevTools",
            "description": "Ejecutar análisis completo de rendimiento usando Flutter DevTools para identificar cuellos de botella en CPU, memoria y renderizado",
            "dependencies": [],
            "details": "Usar Flutter DevTools para profile la app en dispositivos de gama media. Analizar CPU usage patterns, memory allocation spikes, y frame rendering times. Identificar widgets que causan unnecessary rebuilds. Generar performance reports y documentar bottlenecks específicos. Focus en scenarios de uso intensivo como scroll de listas largas y animaciones simultáneas.",
            "status": "pending",
            "testStrategy": "Ejecutar profiling en al menos 3 dispositivos diferentes de gama media, documentar métricas before/after optimizations",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Optimizar Riverpod providers y implementar lazy loading",
            "description": "Refactorizar providers de Riverpod para evitar rebuilds innecesarios e implementar carga perezosa de contenido multimedia",
            "dependencies": [
              1
            ],
            "details": "Revisar todos los Riverpod providers para ensure proper dispose y avoid memory leaks. Implementar autoDispose donde sea apropiado. Crear lazy loading system para images de learning content usando cached_network_image. Optimize provider dependencies para minimize rebuild cascades. Implementar image preloading strategy para improve UX.",
            "status": "pending",
            "testStrategy": "Monitorear memory usage durante navigation, verificar images se cargan on-demand, probar scroll performance en listas con imágenes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Optimizar animaciones Lottie y implementar estrategias de caching",
            "description": "Mejorar rendimiento de animaciones Lottie y establecer sistema de caché efectivo para reducir consumo de memoria",
            "dependencies": [
              1,
              2
            ],
            "details": "Optimize Lottie animations para 60fps playback usando composition optimization. Implementar const constructors en todos widgets where possible. Create comprehensive image caching strategy usando flutter_cache_manager. Monitor memory leaks usando Dart DevTools. Ensure total RAM usage stays <100MB y cold start <2s. Implement performance monitoring dashboard.",
            "status": "pending",
            "testStrategy": "Verificar 60fps en animaciones, confirmar RAM usage <100MB, medir cold start time, probar en dispositivos de gama baja",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: profiling y análisis de performance con Flutter DevTools, optimización de Riverpod providers y lazy loading, y optimización de animaciones con estrategias de caching"
      },
      {
        "id": 54,
        "title": "Finalizar preparación para production launch",
        "description": "Completar checklist final para submission a app stores incluyendo compliance, security y polish",
        "details": "Complete app store compliance checklist: metadata, screenshots, descriptions, ratings. Final security audit: no hardcoded secrets, proper certificate pinning, secure API communication. Polish UI: consistent spacing, proper loading states, error handling. Verify accessibility compliance. Test en production environment con real Supabase/OneSignal. Create launch plan con marketing timeline.",
        "testStrategy": "Ejecutar full QA checklist, verificar production environment functional, validar store requirements met",
        "priority": "high",
        "dependencies": [
          "43",
          "44",
          "45"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Completar checklist de compliance para app stores",
            "description": "Verificar que todos los requisitos de metadata, screenshots, descripciones y ratings estén completos y cumplan con las guidelines de App Store y Google Play",
            "dependencies": [
              43,
              44
            ],
            "details": "Revisar metadata completo en App Store Connect y Google Play Console. Verificar screenshots están en formatos correctos y muestran features principales. Validar descripciones optimizadas con keywords relevantes. Confirmar age rating y content rating apropiados. Verificar privacy policy URL funcional. Validar todos los assets required están subidos correctamente.",
            "status": "pending",
            "testStrategy": "Ejecutar checklist completo de requirements para ambas stores, verificar preview builds se muestran correctamente",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Realizar auditoría final de seguridad y certificados",
            "description": "Ejecutar security audit completo verificando no hay hardcoded secrets, certificate pinning correcto y comunicación API segura",
            "dependencies": [],
            "details": "Escanear codebase para hardcoded API keys o secrets. Verificar certificate pinning está implementado para Supabase y OneSignal. Probar comunicación API usa HTTPS exclusivamente. Revisar permissions solicitados son mínimos necesarios. Verificar obfuscation en production builds. Confirmar no hay debug logs en release. Validar data encryption en local storage.",
            "status": "pending",
            "testStrategy": "Usar herramientas de static analysis, probar man-in-the-middle attacks fallan, verificar production builds no exponen debug info",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Polish final de UI y testing en production environment",
            "description": "Pulir interfaz con spacing consistente, loading states y error handling, luego probar en production environment con servicios reales",
            "dependencies": [],
            "details": "Revisar spacing consistente en todas las pantallas según design system. Implementar loading states en todas las llamadas API. Verificar error handling muestra mensajes user-friendly. Confirmar accessibility compliance con screen readers. Probar app completa en production environment con Supabase y OneSignal reales. Verificar performance bajo condiciones reales. Crear launch plan con timeline de marketing.",
            "status": "pending",
            "testStrategy": "Testing manual completo en production environment, verificar accessibility con screen readers, performance testing con datos reales",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: completar checklist de compliance para app stores, realizar auditoría de seguridad y certificados, y pulir UI con testing en production environment"
      },
      {
        "id": 55,
        "title": "Ejecutar submission a App Store y Google Play",
        "description": "Realizar submission final a las tiendas de aplicaciones con todos los assets y configuraciones necesarias",
        "details": "Submit iOS app a App Store Connect con: production build obfuscado, all required screenshots, app preview video, optimized description, proper categorization (Health & Fitness), age rating (4+). Submit Android app a Google Play Console con: production AAB, feature graphic, screenshots, content rating, privacy policy link. Monitor review process y respond a feedback si necesario.",
        "testStrategy": "Verificar submissions sin errores, probar builds funcionan en store review devices, monitor approval status",
        "priority": "high",
        "dependencies": [
          "54"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Preparar y subir aplicación iOS a App Store Connect",
            "description": "Configurar y subir la build de producción de iOS con todos los metadatos y assets requeridos para la revisión de Apple",
            "dependencies": [],
            "details": "Generar build de producción obfuscado para iOS usando flutter build ipa --release --obfuscate. Subir a App Store Connect via Xcode o Transporter. Configurar metadatos: título, descripción optimizada, palabras clave, categoría Health & Fitness, age rating 4+. Subir screenshots requeridos para todos los tamaños de pantalla iPhone. Añadir app preview video si disponible. Configurar pricing como gratuito con IAPs. Enviar para revisión.",
            "status": "pending",
            "testStrategy": "Verificar build se instala correctamente en dispositivos de prueba, validar todos los metadatos están completos, confirmar screenshots se ven correctos en App Store Connect",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Preparar y subir aplicación Android a Google Play Console",
            "description": "Configurar y subir el AAB de producción de Android con todos los assets y configuraciones necesarias para Google Play Store",
            "dependencies": [],
            "details": "Generar Android App Bundle (AAB) de producción usando flutter build appbundle --release --obfuscate. Subir a Google Play Console. Configurar store listing: título, descripción corta/larga, feature graphic, screenshots para phone/tablet. Configurar content rating completando cuestionario. Añadir privacy policy link. Configurar pricing como gratuito. Configurar countries de distribución. Enviar a revisión en track de producción.",
            "status": "pending",
            "testStrategy": "Probar AAB en dispositivos internos, verificar todos los assets se ven correctos en Play Console, confirmar content rating es apropiado",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Monitorear proceso de revisión y responder feedback",
            "description": "Supervisar el estado de las revisiones en ambas tiendas y responder rápidamente a cualquier feedback o rechazo",
            "dependencies": [
              1,
              2
            ],
            "details": "Monitorear App Store Connect y Google Play Console diariamente para updates del estado de revisión. Si hay rejection, analizar feedback detalladamente y crear plan de corrección. Responder a reviewers si necesario via Resolution Center. Preparar hotfixes si required. Documentar cualquier issue encontrado para futuras submissions. Notificar a stakeholders sobre timeline updates.",
            "status": "pending",
            "testStrategy": "Configurar notifications para cambios de estado, probar respuestas rápidas a rejections simulados, verificar comunicación con reviewers funciona",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Dividir en: preparación y upload de iOS a App Store Connect, configuración y upload de Android a Google Play Console, y monitoreo del proceso de revisión"
      },
      {
        "id": 56,
        "title": "Configurar go_router con guards de autenticación y deep linking completo",
        "description": "Implementar sistema completo de rutas protegidas con guards de autenticación, deep linking para notificaciones push y enlaces externos, y navegación tipo-segura para toda la aplicación",
        "details": "Extender el actual app_router.dart existente para incluir rutas completas de la aplicación: /home, /fasting (con subrutas /start, /progress), /hydration, /learning (con subrutas /articles/:id), /profile, /settings. Implementar AuthGuard middleware que verifique isAuthenticatedProvider antes de permitir acceso a rutas protegidas. Configurar deep linking handlers para notificaciones: fast_milestone -> /fasting/progress, hydration_reminder -> /hydration, learning_content -> /learning/articles/:id. Configurar Universal Links para iOS (apple-app-site-association) y App Links para Android (assetlinks.json) en dominio zendfast.app. Implementar typed navigation con rutas nombradas y parámetros tipo-seguro usando go_router extensions. Agregar manejo de rutas no encontradas (404) y redirecciones apropiadas para usuarios no autenticados que intentan acceder a rutas protegidas. Configurar refresh listener que detecte cambios en authState y redirija automáticamente.",
        "testStrategy": "Verificar que rutas protegidas redirigen a login cuando usuario no autenticado, probar deep links funcionan desde notificaciones push simuladas, validar Universal Links y App Links mediante adb y simulador iOS, confirmar navegación tipo-segura compila sin errores, probar redirecciones automáticas cuando cambia estado de autenticación, verificar manejo de rutas 404",
        "status": "done",
        "dependencies": [
          "6",
          "5"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura de rutas y AuthGuard middleware",
            "description": "Extender app_router.dart con todas las rutas de la aplicación y implementar guards de autenticación",
            "dependencies": [],
            "details": "Definir rutas completas: /home, /fasting (con subrutas /start, /progress), /hydration, /learning (con subrutas /articles/:id), /profile, /settings. Implementar AuthGuard middleware que verifique isAuthenticatedProvider antes de permitir acceso a rutas protegidas. Configurar manejo de rutas 404 y redirecciones para usuarios no autenticados.",
            "status": "done",
            "testStrategy": "Verificar que rutas protegidas redirigen a login cuando usuario no autenticado, probar navegación entre rutas funciona correctamente, validar manejo de rutas no encontradas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar deep linking para notificaciones push",
            "description": "Configurar handlers para deep links desde notificaciones OneSignal con rutas específicas",
            "dependencies": [
              1
            ],
            "details": "Configurar deep linking handlers para notificaciones: fast_milestone -> /fasting/progress, hydration_reminder -> /hydration, learning_content -> /learning/articles/:id. Implementar manejo de parámetros en URLs y navegación automática desde notificaciones. Configurar refresh listener que detecte cambios en authState.",
            "status": "done",
            "testStrategy": "Probar deep links funcionan desde notificaciones push simuladas, verificar navegación automática con parámetros correctos, validar manejo de estado de autenticación",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar Universal Links (iOS) y App Links (Android)",
            "description": "Establecer configuración de enlaces profundos nativos para dominio zendfast.app",
            "dependencies": [
              2
            ],
            "details": "Configurar Universal Links para iOS con apple-app-site-association en dominio zendfast.app. Configurar App Links para Android con assetlinks.json. Implementar manejo nativo de enlaces desde navegadores y otras aplicaciones. Configurar verificación de dominio y certificados.",
            "status": "done",
            "testStrategy": "Validar Universal Links y App Links mediante adb y simulador iOS, probar enlaces funcionan desde navegadores móviles, verificar apertura automática de la aplicación",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar navegación tipo-segura con go_router extensions",
            "description": "Crear sistema de navegación con tipos seguros y rutas nombradas para toda la aplicación",
            "dependencies": [
              1
            ],
            "details": "Implementar typed navigation con rutas nombradas y parámetros tipo-seguro usando go_router extensions. Crear clases de navegación que garanticen tipos correctos en tiempo de compilación. Agregar métodos helper para navegación común y manejo de parámetros. Configurar redirecciones automáticas basadas en estado de autenticación.",
            "status": "done",
            "testStrategy": "Confirmar navegación tipo-segura compila sin errores de tipos, probar redirecciones automáticas funcionan correctamente, validar parámetros se pasan correctamente entre rutas",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on configurar go_router con guards de autenticación y deep linking completo."
      },
      {
        "id": 57,
        "title": "Implementar sistema completo de analytics y tracking de eventos en analytics_events de Supabase",
        "description": "Desarrollar un sistema robusto de analytics que rastree eventos críticos del usuario, implemente embudo de conversión, métricas de retención y sincronización offline/online",
        "details": "Crear AnalyticsService que maneje tracking de eventos críticos: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown, app_opened, user_registered. Implementar AnalyticsEvent model con fields: id, user_id, event_name, properties (JSON), timestamp, session_id, platform, app_version. Crear AnalyticsRepository con Isar para storage offline y sync automático con analytics_events table en Supabase. Implementar FunnelAnalytics class para trackear conversion funnel: registration → first_fast → fast_completion → premium_trial → premium_conversion. Desarrollar RetentionMetrics para calcular day 1, 7, 30 retention rates. Crear EngagementMetrics para session duration, feature usage frequency, panic button correlation. Implementar EventBatcher para optimizar network requests enviando eventos en batch cada 30 segundos o 10 eventos. Agregar offline queue con retry logic para eventos fallidos. Crear AnalyticsDashboard widget para visualizar métricas key con charts usando fl_chart package. Implementar privacy-compliant tracking sin PII, hash user identifiers. Configurar automated funnel analysis con cohort tracking mensual.",
        "testStrategy": "Verificar todos los eventos críticos se registran correctamente tanto online como offline. Probar sincronización automática funciona tras reconexión. Validar embudo de conversión calcula métricas precisas. Verificar retención y engagement metrics son exactos comparando con data manual. Probar performance del EventBatcher bajo carga alta. Validar privacy compliance verificando no se almacena PII. Testear dashboard muestra visualizaciones correctas. Verificar eventos persisten tras force-close de app.",
        "status": "pending",
        "dependencies": [
          "48",
          "52"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar servicio base de analytics y modelo de eventos",
            "description": "Crear AnalyticsService principal que maneje tracking de eventos críticos del usuario y implementar modelo AnalyticsEvent con campos necesarios para almacenamiento local y remoto",
            "dependencies": [],
            "details": "Desarrollar AnalyticsService con métodos para trackear eventos: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown, app_opened, user_registered. Implementar AnalyticsEvent model con campos: id, user_id, event_name, properties (JSON), timestamp, session_id, platform, app_version. Configurar privacy-compliant tracking sin PII, hash user identifiers. Establecer base para dependency injection con Riverpod.",
            "status": "pending",
            "testStrategy": "Verificar todos los eventos críticos se registran correctamente con timestamps precisos. Probar hash de user identifiers funciona apropiadamente. Validar estructura JSON properties es correcta para cada tipo de evento.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar métricas de funnel y retención",
            "description": "Implementar clases especializadas para calcular métricas de conversión, análisis de embudo y tasas de retención de usuarios",
            "dependencies": [
              1
            ],
            "details": "Crear FunnelAnalytics class para trackear conversion funnel: registration → first_fast → fast_completion → premium_trial → premium_conversion. Desarrollar RetentionMetrics para calcular day 1, 7, 30 retention rates con cohort tracking mensual. Implementar EngagementMetrics para session duration, feature usage frequency, panic button correlation. Configurar automated funnel analysis con algoritmos de cálculo eficientes.",
            "status": "pending",
            "testStrategy": "Validar embudo de conversión calcula métricas precisas comparando con data de prueba manual. Verificar retención y engagement metrics son exactos. Probar cohort analysis funciona correctamente con diferentes rangos de fechas.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar sistema de batching y sincronización offline",
            "description": "Desarrollar AnalyticsRepository con almacenamiento local Isar y sistema de sincronización automática con Supabase incluyendo cola offline y retry logic",
            "dependencies": [
              1
            ],
            "details": "Crear AnalyticsRepository con Isar para storage offline y sync automático con analytics_events table en Supabase. Implementar EventBatcher para optimizar network requests enviando eventos en batch cada 30 segundos o 10 eventos. Agregar offline queue con retry logic para eventos fallidos. Configurar background sync que funcione cuando app vuelve a estar online. Implementar conflict resolution para eventos duplicados.",
            "status": "pending",
            "testStrategy": "Probar sincronización automática funciona tras reconexión a internet. Verificar eventos se almacenan correctamente offline. Validar batching optimiza requests de red. Probar retry logic maneja fallos de red apropiadamente.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Crear dashboard de visualización de métricas",
            "description": "Desarrollar AnalyticsDashboard widget con charts interactivos para visualizar métricas clave usando fl_chart package",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear AnalyticsDashboard widget para visualizar métricas key con charts usando fl_chart package. Implementar gráficos para funnel conversion, retention curves, engagement trends, y event frequency. Agregar filtros por fecha range y tipo de evento. Crear widgets específicos para mostrar KPIs principales: DAU, conversion rate, average session duration. Implementar responsive design que funcione en diferentes tamaños de pantalla.",
            "status": "pending",
            "testStrategy": "Verificar charts se renderizan correctamente con data real. Probar interactividad de filtros funciona apropiadamente. Validar responsive design en diferentes dispositivos. Confirmar performance es buena con datasets grandes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema completo de analytics y tracking de eventos en analytics_events de supabase."
      },
      {
        "id": 58,
        "title": "Implementar features de GDPR compliance incluyendo exportación de datos del usuario, eliminación completa de cuenta con cascada en todas las tablas relacionadas, gestión de consentimientos explícitos, política de privacidad accesible, y cumplimiento con CCPA",
        "description": "Desarrollar sistema completo de cumplimiento GDPR/CCPA con exportación de datos, eliminación en cascada, gestión de consentimientos y política de privacidad para ejercer derechos de privacidad desde el perfil del usuario",
        "details": "Implementar DataPrivacyService con exportUserData() que genere JSON/CSV de FastingSession, UserProfile, HydrationLog y ContentItem favoritos. Crear AccountDeletionService con deleteUserAccount() que ejecute cascada en Supabase (user_profiles, fasting_sessions, hydration_logs, analytics_events) y Isar local. Desarrollar ConsentManager con toggles para analytics tracking, marketing communications, data processing con storage en user_consents table. Crear PrivacyPolicyScreen accesible desde Settings con texto actualizable desde Supabase. Implementar DataRightsScreen en UserProfile con botones: 'Exportar mis datos', 'Eliminar cuenta permanentemente', 'Gestionar consentimientos'. Para CCPA: agregar 'Do Not Sell My Data' toggle. Usar flutter_file_saver para export downloads. Implementar confirmación multi-step para account deletion con password verification. Asegurar compliance con retention periods y audit logging.",
        "testStrategy": "Verificar exportación genera archivo completo con todos los datos del usuario, probar eliminación en cascada no deja datos huérfanos en ninguna tabla, validar consentimientos se persisten correctamente y afectan funcionalidad, confirmar política de privacidad se actualiza dinámicamente, testear flujo completo de eliminación de cuenta requiere confirmación de contraseña",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "48"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar DataPrivacyService con exportación completa de datos del usuario",
            "description": "Desarrollar servicio para exportar todos los datos del usuario en formatos JSON/CSV incluyendo sesiones de ayuno, perfil, logs de hidratación y contenido favorito",
            "dependencies": [],
            "details": "Crear DataPrivacyService con método exportUserData() que consulte todas las tablas relacionadas (FastingSession, UserProfile, HydrationLog, ContentItem favoritos) tanto de Supabase como Isar local. Generar archivos JSON estructurado y CSV para facilitar lectura. Usar flutter_file_saver para permitir descarga. Incluir metadatos como fecha de exportación y versión de datos. Implementar compresión ZIP si el archivo es grande.",
            "status": "done",
            "testStrategy": "Verificar que la exportación incluye todos los datos del usuario sin omisiones, probar generación correcta de archivos JSON/CSV, validar descarga funciona en diferentes dispositivos, confirmar estructura de datos es completa y legible",
            "updatedAt": "2025-10-31T20:44:42.437Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar AccountDeletionService con eliminación en cascada completa",
            "description": "Implementar servicio de eliminación de cuenta que ejecute cascada segura en todas las tablas relacionadas tanto en Supabase como almacenamiento local",
            "dependencies": [
              1
            ],
            "details": "Crear AccountDeletionService con deleteUserAccount() que elimine datos en orden correcto: primero tablas dependientes (fasting_sessions, hydration_logs, analytics_events) luego user_profiles en Supabase. Limpiar datos locales en Isar. Implementar transacciones para asegurar atomicidad. Agregar logs de auditoría antes de eliminación. Implementar verificación multi-step con confirmación de contraseña y período de gracia de 30 días.",
            "status": "done",
            "testStrategy": "Probar eliminación no deja datos huérfanos en ninguna tabla, verificar transacciones son atómicas, validar logs de auditoría se crean correctamente, confirmar verificación de contraseña funciona, testear período de gracia permite recuperación",
            "parentId": "undefined",
            "updatedAt": "2025-10-31T20:44:50.505Z"
          },
          {
            "id": 3,
            "title": "Crear ConsentManager con gestión granular de consentimientos GDPR/CCPA",
            "description": "Desarrollar sistema de gestión de consentimientos con toggles granulares para diferentes tipos de procesamiento de datos y cumplimiento legal",
            "dependencies": [],
            "details": "Implementar ConsentManager con storage en tabla user_consents. Crear toggles para: analytics tracking, marketing communications, data processing, cookies no esenciales. Para CCPA agregar 'Do Not Sell My Data' toggle. Implementar versioning de consentimientos para trackear cambios. Crear ConsentScreen con explicaciones claras de cada permiso. Integrar con analytics providers para respetar preferencias. Asegurar defaults cumplen con GDPR (opt-in required).",
            "status": "done",
            "testStrategy": "Verificar consentimientos se persisten correctamente en base de datos, probar toggles afectan funcionalidad apropiadamente, validar versioning funciona para auditoría, confirmar defaults cumplen GDPR, testear integración con providers de analytics",
            "parentId": "undefined",
            "updatedAt": "2025-10-31T20:44:53.019Z"
          },
          {
            "id": 4,
            "title": "Implementar PrivacyPolicyScreen y DataRightsScreen con flujos completos",
            "description": "Crear pantallas de política de privacidad dinámica y ejercicio de derechos de datos con todos los flujos de confirmación requeridos",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear PrivacyPolicyScreen que cargue contenido desde Supabase (tabla privacy_policy) para actualizaciones dinámicas. Implementar DataRightsScreen accesible desde UserProfile con botones: 'Exportar mis datos', 'Eliminar cuenta permanentemente', 'Gestionar consentimientos'. Crear flujos de confirmación multi-step para eliminación de cuenta. Agregar enlaces a políticas desde Settings. Implementar notificaciones cuando políticas cambien. Asegurar accesibilidad y claridad legal.",
            "status": "done",
            "testStrategy": "Verificar política de privacidad se actualiza dinámicamente desde Supabase, probar todos los botones de derechos funcionan correctamente, validar flujos de confirmación previenen eliminaciones accidentales, confirmar accesibilidad desde Settings, testear notificaciones de cambios en políticas",
            "parentId": "undefined",
            "updatedAt": "2025-10-31T20:44:55.353Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar features de gdpr compliance incluyendo exportación de datos del usuario, eliminación completa de cuenta con cascada en todas las tablas relacionadas, gestión de consentimientos explícitos, política de privacidad accesible, y cumplimiento con ccpa.",
        "updatedAt": "2025-10-31T20:44:55.353Z"
      },
      {
        "id": 59,
        "title": "Implementar sistema de estado global UI para Loading, Error y Empty states",
        "description": "Desarrollar sistema integral de estados UI consistente con widgets reutilizables LoadingState, ErrorState y EmptyState, providers Riverpod para gestión global, y cumplimiento WCAG 2.1 AA en toda la aplicación",
        "details": "Crear archivo lib/widgets/ui_states/loading_state.dart con widget LoadingState que use CircularProgressIndicator con colores ZendfastColors.primary, animaciones ZendfastAnimations.standard, y texto descriptivo opcional. Implementar lib/widgets/ui_states/error_state.dart con ErrorState que muestre ícono de error, mensaje personalizable, botón retry opcional con PrimaryButton style, y colores semánticos ZendfastColors.error. Desarrollar lib/widgets/ui_states/empty_state.dart con EmptyState siguiendo patrón existente del Frontend Guidelines pero extendido con ilustraciones opcionales, acciones múltiples, y variantes para diferentes contextos (no data, no results, offline). Crear lib/providers/ui_state_provider.dart con Riverpod StateNotifierProvider para gestionar estados globales: isLoading, errorMessage, isEmpty con métodos setLoading(), setError(), setEmpty(), clearState(). Implementar lib/widgets/ui_states/adaptive_state_wrapper.dart que combine los tres estados y los muestre automáticamente basado en provider state. Asegurar cumplimiento WCAG 2.1 AA: contrastaratio mínimo 4.5:1, Semantics labels, touch targets 44dp mínimo, support para screen readers con announcements, y text scaling compatible. Integrar con sistema de colores ZendfastColors, tipografía ZendfastTypography, y espaciado ZendfastSpacing existentes. Proporcionar examples de uso con diferentes servicios (auth, timer, database) y documentar patterns de implementación.",
        "testStrategy": "Verificar contraste WCAG 2.1 AA con color contrast analyzer en todos los estados, probar con TalkBack/VoiceOver para validar screen reader announcements, verificar touch targets cumplen 44dp mínimo, probar scaling de texto hasta 200% sin overflow, validar estados se muestran correctamente en diferentes tamaños de pantalla, testear transiciones entre estados son fluidas y accesibles, verificar providers actualizan UI reactivamente, probar retry actions funcionan correctamente, validar empty states muestran acciones apropiadas según contexto",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear widgets base de estado UI con cumplimiento WCAG",
            "description": "Implementar LoadingState, ErrorState y EmptyState widgets con contraste mínimo 4.5:1, touch targets 44dp, labels semánticos y compatibilidad con lectores de pantalla",
            "dependencies": [],
            "details": "Crear lib/widgets/ui_states/loading_state.dart con CircularProgressIndicator usando ZendfastColors.primary y animaciones ZendfastAnimations.standard. Implementar lib/widgets/ui_states/error_state.dart con ícono de error, mensaje personalizable y botón retry usando PrimaryButton. Desarrollar lib/widgets/ui_states/empty_state.dart con ilustraciones opcionales y acciones múltiples. Asegurar cumplimiento WCAG 2.1 AA con contrast ratio mínimo 4.5:1, Semantics labels apropiados, touch targets de 44dp mínimo y soporte para screen readers con announcements.",
            "status": "done",
            "testStrategy": "Verificar contraste WCAG 2.1 AA con color contrast analyzer, probar con TalkBack/VoiceOver para validar announcements, verificar touch targets cumplen 44dp mínimo, probar scaling de texto hasta 200%",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar providers Riverpod para gestión global de estados",
            "description": "Desarrollar sistema de gestión de estado global usando Riverpod para coordinar estados de loading, error y empty en toda la aplicación",
            "dependencies": [
              1
            ],
            "details": "Crear lib/providers/ui_state_provider.dart con StateNotifierProvider para gestionar estados globales: isLoading, errorMessage, isEmpty. Implementar métodos setLoading(), setError(), setEmpty(), clearState() para transiciones de estado. Configurar notificaciones automáticas a widgets suscritos. Integrar con sistema de colores ZendfastColors, tipografía ZendfastTypography y espaciado ZendfastSpacing existentes.",
            "status": "done",
            "testStrategy": "Verificar estados se actualizan correctamente entre widgets, probar transiciones de estado fluidas, validar notificaciones automáticas funcionan",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Desarrollar wrapper adaptativo con integración completa",
            "description": "Crear AdaptiveStateWrapper que combine automáticamente los tres estados y proporcionar ejemplos de uso con diferentes servicios",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar lib/widgets/ui_states/adaptive_state_wrapper.dart que combine LoadingState, ErrorState y EmptyState mostrándolos automáticamente basado en provider state. Crear ejemplos de uso con diferentes servicios (auth, timer, database). Documentar patterns de implementación y mejores prácticas. Asegurar integración completa con sistema de diseño existente y proporcionar guías de uso para desarrolladores.",
            "status": "done",
            "testStrategy": "Probar wrapper muestra estados correctos automáticamente, verificar ejemplos funcionan con servicios reales, validar documentación está completa",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de estado global ui para loading, error y empty states."
      },
      {
        "id": 60,
        "title": "Implementar sistema de backup automático de datos con exportación periódica a Supabase Storage",
        "description": "Desarrollar sistema completo de backup automático diario para datos Isar locales con exportación cifrada a Supabase Storage y funcionalidad de restauración.",
        "details": "Crear BackupService singleton con métodos createBackup(), uploadToSupabase(), downloadBackup(), restoreFromBackup(). Implementar backup diario usando flutter_background_service scheduler que exporte todas las colecciones Isar (FastingSession, UserProfile, HydrationLog, ContentItem) a JSON. Cifrar backups usando dart:convert y crypto package con AES-256-GCM antes de upload a Supabase Storage bucket 'user-backups'. Structure: /backups/{userId}/{timestamp}_backup.json.encrypted. Implementar BackupManager con BackupMetadata model para tracking: timestamp, fileSize, collections, isEncrypted. Crear UI en settings para manual backup, restore, y download complete data (GDPR). Implementar conflict resolution para restore (user choice to overwrite/merge). Usar shared_preferences para backup schedule config y last backup timestamp. Agregar compression con gzip antes encryption para optimize storage.",
        "testStrategy": "Verificar backup automático se ejecuta diariamente, probar encryption/decryption de datos funciona correctamente, validar upload y download desde Supabase Storage exitoso, confirmar restauración completa no pierde datos, probar GDPR export genera JSON válido con todos los datos de usuario",
        "status": "pending",
        "dependencies": [
          "48",
          "49"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar BackupService con scheduling automático diario",
            "description": "Desarrollar servicio singleton para manejo de backups automáticos con scheduler en background que exporte datos Isar a JSON diariamente",
            "dependencies": [],
            "details": "Crear BackupService singleton con métodos createBackup(), scheduleAutomaticBackup(). Implementar flutter_background_service para ejecutar backup diario automático. Exportar todas las colecciones Isar (FastingSession, UserProfile, HydrationLog, ContentItem) a formato JSON. Usar shared_preferences para configurar horario de backup y guardar timestamp del último backup. Implementar compresión gzip de datos antes del cifrado para optimizar almacenamiento.",
            "status": "pending",
            "testStrategy": "Verificar que el backup automático se ejecuta correctamente cada 24 horas, probar que todas las colecciones Isar se exportan completamente a JSON, validar que la compresión gzip funciona y reduce el tamaño de archivos",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Desarrollar sistema de cifrado AES-256-GCM y upload a Supabase Storage",
            "description": "Implementar cifrado seguro de backups con AES-256-GCM y sistema de upload/download desde Supabase Storage con estructura organizada",
            "dependencies": [
              1
            ],
            "details": "Implementar cifrado AES-256-GCM usando crypto package para encriptar backups JSON comprimidos. Crear métodos uploadToSupabase() y downloadBackup() en BackupService. Configurar Supabase Storage bucket 'user-backups' con estructura /backups/{userId}/{timestamp}_backup.json.encrypted. Implementar BackupMetadata model para tracking de metadatos: timestamp, fileSize, collections incluidas, isEncrypted. Manejar autenticación y permisos de Supabase Storage.",
            "status": "pending",
            "testStrategy": "Probar que el cifrado AES-256-GCM funciona correctamente y los datos se pueden descifrar, verificar que el upload a Supabase Storage es exitoso con la estructura correcta, validar que los metadatos se guardan apropiadamente",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear UI de gestión de backups con restore y exportación GDPR",
            "description": "Desarrollar interfaz de usuario completa para gestión manual de backups, restauración de datos y exportación GDPR en configuraciones",
            "dependencies": [
              2
            ],
            "details": "Crear BackupManager para orchestrar operaciones UI. Implementar pantalla en settings con opciones: backup manual, restaurar desde backup, descargar datos completos (GDPR export). Desarrollar restoreFromBackup() con conflict resolution permitiendo al usuario elegir entre sobrescribir o fusionar datos. Crear UI intuitiva para mostrar backups disponibles, fechas, tamaños. Implementar progress indicators para operaciones largas. Agregar validación de integridad antes de restauración.",
            "status": "pending",
            "testStrategy": "Verificar que la UI permite realizar backups manuales correctamente, probar que la restauración funciona sin pérdida de datos, validar que la exportación GDPR genera JSON completo con todos los datos del usuario, confirmar que la resolución de conflictos funciona apropiadamente",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de backup automático de datos con exportación periódica a supabase storage."
      },
      {
        "id": 61,
        "title": "Implementar Edge Function 'calculate-user-metrics' en Supabase",
        "description": "Desarrollar función Edge Function en Supabase que calcule métricas de usuario incluyendo racha actual, horas totales de ayuno, tasa de éxito y efectividad del botón de pánico",
        "details": "Crear archivo supabase/functions/calculate-user-metrics/index.ts implementando la lógica definida en Backend Structure Document líneas 320-434. Incluir funciones utilitarias: calculateTotalHours() para sumar horas de ayunos completados, calculateCurrentStreak() para racha consecutiva de días, calculateSuccessRate() para porcentaje de ayunos exitosos, calculatePanicUsage() para efectividad del botón pánico cuando es usado. La función debe: 1) Validar entrada JSON con userId, 2) Conectar con Supabase usando SERVICE_ROLE_KEY, 3) Consultar fasting_sessions y hydration_logs del usuario, 4) Calcular todas las métricas usando las funciones helper, 5) Actualizar tabla user_metrics con resultados, 6) Implementar manejo de errores robusto con logging detallado, 7) Retornar respuesta JSON con métricas calculadas. Configurar deployment automático y testing con datos mock. Implementar rate limiting y validación de permisos para seguridad.",
        "testStrategy": "Crear tests unitarios para cada función de cálculo con datos mock variados. Probar Edge Function end-to-end con usuarios reales y datos de diferentes escenarios (sin datos, pocos ayunos, usuarios activos). Verificar manejo de errores para datos corruptos o faltantes. Validar performance con datasets grandes. Probar deployment y invocar desde Flutter app usando SupabaseConfig.functions. Confirmar actualización correcta de user_metrics table",
        "status": "pending",
        "dependencies": [
          "15",
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base del Edge Function calculate-user-metrics",
            "description": "Establecer la estructura inicial del Edge Function con configuración básica, validación de entrada y conexión a Supabase",
            "dependencies": [],
            "details": "Crear archivo supabase/functions/calculate-user-metrics/index.ts con estructura básica de Deno.serve(). Implementar validación de entrada JSON para userId requerido. Configurar conexión a Supabase usando createClient con SERVICE_ROLE_KEY. Implementar manejo básico de errores con try-catch y logging. Agregar headers CORS apropiados para respuestas. Configurar tipos TypeScript para request/response.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para validación de entrada con casos válidos e inválidos. Probar conexión a Supabase con credenciales mock. Verificar manejo de errores retorna códigos HTTP apropiados.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar funciones utilitarias de cálculo de métricas",
            "description": "Desarrollar las funciones helper para calcular todas las métricas de usuario: horas totales, racha actual, tasa de éxito y uso del pánico",
            "dependencies": [
              1
            ],
            "details": "Implementar calculateTotalHours() que sume duration de fasting_sessions completadas. Crear calculateCurrentStreak() que calcule días consecutivos de ayunos exitosos desde la fecha más reciente. Desarrollar calculateSuccessRate() que calcule porcentaje de ayunos completados vs iniciados. Implementar calculatePanicUsage() que analice efectividad del botón pánico correlacionando panic_button_used con session_completed. Incluir manejo de casos edge como usuarios sin datos o datos incompletos.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios exhaustivos para cada función con datasets variados: usuarios nuevos sin datos, usuarios con pocas sesiones, usuarios activos con historial largo. Probar casos edge como sesiones incompletas, datos corruptos y fechas inválidas.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar cálculos con base de datos y deployment",
            "description": "Conectar las funciones de cálculo con consultas a Supabase, actualizar tabla user_metrics y configurar deployment automático",
            "dependencies": [
              2
            ],
            "details": "Implementar consultas SQL para obtener fasting_sessions y hydration_logs del usuario especificado. Integrar las funciones de cálculo con los datos obtenidos. Crear/actualizar registros en tabla user_metrics con las métricas calculadas usando upsert. Implementar rate limiting para prevenir abuse. Agregar validación de permisos verificando que el usuario solo puede consultar sus propias métricas. Configurar deployment automático via Supabase CLI. Crear documentación de API con ejemplos de uso.",
            "status": "pending",
            "testStrategy": "Probar Edge Function end-to-end con usuarios reales en diferentes escenarios. Verificar rate limiting funciona correctamente. Validar security: usuarios no pueden acceder datos de otros. Probar deployment automático y rollback. Realizar load testing con múltiples requests concurrentes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'calculate-user-metrics' en supabase."
      },
      {
        "id": 62,
        "title": "Implementar Edge Function 'schedule-notifications' en Supabase para integración con OneSignal",
        "description": "Desarrollar función Edge Function en Supabase que programe notificaciones push personalizadas según el tipo de plan de ayuno del usuario y sus preferencias",
        "details": "Crear archivo supabase/functions/schedule-notifications/index.ts implementando la estructura definida en Backend Structure Document líneas 436-543. La función debe: 1) Recibir parámetros userId, sessionId, planType via POST request, 2) Validar entrada JSON y autenticación, 3) Consultar user_profiles para obtener notification_preferences y timezone, 4) Generar schedule de notificaciones basado en planType: inicio/fin de ayuno, recordatorios de hidratación cada 2-3h, mensajes motivacionales cada 4-6h, contenido educativo personalizado, 5) Integrar con OneSignal REST API v1 usando include_external_user_ids para targeting, 6) Programar notificaciones con send_after timestamp respetando user timezone, 7) Implementar lógica para cancelar notificaciones existentes si fast es interrumpido, 8) Manejar diferentes templates según planType (16:8, 18:6, OMAD, 24h), 9) Incluir data payload para deep linking (type: fasting_start/end/hydration/motivation), 10) Error handling robusto con logs structured y response codes apropiados",
        "testStrategy": "Crear tests unitarios para generateNotificationSchedule() con diferentes planTypes y user preferences. Probar Edge Function end-to-end con usuarios mock y verificar llamadas OneSignal API correctas. Validar timezone handling para diferentes regiones. Probar error scenarios: user sin notificaciones habilitadas, OneSignal API down, invalid input data. Verificar que notifications se cancelan correctamente cuando fast es interrumpido. Test integration con user_profiles table y RLS policies. Validar deep link data estructura es correcta para routing",
        "status": "pending",
        "dependencies": [
          "5",
          "47"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de la Edge Function schedule-notifications",
            "description": "Implementar la estructura básica del archivo index.ts con validación de entrada, autenticación y manejo de errores inicial",
            "dependencies": [],
            "details": "Crear archivo supabase/functions/schedule-notifications/index.ts con estructura base: importar dependencias necesarias (Supabase client, OneSignal), implementar función principal serve() que maneje POST requests, validar parámetros de entrada (userId, sessionId, planType), implementar autenticación JWT, configurar manejo básico de errores con response codes apropiados y logging estructurado",
            "status": "pending",
            "testStrategy": "Crear tests para validación de parámetros de entrada, autenticación JWT y respuestas de error apropiadas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de generación de schedules de notificaciones",
            "description": "Desarrollar la lógica central que genera schedules personalizados de notificaciones basados en planType y preferencias del usuario",
            "dependencies": [
              1
            ],
            "details": "Implementar función generateNotificationSchedule() que: consulte user_profiles para obtener notification_preferences y timezone, genere schedules específicos por planType (16:8, 18:6, OMAD, 24h) incluyendo notificaciones de inicio/fin de ayuno, recordatorios de hidratación cada 2-3h, mensajes motivacionales cada 4-6h, contenido educativo personalizado, calcule timestamps usando timezone del usuario y respete las preferencias de notificación",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para generateNotificationSchedule() con diferentes planTypes, user preferences y timezones para verificar cálculos correctos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar con OneSignal API y programar notificaciones",
            "description": "Implementar la integración completa con OneSignal REST API v1 para envío y programación de notificaciones push",
            "dependencies": [
              2
            ],
            "details": "Implementar integración con OneSignal REST API v1: configurar autenticación con API key, usar include_external_user_ids para targeting específico, programar notificaciones con send_after timestamp, incluir templates diferenciados por planType, agregar data payload para deep linking (type: fasting_start/end/hydration/motivation), implementar lógica para cancelar notificaciones existentes si ayuno es interrumpido, manejar respuestas de API y errores de red apropiadamente",
            "status": "pending",
            "testStrategy": "Probar integración end-to-end con OneSignal API usando usuarios mock, verificar scheduling correcto y cancelación de notificaciones existentes",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'schedule-notifications' en supabase para integración con onesignal."
      },
      {
        "id": 63,
        "title": "Implementar Edge Function 'sync-user-data' en Supabase para sincronización bidireccional",
        "description": "Desarrollar función Edge Function en Supabase que sincronice bidireccionalmente datos entre base de datos local Isar y Supabase con resolución de conflictos, batch sync y manejo de errores de red.",
        "details": "Crear archivo supabase/functions/sync-user-data/index.ts implementando la lógica definida en Backend Structure Document líneas 547-618. La función debe: 1) Implementar endpoint POST que reciba array de cambios locales con estructura {table: string, action: 'insert'|'update'|'delete', data: object, localTimestamp: string}, 2) Implementar resolución de conflictos usando timestamp más reciente (last-write-wins) comparando createdAt/updatedAt entre datos locales y remotos, 3) Sincronizar tablas: fasting_sessions (startTime, endTime, completed, interrupted, planType), hydration_logs (amountMl, timestamp), user_metrics (streak, totalHours, successRate), 4) Implementar batch processing para procesar hasta 100 registros por request, 5) Retornar estructura {success: boolean, conflicts: array, serverChanges: array, errors: array} con cambios del servidor que el cliente debe aplicar, 6) Manejar errores de red con retry exponential backoff, timeouts de 30 segundos, y logging detallado, 7) Validar autenticación usando JWT del header Authorization, 8) Implementar rate limiting (100 requests/minuto por usuario), 9) Usar transacciones de base de datos para operaciones atómicas. Estructura de respuesta debe incluir timestamp del servidor para próximas sincronizaciones incrementales.",
        "testStrategy": "Crear tests unitarios para resolución de conflictos con diferentes scenarios de timestamp. Probar Edge Function end-to-end con datos de FastingSession, HydrationLog y user_metrics simulando casos de conflicto, batch sync de 50+ registros, errores de red y timeouts. Verificar autenticación correcta con tokens JWT válidos/inválidos. Validar rate limiting funciona correctamente. Probar transacciones rollback en caso de errores. Verificar sincronización bidireccional completa con cliente Flutter usando SupabaseConfig.functions.",
        "status": "pending",
        "dependencies": [
          "15",
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base y configuración de Edge Function sync-user-data",
            "description": "Establecer la estructura inicial del archivo index.ts y configurar el endpoint POST para recibir datos de sincronización",
            "dependencies": [],
            "details": "Crear archivo supabase/functions/sync-user-data/index.ts con estructura base de Deno Edge Function. Configurar endpoint POST que valide JWT del header Authorization, implemente rate limiting (100 requests/minuto por usuario), y establezca estructura de entrada para array de cambios locales con formato {table: string, action: 'insert'|'update'|'delete', data: object, localTimestamp: string}. Configurar timeouts de 30 segundos y logging detallado para debugging.",
            "status": "pending",
            "testStrategy": "Probar autenticación JWT, validar rate limiting con múltiples requests, verificar manejo de timeouts y estructura de entrada correcta",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de resolución de conflictos y procesamiento por lotes",
            "description": "Desarrollar algoritmo de resolución de conflictos usando timestamps y sistema de batch processing para hasta 100 registros",
            "dependencies": [
              1
            ],
            "details": "Implementar resolución de conflictos usando estrategia last-write-wins comparando createdAt/updatedAt entre datos locales y remotos. Crear sistema de batch processing que procese hasta 100 registros por request con transacciones atómicas de base de datos. Manejar sincronización para tablas fasting_sessions, hydration_logs y user_metrics con sus campos específicos. Implementar retry con exponential backoff para errores de red.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para diferentes scenarios de conflictos por timestamp, probar batch processing con 50+ registros, validar transacciones atómicas",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar respuesta estructurada y cambios del servidor",
            "description": "Desarrollar sistema de respuesta que incluya conflictos detectados, cambios del servidor y timestamp para sincronizaciones incrementales",
            "dependencies": [
              2
            ],
            "details": "Implementar estructura de respuesta {success: boolean, conflicts: array, serverChanges: array, errors: array} que incluya cambios del servidor que el cliente debe aplicar localmente. Agregar timestamp del servidor para facilitar sincronizaciones incrementales futuras. Manejar y reportar errores detalladamente en el array de errors. Asegurar que todos los cambios del servidor se incluyan en serverChanges para mantener consistencia bidireccional.",
            "status": "pending",
            "testStrategy": "Verificar estructura de respuesta correcta, probar que serverChanges incluye todos los cambios necesarios, validar timestamp del servidor para sync incremental",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'sync-user-data' en supabase para sincronización bidireccional."
      },
      {
        "id": 64,
        "title": "Implementar Edge Function 'handle-superwall-webhook' en Supabase para procesar webhooks de Superwall",
        "description": "Desarrollar función Edge Function en Supabase que procese webhooks de Superwall para actualizar estado de suscripción del usuario, trackear conversiones y manejar eventos de renovación/cancelación con sincronización a tabla user_profiles.",
        "details": "Crear archivo supabase/functions/handle-superwall-webhook/index.ts implementando la lógica definida en Backend Structure Document líneas 1148-1202. La función debe: 1) Implementar endpoint POST que reciba webhooks de Superwall con estructura SuperwallWebhook interface incluyendo event_type ('subscription_started' | 'subscription_cancelled' | 'subscription_renewed'), user_id, product_id ('monthly_premium' | 'yearly_premium') y transaction_data, 2) Validar firma de webhook usando crypto.subtle API para verificar autenticidad del request con secret compartido, 3) Actualizar tabla user_profiles con campos subscription_status, subscription_type y subscription_expires_at basado en el event_type recibido, 4) Insertar eventos en tabla analytics_events para tracking de conversiones con event_type 'subscription_converted', 'subscription_cancelled', 'subscription_renewed', 5) Implementar manejo robusto de errores con logging detallado de eventos procesados y fallos, 6) Configurar CORS headers apropiados para permitir requests desde Superwall servers, 7) Retornar respuestas HTTP adecuadas (200 para éxito, 400/401 para errores) en formato JSON, 8) Implementar rate limiting básico para prevenir abuse, 9) Usar createClient con SUPABASE_SERVICE_ROLE_KEY para operaciones administrativas en user_profiles.",
        "testStrategy": "Crear tests unitarios para validación de firma de webhook con diferentes payloads y secrets. Probar Edge Function end-to-end con webhooks mock de Superwall simulando todos los event_types (started, cancelled, renewed). Verificar actualización correcta de user_profiles y inserción en analytics_events para cada tipo de evento. Validar manejo de errores para webhooks inválidos, firmas incorrectas y usuarios inexistentes. Probar rate limiting y CORS headers. Usar herramientas como ngrok para testing con webhooks reales de Superwall durante desarrollo.",
        "status": "pending",
        "dependencies": [
          "31"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura de proyecto y definir interfaces TypeScript",
            "description": "Establecer la estructura base del Edge Function y definir todas las interfaces TypeScript necesarias para manejar webhooks de Superwall",
            "dependencies": [],
            "details": "Crear directorio supabase/functions/handle-superwall-webhook/ con archivo index.ts. Definir interface SuperwallWebhook con campos event_type ('subscription_started' | 'subscription_cancelled' | 'subscription_renewed'), user_id, product_id ('monthly_premium' | 'yearly_premium') y transaction_data. Configurar imports necesarios para Supabase Edge Runtime incluyendo createClient y crypto APIs. Establecer estructura básica del handler HTTP con manejo de método POST.",
            "status": "pending",
            "testStrategy": "Verificar que las interfaces TypeScript compilen correctamente y que la estructura del proyecto siga las convenciones de Supabase Edge Functions",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar validación de firma de webhook y autenticación",
            "description": "Desarrollar el sistema de validación de firma usando crypto.subtle API para verificar la autenticidad de los webhooks de Superwall",
            "dependencies": [
              1
            ],
            "details": "Implementar función validateWebhookSignature() usando crypto.subtle.importKey() y crypto.subtle.verify() con algoritmo HMAC-SHA256. Extraer signature del header x-superwall-signature del request. Crear función para comparar firmas de forma segura usando crypto.timingSafeEqual(). Configurar manejo de errores para firmas inválidas retornando HTTP 401. Implementar logging detallado para intentos de validación fallidos.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios con payloads válidos e inválidos, diferentes secrets y firmas manipuladas para verificar robustez del sistema de validación",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Procesar eventos de webhook y actualizar base de datos",
            "description": "Implementar la lógica de procesamiento de eventos para actualizar user_profiles y registrar analytics según el tipo de evento recibido",
            "dependencies": [
              2
            ],
            "details": "Crear función processWebhookEvent() que maneje cada event_type: subscription_started actualiza subscription_status='active', subscription_type basado en product_id, subscription_expires_at calculado desde transaction_data; subscription_cancelled establece status='cancelled' preservando expires_at; subscription_renewed actualiza expires_at y mantiene status='active'. Usar createClient con SUPABASE_SERVICE_ROLE_KEY para operaciones administrativas. Insertar eventos correspondientes en analytics_events con metadatos del webhook. Implementar transacciones para consistencia de datos.",
            "status": "pending",
            "testStrategy": "Probar cada tipo de evento con datos mock verificando actualizaciones correctas en user_profiles y inserción en analytics_events. Validar rollback en caso de errores durante transacciones",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'handle-superwall-webhook' en supabase para procesar webhooks de superwall."
      },
      {
        "id": 65,
        "title": "Implementar Edge Function 'backup-data' en Supabase para respaldos automáticos diarios",
        "description": "Desarrollar función Edge Function en Supabase que realice respaldos automáticos diarios de datos críticos de usuario con compresión, encriptación y retención de 30 días",
        "details": "Crear archivo supabase/functions/backup-data/index.ts implementando la lógica definida en Backend Structure Document líneas 1114-1141. La función debe: 1) Implementar endpoint GET/POST que ejecute función PostgreSQL backup_critical_data() para extraer datos de fasting_sessions, user_profiles, hydration_logs de últimas 24 horas, 2) Comprimir datos usando gzip/deflate antes del almacenamiento para optimizar espacio, 3) Encriptar backup usando AES-256 con key derivada de BACKUP_ENCRYPTION_KEY environment variable, 4) Subir archivo encriptado a almacenamiento externo (AWS S3/Supabase Storage) con naming convention: backup_YYYYMMDD_HHMMSS.json.gz.enc, 5) Implementar política de retención automática eliminando backups >30 días, 6) Registrar evento en system_logs table con status y tamaño del backup, 7) Configurar notificación vía OneSignal/email en caso de fallos usando existing notification service, 8) Implementar rate limiting para prevenir ejecución múltiple simultánea, 9) Validar autenticación service role para security. Usar librerías: crypto-js para encriptación, node-gzip para compresión. Configurar como cron job diario via Supabase pg_cron extension.",
        "testStrategy": "Crear tests unitarios para funciones de compresión, encriptación y upload con datos mock. Probar Edge Function end-to-end simulando backup completo con datos reales de desarrollo. Verificar política de retención elimina archivos antiguos correctamente. Probar notificaciones de fallo con scenarios de error simulados (falta storage access, encryption key inválida, timeout de conexión). Validar autenticación rechaza requests sin service role key. Performance test con datasets grandes (1000+ registros por tabla) para verificar timeout no excede 300 segundos. Probar ejecución programada via pg_cron funciona correctamente.",
        "status": "pending",
        "dependencies": [
          "15",
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base y endpoint Edge Function backup-data",
            "description": "Implementar archivo base supabase/functions/backup-data/index.ts con endpoint GET/POST y configuración inicial de la función Edge Function",
            "dependencies": [],
            "details": "Crear directorio supabase/functions/backup-data/ con index.ts. Implementar handler Deno.serve() que responda a métodos GET/POST. Configurar validación de autenticación service role para seguridad. Implementar rate limiting básico para prevenir ejecución múltiple simultánea. Configurar imports necesarios para crypto-js y node-gzip. Establecer estructura base de respuesta JSON con status y mensajes.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para validar endpoint responde correctamente. Probar autenticación service role funciona. Verificar rate limiting previene ejecuciones simultáneas.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar extracción, compresión y encriptación de datos",
            "description": "Desarrollar lógica para extraer datos críticos de PostgreSQL, comprimirlos con gzip y encriptarlos con AES-256",
            "dependencies": [
              1
            ],
            "details": "Implementar función executeBackup() que llame a backup_critical_data() PostgreSQL para extraer fasting_sessions, user_profiles, hydration_logs de últimas 24 horas. Usar node-gzip para comprimir datos JSON antes del almacenamiento. Implementar encriptación AES-256 usando crypto-js con key derivada de BACKUP_ENCRYPTION_KEY environment variable. Generar naming convention: backup_YYYYMMDD_HHMMSS.json.gz.enc.",
            "status": "pending",
            "testStrategy": "Probar extracción de datos con diferentes volúmenes. Verificar compresión reduce tamaño significativamente. Validar encriptación/desencriptación funciona correctamente con datos mock.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar almacenamiento, retención y notificaciones",
            "description": "Implementar subida a almacenamiento externo, política de retención de 30 días y notificaciones de fallos",
            "dependencies": [
              2
            ],
            "details": "Configurar upload de archivos encriptados a Supabase Storage con estructura organizada por fechas. Implementar política de retención automática que elimine backups >30 días ejecutándose en cada backup. Registrar eventos en system_logs table con status, tamaño del backup y timestamp. Configurar notificaciones vía OneSignal/email en caso de fallos usando servicio de notificaciones existente. Configurar como cron job diario via Supabase pg_cron extension.",
            "status": "pending",
            "testStrategy": "Probar upload a Supabase Storage funciona correctamente. Verificar política de retención elimina archivos antiguos. Validar notificaciones de fallo se envían apropiadamente. Probar configuración de cron job ejecuta diariamente.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'backup-data' en supabase para respaldos automáticos diarios."
      },
      {
        "id": 66,
        "title": "Implementar Edge Function 'track-analytics-event' en Supabase para registrar eventos de usuario en tabla analytics_events",
        "description": "Desarrollar función Edge Function en Supabase que registre eventos críticos de usuario (inicio/fin ayuno, botón pánico, conversiones paywall, interacción contenido) con batching, validación de esquema y rate limiting.",
        "details": "Crear archivo supabase/functions/track-analytics-event/index.ts implementando la lógica definida en Backend Structure Document líneas 1241-1271. La función debe: 1) Implementar endpoint POST que reciba eventos con estructura {userId, eventType, parameters, timestamp}, 2) Validar esquema de entrada usando Joi o similar validando tipos de eventos permitidos: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown, content_interaction, 3) Implementar rate limiting por usuario (máximo 100 eventos por minuto) usando Redis o in-memory store, 4) Implementar batching de eventos para optimizar inserts en analytics_events table - acumular eventos por 30 segundos antes de hacer batch insert, 5) Conectar con Supabase usando createClient() con SERVICE_ROLE_KEY para permisos completos, 6) Insertar eventos en tabla analytics_events con campos: user_id, event_type, event_data (JSON), timestamp, session_id (opcional), 7) Implementar manejo robusto de errores con logs específicos para debugging, 8) Agregar CORS headers para requests desde app Flutter, 9) Implementar autenticación verificando JWT token en Authorization header, 10) Opcional: integrar con Firebase Analytics usando sendToFirebaseAnalytics() helper. Estructura de respuesta: {success: boolean, message?: string, eventId?: string}. La función debe ser eficiente y manejar alta concurrencia de eventos.",
        "testStrategy": "Crear tests unitarios para validación de esquema, rate limiting y batching con datos mock variados. Probar Edge Function end-to-end simulando eventos reales desde app Flutter con diferentes tipos de eventos críticos. Verificar rate limiting funciona correctamente bloqueando requests excesivos. Probar batching accumula eventos y hace inserts bulk optimizados. Validar manejo de errores para requests malformados, tokens inválidos y límites excedidos. Verificar CORS headers permiten requests desde dominio app. Probar performance con alta carga de eventos simultáneos. Validar datos se insertan correctamente en analytics_events con estructura esperada.",
        "status": "pending",
        "dependencies": [
          "52",
          "15",
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura básica y validación de esquema para Edge Function track-analytics-event",
            "description": "Crear archivo supabase/functions/track-analytics-event/index.ts con estructura básica del endpoint POST, implementar validación de esquema usando Joi para validar tipos de eventos permitidos y estructura de entrada",
            "dependencies": [],
            "details": "Configurar Edge Function con Deno.serve() para recibir requests POST. Implementar validación de esquema con Joi validando: userId (string requerido), eventType (enum: fast_started, fast_completed, fast_interrupted, panic_button_used, meditation_completed, premium_conversion, paywall_shown, content_interaction), parameters (objeto opcional), timestamp (ISO string). Configurar CORS headers para requests desde Flutter app. Implementar manejo básico de errores y logging.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para validación de esquema con datos válidos e inválidos. Probar CORS headers funcionan correctamente. Verificar manejo de errores para payloads malformados.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar rate limiting y autenticación JWT para proteger la Edge Function",
            "description": "Desarrollar sistema de rate limiting por usuario (máximo 100 eventos por minuto) y verificación de JWT token en Authorization header para autenticación segura",
            "dependencies": [
              1
            ],
            "details": "Implementar rate limiting usando Map en memoria con cleanup automático cada 60 segundos, tracking de requests por userId. Configurar verificación JWT usando supabase.auth.getUser() con token del Authorization header. Implementar middleware para verificar autenticación antes de procesar eventos. Agregar logging específico para intentos de rate limiting y autenticación fallida.",
            "status": "pending",
            "testStrategy": "Probar rate limiting bloqueando requests excesivos (>100/min). Verificar autenticación rechaza tokens inválidos/expirados. Testear cleanup automático de rate limit cache funciona correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar batching de eventos y inserción en tabla analytics_events",
            "description": "Desarrollar sistema de batching que acumule eventos por 30 segundos antes de hacer batch insert en tabla analytics_events, con conexión Supabase usando SERVICE_ROLE_KEY",
            "dependencies": [
              2
            ],
            "details": "Configurar batch system con Map para acumular eventos por usuario durante 30 segundos. Implementar timer que ejecute batch insert cada 30s o cuando acumule 50+ eventos. Conectar con Supabase usando createClient() con SERVICE_ROLE_KEY para permisos completos. Insertar en analytics_events con campos: user_id, event_type, event_data (JSON), timestamp, session_id. Implementar retry logic para fallos de inserción y logging detallado.",
            "status": "pending",
            "testStrategy": "Probar batching acumula eventos correctamente durante 30s. Verificar batch insert funciona con múltiples eventos. Testear retry logic para fallos de conexión. Validar estructura de datos en analytics_events table.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'track-analytics-event' en supabase para registrar eventos de usuario en tabla analytics_events."
      },
      {
        "id": 67,
        "title": "Implementar Edge Function 'sentry-error-report' en Supabase para relay de errores a Sentry",
        "description": "Desarrollar función Edge Function en Supabase que capture errores de otras Edge Functions, formatee contexto y los reenvíe a Sentry con filtrado de información sensible, rate limiting y manejo robusto de errores.",
        "details": "Crear archivo supabase/functions/sentry-error-report/index.ts implementando la funcionalidad definida en Backend Structure Document líneas 1024-1050. La función debe: 1) Implementar endpoint POST que reciba estructura {error: string, userId: string, context: object, stackTrace?: string, functionName?: string, timestamp?: number}, 2) Validar entrada JSON y sanitizar datos sensibles eliminando campos como passwords, tokens, keys y PII usando allowlist approach, 3) Implementar rate limiting por usuario (máx 10 errores/minuto, 100 errores/hora) usando Map temporal o Redis, 4) Formatear payload para Sentry API incluyendo user.id, message, extra context, timestamp, platform: 'edge-function', environment basado en SUPABASE_ENV, 5) Enviar a Sentry vía fetch POST a https://sentry.io/api/YOUR_PROJECT_ID/store/ con headers X-Sentry-Auth correctos usando SENTRY_API_KEY, 6) Implementar circuit breaker pattern - si Sentry falla 5 veces consecutivas, pausar envíos por 5 minutos, 7) Logging structured con console.log para debugging local incluyendo error_id, user_id, sent_to_sentry boolean, 8) Manejo de errores del propio error handler retornando 500 pero sin causar loops infinitos, 9) Configurar CORS headers para permitir llamadas desde otras Edge Functions, 10) Incluir timeout de 10 segundos para requests a Sentry.",
        "testStrategy": "Crear tests unitarios para sanitización de datos sensibles con payloads que contengan passwords, tokens y PII. Probar rate limiting simulando múltiples requests rápidos del mismo usuario. Verificar circuit breaker pausando Sentry y enviando errores. Probar Edge Function end-to-end desde otras funciones simulando errores reales de calculate-user-metrics y sync-user-data. Validar formato correcto de payload Sentry y headers de autenticación. Probar manejo de errores internos sin causar recursión infinita. Verificar timeouts y logging structured funciona correctamente.",
        "status": "pending",
        "dependencies": [
          "61",
          "63"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura base de Edge Function y validación de entrada",
            "description": "Implementar la estructura inicial del archivo index.ts con endpoint POST, validación JSON y sanitización de datos sensibles",
            "dependencies": [],
            "details": "Crear archivo supabase/functions/sentry-error-report/index.ts con estructura Deno.serve básica. Implementar endpoint POST que valide estructura de entrada {error, userId, context, stackTrace?, functionName?, timestamp?}. Crear función sanitizeData() que elimine campos sensibles (passwords, tokens, keys, PII) usando allowlist approach. Configurar CORS headers para permitir llamadas desde otras Edge Functions.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para validación de entrada con payloads válidos e inválidos. Probar sanitización con objetos que contengan datos sensibles. Verificar CORS headers funcionan correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar rate limiting y circuit breaker pattern",
            "description": "Desarrollar sistema de rate limiting por usuario y circuit breaker para pausar envíos cuando Sentry falla",
            "dependencies": [
              1
            ],
            "details": "Implementar rate limiting usando Map temporal con límites de 10 errores/minuto y 100 errores/hora por usuario. Crear circuit breaker que pause envíos por 5 minutos después de 5 fallos consecutivos a Sentry. Incluir cleanup automático de Map para evitar memory leaks. Agregar logging structured para debugging.",
            "status": "pending",
            "testStrategy": "Probar rate limiting simulando múltiples requests rápidos del mismo usuario. Verificar circuit breaker pausando Sentry mock y enviando errores consecutivos. Validar cleanup de memoria funciona correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar envío a Sentry API con manejo de errores robusto",
            "description": "Implementar formateo de payload para Sentry y envío vía API con timeout y manejo de errores sin loops infinitos",
            "dependencies": [
              2
            ],
            "details": "Formatear payload para Sentry API incluyendo user.id, message, extra context, timestamp, platform 'edge-function', environment basado en SUPABASE_ENV. Implementar envío POST a https://sentry.io/api/YOUR_PROJECT_ID/store/ con headers X-Sentry-Auth usando SENTRY_API_KEY. Configurar timeout de 10 segundos. Manejar errores del propio error handler retornando 500 sin causar loops infinitos.",
            "status": "pending",
            "testStrategy": "Probar Edge Function end-to-end desde otras funciones simuladas. Verificar formateo correcto de payload Sentry. Validar timeout funciona y no hay loops infinitos en manejo de errores.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar edge function 'sentry-error-report' en supabase para relay de errores a sentry."
      },
      {
        "id": 68,
        "title": "Crear tabla 'analytics_events' en Supabase con tracking de eventos de usuario",
        "description": "Implementar tabla PostgreSQL analytics_events con campos especificados, políticas RLS por usuario, índices optimizados y particionamiento por fecha para tracking de eventos.",
        "details": "Crear migración SQL en Supabase para tabla analytics_events con campos: event_id (UUID PRIMARY KEY con gen_random_uuid()), user_id (UUID FK a auth.users), event_type (TEXT con CHECK constraint para valores válidos: 'fasting_started', 'fasting_completed', 'fasting_interrupted', 'panic_button_used', 'meditation_attempted', 'meditation_completed', 'hydration_logged', 'plan_changed', 'content_viewed', 'subscription_converted'), event_data (JSONB para datos flexibles), timestamp (TIMESTAMPTZ DEFAULT NOW()), session_id (TEXT). Implementar RLS con políticas: 'users_own_analytics_only' permitiendo solo acceso a eventos propios, 'admin_aggregate_analytics_only' para agregaciones. Crear índices: idx_analytics_events_user_type (user_id, event_type), idx_analytics_events_type_timestamp (event_type, timestamp). Implementar particionamiento por rango de fecha mensual usando PARTITION BY RANGE (timestamp) con particiones automáticas. Agregar trigger para actualización de updated_at. Configurar retention de 2 años para optimizar storage.",
        "testStrategy": "Verificar tabla creada correctamente con DESCRIBE analytics_events. Probar RLS policies con diferentes usuarios - confirmar users solo ven sus eventos. Validar CHECK constraints rechazando event_types inválidos. Probar inserción de eventos con diferentes tipos y verificar campos JSONB. Validar performance de queries con EXPLAIN ANALYZE en índices. Verificar particionamiento funciona creando eventos en diferentes meses. Probar retention policies eliminando datos antiguos correctamente.",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear migración SQL base para tabla analytics_events",
            "description": "Crear la migración SQL en Supabase que defina la estructura básica de la tabla analytics_events con todos los campos especificados",
            "dependencies": [],
            "details": "Crear migración SQL con CREATE TABLE analytics_events incluyendo: event_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, event_type TEXT NOT NULL con CHECK constraint para valores válidos ('fasting_started', 'fasting_completed', 'fasting_interrupted', 'panic_button_used', 'meditation_attempted', 'meditation_completed', 'hydration_logged', 'plan_changed', 'content_viewed', 'subscription_converted'), event_data JSONB DEFAULT '{}', timestamp TIMESTAMPTZ DEFAULT NOW(), session_id TEXT, updated_at TIMESTAMPTZ DEFAULT NOW(). Aplicar migración y verificar estructura.",
            "status": "done",
            "testStrategy": "Ejecutar DESCRIBE analytics_events y verificar todos los campos. Probar inserción básica y validar CHECK constraint rechaza valores inválidos en event_type.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar políticas RLS y sistema de permisos",
            "description": "Configurar Row Level Security con políticas para restringir acceso a eventos por usuario y permitir agregaciones para administradores",
            "dependencies": [
              1
            ],
            "details": "Habilitar RLS en tabla analytics_events con ALTER TABLE analytics_events ENABLE ROW LEVEL SECURITY. Crear política 'users_own_analytics_only' que permita SELECT, INSERT, UPDATE, DELETE solo para auth.uid() = user_id. Crear política 'admin_aggregate_analytics_only' para rol admin que permita SELECT para agregaciones sin acceso a datos individuales. Configurar grants apropiados para roles.",
            "status": "done",
            "testStrategy": "Probar con diferentes usuarios que solo pueden acceder a sus propios eventos. Verificar que usuarios no pueden ver eventos de otros. Validar políticas admin funcionan correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar índices optimizados y particionamiento por fecha",
            "description": "Implementar índices para consultas eficientes y particionamiento mensual automático con configuración de retención de 2 años",
            "dependencies": [
              2
            ],
            "details": "Crear índices: CREATE INDEX idx_analytics_events_user_type ON analytics_events (user_id, event_type) y CREATE INDEX idx_analytics_events_type_timestamp ON analytics_events (event_type, timestamp). Implementar particionamiento con PARTITION BY RANGE (timestamp), crear particiones mensuales automáticas usando pg_partman o similar. Configurar trigger para updated_at con función update_timestamp(). Establecer política de retención de 2 años para optimizar storage.",
            "status": "done",
            "testStrategy": "Verificar índices mejoran performance con EXPLAIN ANALYZE. Probar particionamiento funciona correctamente insertando eventos en diferentes meses. Validar trigger updated_at y políticas de retención.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear tabla 'analytics_events' en supabase con tracking de eventos de usuario."
      },
      {
        "id": 69,
        "title": "Crear tabla 'user_content_interactions' para rastrear interacciones con contenido educativo",
        "description": "Implementar tabla PostgreSQL/Supabase para rastrear interacciones de usuarios con contenido educativo incluyendo vistas, favoritos y contenido compartido",
        "details": "Crear tabla 'user_content_interactions' en Supabase con campos: interaction_id (UUID PRIMARY KEY), user_id (UUID FK a auth.users), content_id (UUID FK a learning_content), interaction_type (ENUM: 'viewed', 'favorited', 'shared', 'completed'), timestamp (TIMESTAMPTZ DEFAULT NOW()), time_spent_seconds (INTEGER), progress_percentage (INTEGER 0-100). Implementar constraint UNIQUE(user_id, content_id, interaction_type) para evitar duplicados. Configurar RLS policy 'Users can manage own content interactions' usando auth.uid() = user_id. Crear índices compuestos: idx_user_content_interactions_user_type (user_id, interaction_type), idx_user_content_interactions_content_type (content_id, interaction_type), idx_user_content_interactions_timestamp (timestamp DESC). Implementar trigger 'update_content_popularity_metrics' que actualice automáticamente campos popularity_score y interaction_count en tabla learning_content cuando se inserten/actualicen interacciones. Configurar función PL/pgSQL que calcule popularity_score basado en: views * 1 + favorites * 3 + shares * 5 + completions * 2. Implementar soft delete mediante campo 'deleted_at' para mantener historial de analytics. Agregar validaciones CHECK para progress_percentage (0-100) y time_spent_seconds (>= 0).",
        "testStrategy": "Verificar tabla se crea correctamente con todas las constraints y índices. Probar RLS policies bloquean acceso no autorizado entre usuarios diferentes. Validar trigger actualiza métricas de popularidad en learning_content automáticamente al insertar interacciones. Testear índices compuestos mejoran performance de queries por user_id y content_id. Verificar constraint UNIQUE previene duplicados de interaction_type por usuario/contenido. Probar soft delete preserva data para analytics. Validar cálculo de popularity_score es correcto con diferentes combinaciones de interacciones. Realizar load testing con 10000+ interacciones para verificar performance de índices.",
        "status": "done",
        "dependencies": [
          "3",
          "48"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear estructura de tabla user_content_interactions con campos y constraints",
            "description": "Implementar la estructura completa de la tabla user_content_interactions en Supabase con todos los campos necesarios, tipos de datos, claves primarias, foráneas y constraints de validación",
            "dependencies": [],
            "details": "Crear migración SQL para tabla user_content_interactions con campos: interaction_id (UUID PRIMARY KEY DEFAULT gen_random_uuid()), user_id (UUID FK REFERENCES auth.users), content_id (UUID FK REFERENCES learning_content), interaction_type (ENUM 'viewed', 'favorited', 'shared', 'completed'), timestamp (TIMESTAMPTZ DEFAULT NOW()), time_spent_seconds (INTEGER), progress_percentage (INTEGER). Implementar constraints: UNIQUE(user_id, content_id, interaction_type), CHECK progress_percentage BETWEEN 0 AND 100, CHECK time_spent_seconds >= 0. Agregar campo deleted_at TIMESTAMPTZ para soft delete.",
            "status": "done",
            "testStrategy": "Verificar tabla se crea correctamente con todos los campos y tipos de datos. Probar constraints UNIQUE evitan duplicados. Validar CHECK constraints rechazan valores inválidos para progress_percentage y time_spent_seconds. Verificar claves foráneas funcionan correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar índices compuestos y políticas RLS para rendimiento y seguridad",
            "description": "Implementar índices compuestos para optimizar consultas frecuentes y configurar políticas RLS para controlar acceso de usuarios a sus propias interacciones",
            "dependencies": [
              1
            ],
            "details": "Crear índices compuestos: idx_user_content_interactions_user_type (user_id, interaction_type), idx_user_content_interactions_content_type (content_id, interaction_type), idx_user_content_interactions_timestamp (timestamp DESC). Configurar política RLS 'Users can manage own content interactions' usando condición auth.uid() = user_id para SELECT, INSERT, UPDATE, DELETE. Habilitar RLS en la tabla con ALTER TABLE user_content_interactions ENABLE ROW LEVEL SECURITY.",
            "status": "done",
            "testStrategy": "Verificar índices mejoran performance de consultas frecuentes usando EXPLAIN ANALYZE. Probar políticas RLS bloquean acceso a interacciones de otros usuarios. Validar usuarios pueden crear, leer, actualizar y eliminar solo sus propias interacciones.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar trigger para actualizar métricas de popularidad automáticamente",
            "description": "Crear trigger y función PL/pgSQL que actualice automáticamente los campos popularity_score e interaction_count en la tabla learning_content cuando se registren nuevas interacciones",
            "dependencies": [
              1
            ],
            "details": "Crear función PL/pgSQL update_content_popularity_metrics() que calcule popularity_score usando fórmula: views * 1 + favorites * 3 + shares * 5 + completions * 2. Actualizar campos popularity_score e interaction_count en tabla learning_content basado en COUNT de interacciones por content_id. Implementar trigger update_content_popularity_metrics AFTER INSERT OR UPDATE OR DELETE ON user_content_interactions FOR EACH ROW que ejecute la función. Manejar casos de soft delete verificando deleted_at IS NULL.",
            "status": "done",
            "testStrategy": "Verificar trigger se ejecuta correctamente al insertar, actualizar y eliminar interacciones. Validar cálculo de popularity_score con diferentes combinaciones de interacciones. Probar performance del trigger con volumen alto de datos. Verificar soft deletes no afectan métricas incorrectamente.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear tabla 'user_content_interactions' para rastrear interacciones con contenido educativo."
      },
      {
        "id": 70,
        "title": "Crear tabla 'system_logs' en PostgreSQL/Supabase para logs de debugging del sistema",
        "description": "Implementar tabla system_logs con campos log_id, severity, service, message, metadata (JSONB) y timestamp, incluyendo política de retención de 90 días, índices optimizados y configuración sin RLS para acceso administrativo exclusivo",
        "details": "Crear migración SQL para tabla system_logs en Supabase con campos: log_id (UUID PRIMARY KEY con gen_random_uuid()), severity (ENUM con valores 'info', 'warning', 'error', 'critical'), service (ENUM con valores 'edge_function', 'database', 'auth'), message (TEXT NOT NULL), metadata (JSONB para datos estructurados adicionales), timestamp (TIMESTAMPTZ DEFAULT NOW()). Implementar índices: CREATE INDEX idx_system_logs_severity ON system_logs(severity), CREATE INDEX idx_system_logs_timestamp ON system_logs(timestamp), CREATE INDEX idx_system_logs_service ON system_logs(service). Configurar política de retención automática con trigger PostgreSQL que elimine logs >90 días: CREATE OR REPLACE FUNCTION cleanup_old_logs() que ejecute DELETE FROM system_logs WHERE timestamp < NOW() - INTERVAL '90 days', programado con pg_cron extension daily. NO habilitar RLS en esta tabla (acceso solo para service_role y admins). Crear función helper log_system_event(severity, service, message, metadata) para inserción consistente desde Edge Functions. Integrar con existing SupabaseConfig.from('system_logs') para queries desde Flutter app.",
        "testStrategy": "Verificar inserción de logs con diferentes severity levels, probar consultas con índices funcionando correctamente, validar política de retención elimina logs antiguos, confirmar acceso restringido sin RLS habilitado, probar función helper log_system_event con metadata JSONB, verificar performance de queries con índices en timestamp y severity",
        "status": "pending",
        "dependencies": [
          "3"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear migración SQL para tabla system_logs con campos y ENUMs",
            "description": "Crear migración SQL en Supabase para definir tabla system_logs con todos los campos requeridos incluyendo ENUMs para severity y service",
            "dependencies": [],
            "details": "Crear archivo de migración SQL que defina: CREATE TYPE severity_level AS ENUM ('info', 'warning', 'error', 'critical'); CREATE TYPE service_type AS ENUM ('edge_function', 'database', 'auth'); CREATE TABLE system_logs (log_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), severity severity_level NOT NULL, service service_type NOT NULL, message TEXT NOT NULL, metadata JSONB, timestamp TIMESTAMPTZ DEFAULT NOW()). Aplicar migración usando herramientas Supabase CLI o interfaz web.",
            "status": "pending",
            "testStrategy": "Verificar que la tabla se crea correctamente ejecutando \\d system_logs en psql, validar que los ENUMs se definen correctamente con \\dT, probar inserción manual de registro con diferentes valores de severity y service",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar índices optimizados y política de retención automática",
            "description": "Crear índices para mejorar performance de consultas y configurar trigger automático para eliminar logs antiguos cada 90 días",
            "dependencies": [
              1
            ],
            "details": "Crear índices: CREATE INDEX idx_system_logs_severity ON system_logs(severity); CREATE INDEX idx_system_logs_timestamp ON system_logs(timestamp); CREATE INDEX idx_system_logs_service ON system_logs(service). Implementar función de limpieza: CREATE OR REPLACE FUNCTION cleanup_old_logs() RETURNS void AS $$ BEGIN DELETE FROM system_logs WHERE timestamp < NOW() - INTERVAL '90 days'; END; $$ LANGUAGE plpgsql. Configurar pg_cron job diario: SELECT cron.schedule('cleanup-logs', '0 2 * * *', 'SELECT cleanup_old_logs();').",
            "status": "pending",
            "testStrategy": "Probar performance de consultas con EXPLAIN ANALYZE antes y después de índices, verificar que función cleanup_old_logs ejecuta correctamente eliminando registros antiguos, confirmar que pg_cron job se programa correctamente consultando cron.job",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear función helper log_system_event y configurar acceso sin RLS",
            "description": "Implementar función helper para inserción consistente de logs y configurar permisos administrativos sin Row Level Security",
            "dependencies": [
              2
            ],
            "details": "Crear función: CREATE OR REPLACE FUNCTION log_system_event(p_severity severity_level, p_service service_type, p_message TEXT, p_metadata JSONB DEFAULT NULL) RETURNS UUID AS $$ DECLARE log_uuid UUID; BEGIN INSERT INTO system_logs (severity, service, message, metadata) VALUES (p_severity, p_service, p_message, p_metadata) RETURNING log_id INTO log_uuid; RETURN log_uuid; END; $$ LANGUAGE plpgsql SECURITY DEFINER. Configurar permisos: GRANT USAGE ON SCHEMA public TO service_role; GRANT ALL ON system_logs TO service_role; GRANT EXECUTE ON FUNCTION log_system_event TO service_role. NO habilitar RLS en esta tabla.",
            "status": "pending",
            "testStrategy": "Probar función log_system_event con diferentes combinaciones de parámetros desde Edge Function, verificar que retorna UUID válido, confirmar que service_role puede insertar/consultar sin restricciones RLS, validar que usuarios anónimos no pueden acceder directamente a la tabla",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear tabla 'system_logs' en postgresql/supabase para logs de debugging del sistema."
      },
      {
        "id": 71,
        "title": "Crear datos seed para tabla 'fasting_plans' en Supabase",
        "description": "Implementar script de migración SQL que populate la tabla fasting_plans con los 6 planes predefinidos (12/12, 14/10, 16/8, 18/6, 24h, 48h) más el plan de desintoxicación de 48h carnívoro",
        "details": "Crear migración SQL supabase/migrations/YYYYMMDDHHMMSS_seed_fasting_plans.sql que: 1) Verifique si la tabla fasting_plans existe, si no existe crearla con esquema: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), plan_name TEXT NOT NULL UNIQUE, fasting_hours INT NOT NULL, eating_hours INT NOT NULL, description TEXT, difficulty_level TEXT CHECK (difficulty_level IN ('beginner', 'intermediate', 'advanced')), recommended_for TEXT, is_default BOOLEAN DEFAULT false, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(). 2) Insertar los 7 planes con datos: ('12/12', 12, 12, 'Plan principiante: ayuna 12 horas, come 12 horas. Ideal para alineación del ritmo circadiano.', 'beginner', 'Alineación del ritmo circadiano', true), ('14/10', 14, 10, 'Paso intermedio: ayuna 14 horas, come 10 horas. Suave entrada a la quema de grasa.', 'beginner', 'Quema suave de grasa', false), ('16/8', 16, 8, 'Más popular: ayuna 16 horas, come 8 horas. Equilibrio perfecto entre pérdida de grasa y autofagia.', 'intermediate', 'Pérdida de grasa y autofagia', false), ('18/6', 18, 6, 'Avanzado: ayuna 18 horas, come 6 horas. Cetosis profunda y mayor autofagia.', 'advanced', 'Cetosis profunda', false), ('24h', 24, 0, 'OMAD (Una Comida Al Día): ayuno de 24 horas. Máxima autofagia y regeneración celular.', 'advanced', 'Máxima autofagia', false), ('48h', 48, 0, 'Ayuno extendido: 48 horas solo agua. Reparación celular profunda y renovación.', 'advanced', 'Reparación celular', false), ('Desintoxicación 48h', 48, 0, 'Plan carnívoro de 48h: solo carne, huevos, pescado, sal y agua. Elimina antojos de azúcar antes del ayuno intermitente.', 'beginner', 'Reducción de antojos de azúcar', false). 3) Configurar RLS con política 'Public read access' ON fasting_plans FOR SELECT USING (true). 4) Usar ON CONFLICT (plan_name) DO UPDATE para evitar duplicados en múltiples ejecuciones. 5) Agregar trigger para updated_at automático.\n<info added on 2025-10-27T12:41:55.863Z>\nACTUALIZACIÓN COMPLETADA (27 de octubre de 2025)\n\nLa migración SQL ha sido implementada y aplicada exitosamente con todas las funcionalidades requeridas:\n\nARCHIVO CREADO: supabase/migrations/20251027122709_seed_fasting_plans.sql\n\nIMPLEMENTACIÓN VERIFICADA:\n- Tabla fasting_plans creada con esquema completo incluyendo UUID, columnas requeridas, constraints CHECK y índices de rendimiento\n- 7 planes de ayuno insertados con descripciones en español y datos correctos\n- Configuración RLS habilitada con políticas de acceso público para lectura y gestión por service_role\n- Trigger automático para updated_at funcionando correctamente\n- Manejo ON CONFLICT implementado para prevenir duplicados en re-ejecuciones\n- Comentarios documentativos agregados para mantenibilidad\n\nPLANES CONFIRMADOS EN BASE DE DATOS:\n1. 12/12 (Principiante, Plan por defecto) - Alineación circadiana\n2. 14/10 (Principiante) - Quema suave de grasa  \n3. 16/8 (Intermedio) - Pérdida de grasa y autofagia\n4. 18/6 (Avanzado) - Cetosis profunda\n5. 24h OMAD (Avanzado) - Máxima autofagia\n6. 48h Extendido (Avanzado) - Reparación celular\n7. Desintoxicación 48h Carnívoro (Principiante) - Reducción antojos azúcar\n\nPRUEBAS SUPERADAS:\n- Migración aplicada sin errores usando Supabase MCP\n- 7 registros insertados correctamente verificados\n- Solo plan 12/12 marcado como is_default=true\n- RLS y políticas activas confirmadas en pg_policies\n- Trigger updated_at probado y funcional\n- Prevención de duplicados confirmada\n\nBase de datos productiva (rwsoddkrhdzdbthzszby.supabase.co) actualizada correctamente.\n</info added on 2025-10-27T12:41:55.863Z>",
        "testStrategy": "Verificar que la migración se ejecute sin errores en Supabase Dashboard. Comprobar que los 7 planes se insertaron correctamente con SELECT * FROM fasting_plans ORDER BY difficulty_level, fasting_hours. Validar que RLS está habilitado y permite lectura pública. Probar que el plan '12/12' tiene is_default = true. Verificar que múltiples ejecuciones de la migración no crean duplicados. Confirmar que trigger de updated_at funciona al hacer UPDATE manual de un registro.",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear archivo de migración SQL con esquema de tabla fasting_plans",
            "description": "Generar archivo de migración SQL en supabase/migrations/ que defina la estructura completa de la tabla fasting_plans con todas las columnas necesarias",
            "dependencies": [],
            "details": "Crear archivo YYYYMMDDHHMMSS_seed_fasting_plans.sql que incluya: verificación de existencia de tabla, definición de esquema con id UUID PRIMARY KEY, plan_name TEXT UNIQUE, fasting_hours INT, eating_hours INT, description TEXT, difficulty_level con CHECK constraint, recommended_for TEXT, is_default BOOLEAN, timestamps created_at y updated_at con valores por defecto",
            "status": "done",
            "testStrategy": "Verificar que la migración se ejecute sin errores sintácticos en Supabase Dashboard y que la tabla se cree con todas las columnas correctas",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Insertar datos seed de los 7 planes de ayuno intermitente",
            "description": "Implementar las sentencias INSERT para poblar la tabla con los planes predefinidos incluyendo manejo de duplicados",
            "dependencies": [
              1
            ],
            "details": "Agregar 7 sentencias INSERT con ON CONFLICT (plan_name) DO UPDATE para los planes: 12/12 (beginner, default), 14/10 (beginner), 16/8 (intermediate), 18/6 (advanced), 24h OMAD (advanced), 48h ayuno extendido (advanced), y Desintoxicación 48h carnívoro (beginner). Incluir descripciones completas en español y configurar correctamente difficulty_level y recommended_for",
            "status": "done",
            "testStrategy": "Ejecutar SELECT * FROM fasting_plans ORDER BY difficulty_level, fasting_hours para verificar que los 7 planes se insertaron correctamente con todos los datos",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configurar RLS y trigger de updated_at para la tabla",
            "description": "Implementar políticas de Row Level Security y trigger automático para mantener el campo updated_at actualizado",
            "dependencies": [
              1
            ],
            "details": "Habilitar RLS en la tabla fasting_plans, crear política 'Public read access' que permita SELECT a todos los usuarios usando (true). Crear función trigger update_updated_at_column() y asociarla a la tabla para actualizar automáticamente updated_at en cada UPDATE. Esto garantiza acceso público de lectura y mantenimiento automático de timestamps",
            "status": "done",
            "testStrategy": "Verificar que RLS está habilitado y permite lectura pública sin autenticación, probar que el trigger updated_at funciona correctamente al hacer UPDATE en cualquier registro",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear datos seed para tabla 'fasting_plans' en supabase."
      },
      {
        "id": 72,
        "title": "Implementar función PostgreSQL 'validate_fasting_duration' en Supabase para prevenir ayunos peligrosos",
        "description": "Desarrollar función PostgreSQL robusta que valide duraciones de ayuno seguras, requiera confirmación explícita para ayunos >48h, analice historial de riesgo y bloquee usuarios con condiciones médicas registradas",
        "details": "Crear archivo supabase/migrations/20250125000000_enhanced_fasting_validation.sql implementando función validate_fasting_duration() mejorada según Backend Structure Document líneas 656-707. La función debe: 1) Extender validación existente agregando parámetro opcional 'explicit_confirmation' para ayunos >48h que retorne FALSE si no se proporciona confirmación explícita, 2) Implementar análisis de historial agregando consulta a fasting_sessions para detectar patrones de riesgo como >3 interrupciones por panic_button en últimos 7 días o >5 ayunos interrumpidos en último mes, 3) Agregar tabla medical_conditions con campos: user_id UUID, condition_type TEXT (diabetes, eating_disorder, pregnancy, underweight), severity TEXT (mild, moderate, severe), created_at TIMESTAMP, 4) Implementar bloqueo automático consultando medical_conditions donde severity='severe' retorna FALSE inmediatamente, 5) Agregar logging de intentos bloqueados en tabla fasting_validation_logs para auditoría médica, 6) Mantener compatibilidad con función actual mientras extiende funcionalidad, 7) Implementar rate limiting para prevenir bypass via múltiples intentos. Función debe retornar BOOLEAN con casos: TRUE para ayunos seguros, FALSE para rechazados, y trigger exception con mensaje específico para cada tipo de bloqueo.",
        "testStrategy": "Crear suite completa de tests en supabase/tests/validate_fasting_duration_test.sql probando: casos base de función original (ayunos 12-24h normales), límite 48h sin confirmación explícita debe fallar, ayunos >48h con explicit_confirmation=true debe pasar, detección patrones riesgo con datos mock de sesiones interrumpidas, bloqueo por condiciones médicas severity='severe', logging correcto en fasting_validation_logs, rate limiting tras múltiples intentos fallidos. Probar edge cases: usuarios sin historial, perfiles incompletos, condiciones médicas múltiples, timezone handling para cálculos de tiempo. Verificar performance con datasets grandes (>1000 sesiones por usuario). Implementar integration tests desde Edge Functions simulando validaciones reales durante creación de ayunos. Validar trigger validate_fasting_session_safety funciona con nueva función extendida.",
        "status": "pending",
        "dependencies": [
          "15",
          "11"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear migración y estructura de tablas de soporte para validación de ayuno",
            "description": "Implementar archivo de migración con tabla medical_conditions, fasting_validation_logs y extender función validate_fasting_duration existente",
            "dependencies": [],
            "details": "Crear archivo supabase/migrations/20250125000000_enhanced_fasting_validation.sql que incluya: 1) Tabla medical_conditions con campos user_id UUID, condition_type TEXT (diabetes, eating_disorder, pregnancy, underweight), severity TEXT (mild, moderate, severe), created_at TIMESTAMP, 2) Tabla fasting_validation_logs para auditoría médica con campos user_id, attempted_duration, blocked_reason, created_at, 3) Extender función validate_fasting_duration existente agregando parámetro opcional explicit_confirmation BOOLEAN DEFAULT FALSE",
            "status": "pending",
            "testStrategy": "Crear tests SQL para verificar creación correcta de tablas, constraints, índices y tipos de datos. Probar inserción de datos de ejemplo en medical_conditions y validation_logs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar lógica de validación avanzada en función validate_fasting_duration",
            "description": "Desarrollar algoritmo de validación que analice historial de riesgo, condiciones médicas y requiera confirmación explícita para ayunos >48h",
            "dependencies": [
              1
            ],
            "details": "Modificar función validate_fasting_duration para incluir: 1) Validación de confirmación explícita para ayunos >48h retornando FALSE si explicit_confirmation no se proporciona, 2) Análisis de historial consultando fasting_sessions para detectar >3 interrupciones por panic_button en últimos 7 días o >5 ayunos interrumpidos en último mes, 3) Bloqueo automático para usuarios con severity='severe' en medical_conditions, 4) Rate limiting para prevenir bypass via múltiples intentos, 5) Logging de intentos bloqueados en fasting_validation_logs",
            "status": "pending",
            "testStrategy": "Crear suite completa de tests unitarios probando cada caso: ayunos normales 12-24h, límite 48h sin confirmación, ayunos >48h con confirmación, detección patrones riesgo, bloqueo por condiciones médicas severas.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar manejo de errores y compatibilidad con función existente",
            "description": "Asegurar compatibilidad backward con función actual, implementar manejo robusto de errores y mensajes específicos para cada tipo de bloqueo",
            "dependencies": [
              2
            ],
            "details": "Finalizar implementación de validate_fasting_duration asegurando: 1) Mantener compatibilidad con llamadas existentes sin parámetro explicit_confirmation, 2) Implementar manejo de errores con RAISE EXCEPTION para cada tipo de bloqueo con mensajes específicos (condición médica, historial riesgo, falta confirmación), 3) Optimizar consultas para performance usando índices apropiados, 4) Documentar función con comentarios SQL explicando parámetros y casos de uso, 5) Crear función helper get_user_risk_score() para centralizar cálculo de riesgo",
            "status": "pending",
            "testStrategy": "Probar compatibilidad con código existente, verificar mensajes de error específicos para cada caso de bloqueo, probar performance con datos de gran volumen, validar que índices mejoran tiempo de consulta.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar función postgresql 'validate_fasting_duration' en supabase para prevenir ayunos peligrosos."
      },
      {
        "id": 73,
        "title": "Implementar trigger PostgreSQL 'validate_fasting_limits' en Supabase sobre tabla fasting_sessions",
        "description": "Crear trigger automático que ejecute validación de duración de ayuno en INSERT/UPDATE de fasting_sessions, registre advertencias en system_logs y opcionalmente bloquee sesiones inseguras",
        "details": "Crear archivo supabase/migrations/20250125000001_validate_fasting_limits_trigger.sql implementando: 1) Trigger BEFORE INSERT OR UPDATE en tabla fasting_sessions que llame automáticamente a función validate_fasting_duration(), 2) Agregar parámetro 'block_unsafe_sessions' (boolean) que determine si rechazar INSERT/UPDATE cuando validación falla o solo registrar warning, 3) Implementar función trigger validate_fasting_limits_trigger() que: extraiga planned_duration de NEW record, llame validate_fasting_duration(NEW.user_id, NEW.planned_duration, NEW.explicit_confirmation), registre resultado en system_logs con nivel WARNING/ERROR según corresponda, retorne NEW si block_unsafe_sessions=false o NULL si debe bloquear, 4) Manejar excepciones con EXCEPTION clause capturando errores de validación y registrándolos en system_logs antes de permitir/rechazar operación, 5) Agregar logging detallado incluyendo user_id, planned_duration, validation_result, timestamp en cada ejecución, 6) Configurar trigger para activarse en todas las operaciones de fasting_sessions manteniendo performance óptima",
        "testStrategy": "Crear suite de tests en supabase/tests/validate_fasting_limits_trigger_test.sql probando: INSERT sesión 16h debe pasar sin warnings, INSERT sesión 72h sin explicit_confirmation debe registrar warning/bloquear según configuración, UPDATE aumentando duración de 24h a 60h debe disparar validación, verificar entries correctas en system_logs con niveles apropiados, probar manejo de excepciones con datos inválidos o función validate_fasting_duration unavailable, validar performance del trigger con INSERT/UPDATE batch de 100+ registros, confirmar trigger no interfiere con operaciones normales de la aplicación",
        "status": "pending",
        "dependencies": [
          "72"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear función trigger validate_fasting_limits_trigger() en PostgreSQL",
            "description": "Implementar función trigger principal que validará las sesiones de ayuno automáticamente",
            "dependencies": [],
            "details": "Desarrollar función validate_fasting_limits_trigger() que extraiga planned_duration del NEW record, llame a validate_fasting_duration(NEW.user_id, NEW.planned_duration, NEW.explicit_confirmation), maneje el parámetro block_unsafe_sessions para determinar si rechazar o permitir operaciones inseguras, registre resultados en system_logs con niveles WARNING/ERROR apropiados, y retorne NEW o NULL según configuración de bloqueo",
            "status": "pending",
            "testStrategy": "Probar función con diferentes valores de planned_duration, verificar comportamiento con block_unsafe_sessions true/false, validar registro correcto en system_logs",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configurar trigger BEFORE INSERT OR UPDATE en tabla fasting_sessions",
            "description": "Crear trigger automático que ejecute la función de validación en operaciones de la tabla fasting_sessions",
            "dependencies": [
              1
            ],
            "details": "Implementar trigger BEFORE INSERT OR UPDATE en tabla fasting_sessions que llame automáticamente a validate_fasting_limits_trigger(). Configurar para activarse en todas las operaciones manteniendo performance óptima. Incluir manejo de excepciones con EXCEPTION clause para capturar errores de validación y registrarlos en system_logs antes de permitir/rechazar la operación",
            "status": "pending",
            "testStrategy": "Verificar trigger se ejecuta en INSERT/UPDATE, probar manejo de excepciones, validar performance con múltiples operaciones concurrentes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear archivo de migración con logging detallado y tests",
            "description": "Generar migración Supabase completa con sistema de logging y suite de tests",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear archivo supabase/migrations/20250125000001_validate_fasting_limits_trigger.sql con toda la implementación. Agregar logging detallado incluyendo user_id, planned_duration, validation_result, timestamp en cada ejecución. Incluir comentarios SQL explicativos y configuración del parámetro block_unsafe_sessions. Crear tests en supabase/tests/ para validar funcionamiento completo del trigger",
            "status": "pending",
            "testStrategy": "Ejecutar migración en entorno de desarrollo, probar INSERT sesión 16h sin warnings, INSERT sesión 72h con warnings/bloqueo, UPDATE aumentando duración activando validación",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar trigger postgresql 'validate_fasting_limits' en supabase sobre tabla fasting_sessions."
      },
      {
        "id": 74,
        "title": "Implementar modales de confirmación en Flutter para acciones críticas",
        "description": "Crear sistema de modales de confirmación para acciones críticas del ayuno usando ZendfastDialog con animaciones, botones diferenciados y feedback háptico.",
        "details": "Crear lib/widgets/dialogs/zendfast_dialog.dart implementando widget ZendfastDialog que extienda AlertDialog con Material 3 design system siguiendo tema existente en theme.dart. Incluir propiedades: title (Widget), content (Widget), confirmButtonText (String), cancelButtonText (String), onConfirm (VoidCallback), onCancel (VoidCallback), confirmButtonColor (Color), showCloseButton (bool). Implementar animaciones de entrada/salida usando AnimatedScale y AnimatedOpacity con duration 300ms y curve Curves.easeInOut. Crear tipos específicos: StartFastingDialog, ChangePlanDialog, BreakFastingDialog, DeleteHistoryDialog con copy diferenciado y colores semánticos (error para acciones destructivas, primary para acciones normales). Agregar HapticFeedback.lightImpact() en onConfirm y HapticFeedback.selectionClick() en onCancel. Implementar método estático ZendfastDialog.show() para mostrar modales con barrier dismissible configurables. Botones deben usar FilledButton para confirmación (elevated visualmente) y TextButton para cancelación, con spacing ZendfastSpacing.m entre ellos. Usar colorScheme del contexto para consistencia visual.",
        "testStrategy": "Crear tests unitarios para ZendfastDialog verificando renderizado correcto de props y callbacks. Crear widget tests para cada tipo específico verificando textos y colores correctos. Probar animaciones usando WidgetTester.pumpAndSettle() para completar transiciones. Verificar feedback háptico se activa correctamente con mock de HapticFeedback. Probar interaction tests con tap en botones confirmación/cancelación y verificar callbacks ejecutados. Validar barrier dismissible funciona según configuración. Probar responsividad en diferentes tamaños de pantalla y orientaciones.",
        "status": "pending",
        "dependencies": [
          "11",
          "15"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear widget base ZendfastDialog con propiedades y animaciones",
            "description": "Implementar el widget ZendfastDialog base que extienda AlertDialog con todas las propiedades requeridas y animaciones de entrada/salida",
            "dependencies": [],
            "details": "Crear archivo lib/widgets/dialogs/zendfast_dialog.dart implementando ZendfastDialog que extienda AlertDialog. Incluir propiedades: title (Widget), content (Widget), confirmButtonText (String), cancelButtonText (String), onConfirm (VoidCallback), onCancel (VoidCallback), confirmButtonColor (Color), showCloseButton (bool). Implementar animaciones usando AnimatedScale y AnimatedOpacity con duration 300ms y curve Curves.easeInOut. Crear método estático ZendfastDialog.show() para mostrar modales con barrier dismissible configurables. Usar Material 3 design system siguiendo tema en theme.dart.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios verificando renderizado correcto de propiedades, callbacks onConfirm/onCancel funcionan, animaciones se ejecutan con timing correcto usando WidgetTester.pumpAndSettle()",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar botones diferenciados con feedback háptico",
            "description": "Configurar botones FilledButton para confirmación y TextButton para cancelación con colores semánticos y feedback háptico",
            "dependencies": [
              1
            ],
            "details": "Implementar botones usando FilledButton para confirmación (elevated visualmente) y TextButton para cancelación. Aplicar spacing ZendfastSpacing.m entre botones. Usar colorScheme del contexto para consistencia visual. Agregar HapticFeedback.lightImpact() en onConfirm y HapticFeedback.selectionClick() en onCancel. Configurar colores semánticos: error para acciones destructivas, primary para acciones normales según confirmButtonColor prop.",
            "status": "pending",
            "testStrategy": "Verificar tipos de botones correctos se renderizan, probar feedback háptico se ejecuta en cada acción, validar colores semánticos aplicados según tipo de acción",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Crear tipos específicos de diálogos para acciones críticas",
            "description": "Implementar diálogos especializados para cada acción crítica del ayuno con copy y colores diferenciados",
            "dependencies": [
              1,
              2
            ],
            "details": "Crear tipos específicos: StartFastingDialog, ChangePlanDialog, BreakFastingDialog, DeleteHistoryDialog. Cada tipo debe tener copy diferenciado apropiado para la acción y colores semánticos correctos. StartFastingDialog y ChangePlanDialog usan color primary, BreakFastingDialog y DeleteHistoryDialog usan color error para indicar acciones destructivas. Implementar factory constructors para cada tipo que preconfiguran textos y colores apropiados.",
            "status": "pending",
            "testStrategy": "Crear widget tests para cada tipo específico verificando textos correctos se muestran, colores semánticos aplicados apropiadamente, comportamiento específico de cada diálogo funciona según diseño",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar modales de confirmación en flutter para acciones críticas."
      },
      {
        "id": 75,
        "title": "Implementar encuesta rápida post-interrupción de ayuno en Flutter",
        "description": "Crear modal de encuesta que aparece cuando usuario selecciona 'Rompí el ayuno' o 'No aguanto' con 4-5 opciones predefinidas y campo de texto opcional para registrar en analytics.",
        "details": "Crear archivo lib/widgets/dialogs/fasting_interruption_survey_dialog.dart que implemente SurveyDialog extendiendo ZendfastDialog (de task 74). El modal debe: 1) Incluir título 'Cuéntanos qué pasó' y descripción explicativa, 2) Implementar ListView con RadioListTile para opciones: 'Hambre extrema', 'Evento social', 'Malestar físico', 'Ansiedad/estrés', 'Otro motivo', 3) Agregar TextField opcional con hint 'Detalles adicionales (opcional)' que aparece cuando se selecciona cualquier opción, 4) Botones 'Omitir' (TextButton) y 'Enviar' (FilledButton con colores de theme.dart), 5) Implementar animaciones de entrada con AnimatedScale duration 300ms. Crear InterruptionSurveyData model con campos: reason (String), details (String?), timestamp (DateTime). Integrar con analytics creando método logFastingInterruption() en analytics service que registre evento 'fast_interrupted' en analytics_events table (referencia task 52) con campos: user_id, reason, details, timestamp. Usar colors.dart para consistencia visual (tertiary: panicOrange para botón enviar). Mostrar modal automáticamente cuando FastingSession.endSession() se llama con wasInterrupted=true desde botón pánico (task 11).",
        "testStrategy": "Crear tests unitarios para SurveyDialog verificando renderizado de opciones y validación de datos. Crear widget tests usando WidgetTester para interacciones: selección de radio buttons, entrada de texto opcional, callbacks de botones. Probar integración con analytics service usando mocks para verificar eventos se logean correctamente con estructura esperada. Validar modal aparece automáticamente al interrumpir ayuno desde diferentes flujos (botón pánico, acción manual). Probar animaciones usando pumpAndSettle() para completar transiciones.",
        "status": "pending",
        "dependencies": [
          "11",
          "52",
          "74"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear componente SurveyDialog y modelo de datos",
            "description": "Implementar el widget principal FastingInterruptionSurveyDialog que extienda ZendfastDialog y crear el modelo InterruptionSurveyData para estructurar los datos de la encuesta",
            "dependencies": [
              74
            ],
            "details": "Crear archivo lib/widgets/dialogs/fasting_interruption_survey_dialog.dart implementando SurveyDialog que extienda ZendfastDialog. Incluir título 'Cuéntanos qué pasó' y descripción explicativa. Crear modelo InterruptionSurveyData en lib/models/ con campos: reason (String), details (String?), timestamp (DateTime). Implementar constructor y métodos toJson/fromJson para serialización.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para el modelo InterruptionSurveyData verificando serialización correcta. Crear widget tests para el componente SurveyDialog validando renderizado del título y descripción.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar interfaz de usuario con opciones y campo de texto",
            "description": "Desarrollar la UI del modal con RadioListTile para las opciones predefinidas, TextField opcional para detalles adicionales y botones de acción con animaciones",
            "dependencies": [
              1
            ],
            "details": "Implementar ListView con RadioListTile para opciones: 'Hambre extrema', 'Evento social', 'Malestar físico', 'Ansiedad/estrés', 'Otro motivo'. Agregar TextField opcional con hint 'Detalles adicionales (opcional)' que aparece cuando se selecciona cualquier opción. Incluir botones 'Omitir' (TextButton) y 'Enviar' (FilledButton) usando colores de theme.dart (tertiary: panicOrange). Implementar animaciones de entrada con AnimatedScale duration 300ms.",
            "status": "pending",
            "testStrategy": "Probar interacciones con WidgetTester: selección de radio buttons, aparición del TextField al seleccionar opción, validación de callbacks de botones. Verificar animaciones funcionan correctamente.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar con analytics y sistema de ayuno",
            "description": "Conectar el modal con el servicio de analytics para registrar interrupciones y configurar la activación automática desde FastingSession",
            "dependencies": [
              2,
              52,
              11
            ],
            "details": "Crear método logFastingInterruption() en analytics service que registre evento 'fast_interrupted' en analytics_events table con campos: user_id, reason, details, timestamp. Modificar FastingSession.endSession() para mostrar modal automáticamente cuando se llama con wasInterrupted=true desde botón pánico. Configurar integración completa entre todos los componentes del sistema.",
            "status": "pending",
            "testStrategy": "Crear tests de integración usando mocks para analytics service verificando que los datos se registran correctamente. Probar activación automática del modal desde el botón pánico validando el flujo completo.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar encuesta rápida post-interrupción de ayuno en flutter."
      },
      {
        "id": 76,
        "title": "Implementar sistema de micro-interacciones en Flutter usando Lottie y animaciones nativas",
        "description": "Crear sistema completo de micro-interacciones para mejorar la UX incluyendo efectos ripple, animaciones de confetti, pulso en botón pánico, transiciones suaves y feedback háptico al registrar hidratación.",
        "details": "Crear archivo lib/widgets/animations/micro_interactions.dart implementando: 1) RippleEffect widget para botones usando Material InkWell con customSplashFactory y ColorScheme.primary, 2) ConfettiAnimation widget usando package:confetti o Lottie para celebración al completar ayuno, integrado con FastingSession completion events, 3) PulseButton widget para botón pánico con AnimationController y ScaleTransition (scale 1.0 to 1.05, duration 1000ms, repeat infinitely), 4) SmoothPageTransition para go_router usando CustomTransitionPage con SlideTransition y easeInOut curve (250ms duration), 5) HydrationFeedback usando HapticFeedback.lightImpact() + subtle scale animation al registrar hidratación. Crear archivo lib/widgets/animations/animation_constants.dart con duraciones estándar: quickFeedback(150ms), standardTransition(250ms), slowTransition(350ms), curves: easeInOut, bounceIn. Integrar con theme.dart existente para colores consistentes. Implementar AnimationMixin para cleanup automático de AnimationControllers. Seguir guidelines no intrusivas del Tech Stack Document líneas 194-200.",
        "testStrategy": "Crear tests unitarios para cada widget de animación verificando configuración de AnimationController y cleanup. Crear widget tests para RippleEffect probando splash color y comportamiento táctil. Probar ConfettiAnimation con mock de FastingSession completion usando WidgetTester.pumpAndSettle(). Verificar PulseButton animation loop usando WidgetTester.pump() con incrementos de tiempo. Probar transiciones de navegación con Router y MockGoRouter. Verificar HapticFeedback.lightImpact() se llama correctamente usando platform channel mocks. Probar performance con Flutter Inspector para verificar frame rate >60fps.",
        "status": "pending",
        "dependencies": [
          "11",
          "15"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear archivo de constantes y mixins para animaciones",
            "description": "Implementar archivo lib/widgets/animations/animation_constants.dart con duraciones estándar y curvas de animación, y crear AnimationMixin para cleanup automático",
            "dependencies": [],
            "details": "Crear animation_constants.dart definiendo duraciones: quickFeedback(150ms), standardTransition(250ms), slowTransition(350ms). Definir curvas: easeInOut, bounceIn. Implementar AnimationMixin con métodos para cleanup automático de AnimationControllers en dispose(). Integrar con theme.dart existente para colores consistentes usando ColorScheme.primary.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios verificando valores correctos de constantes de duración y curvas. Probar AnimationMixin con mock AnimationController verificando cleanup automático en dispose().",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar widgets de micro-interacciones básicas",
            "description": "Desarrollar RippleEffect, PulseButton y HydrationFeedback widgets con animaciones nativas y feedback háptico",
            "dependencies": [
              1
            ],
            "details": "Crear micro_interactions.dart implementando: RippleEffect widget usando Material InkWell con customSplashFactory y ColorScheme.primary. PulseButton widget con AnimationController y ScaleTransition (scale 1.0 a 1.05, duración 1000ms, repetir infinitamente). HydrationFeedback usando HapticFeedback.lightImpact() con sutil animación de escala al registrar hidratación. Usar AnimationMixin para cleanup automático.",
            "status": "pending",
            "testStrategy": "Crear widget tests para RippleEffect probando splash color y comportamiento táctil. Probar PulseButton verificando animación continua y cleanup. Validar HydrationFeedback con mock de registro de hidratación.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar ConfettiAnimation y transiciones de página",
            "description": "Desarrollar widget de celebración con confetti usando Lottie y transiciones suaves para navegación con go_router",
            "dependencies": [
              1
            ],
            "details": "Implementar ConfettiAnimation widget usando package:confetti o Lottie para celebración al completar ayuno, integrado con FastingSession completion events. Crear SmoothPageTransition para go_router usando CustomTransitionPage con SlideTransition y easeInOut curve (250ms duración). Seguir guidelines no intrusivas del Tech Stack Document líneas 194-200.",
            "status": "pending",
            "testStrategy": "Probar ConfettiAnimation con mock de FastingSession completion usando WidgetTester.pumpAndSettle(). Validar SmoothPageTransition en go_router con diferentes rutas. Verificar performance y que animaciones no sean intrusivas.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar sistema de micro-interacciones en flutter usando lottie y animaciones nativas."
      },
      {
        "id": 77,
        "title": "Implementar detección y ajuste automático de zona horaria en Flutter",
        "description": "Desarrollar sistema que detecte cambios de zona horaria del dispositivo usando plugin timezone, ajuste automáticamente timers de ayuno activos, notifique al usuario sobre los ajustes realizados y registre eventos en analytics.",
        "details": "Crear archivo lib/services/timezone_service.dart implementando TimeZoneService con flutter_timezone plugin para detectar cambios de zona horaria del dispositivo. Implementar TimezoneChangeListener que use zone_detector para monitorear cambios automáticos y manuales. Al detectar cambio: 1) Pausar timers activos usando FastingTimerService, 2) Calcular diferencia horaria y ajustar start_time y end_time de sesiones activas en Isar database, 3) Reiniciar timers con nuevos timestamps, 4) Mostrar notification usando local_notifications explicando el ajuste realizado con detalles de zona anterior/nueva. Manejar edge cases: viajes internacionales con múltiples cambios rápidos (throttling de 5 minutos), cambios de horario de verano automáticos, sincronización con Supabase respetando UTC timestamps. Integrar con analytics service (task 52) registrando eventos timezone_change_detected y timezone_adjustment_completed con metadata de zonas y duración de ajuste. Implementar configuración en user preferences para habilitar/deshabilitar ajustes automáticos.",
        "testStrategy": "Crear tests unitarios para TimeZoneService usando timezone mocks simulando cambios GMT-5 a GMT+2. Probar TimezoneChangeListener con diferentes scenarios: cambio manual de zona, viaje internacional, horario de verano. Crear widget tests para notification display verificando textos informativos correctos. Probar integration end-to-end con ayuno activo de 16h simulando cambio de zona a mitad del ayuno y verificando que timer se ajusta correctamente sin perder progreso. Validar que eventos analytics se registran con metadata apropiada usando analytics service mocks.",
        "status": "pending",
        "dependencies": [
          "11",
          "52"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear TimeZoneService con flutter_timezone plugin",
            "description": "Implementar el servicio principal para detectar cambios de zona horaria del dispositivo",
            "dependencies": [],
            "details": "Crear archivo lib/services/timezone_service.dart implementando TimeZoneService que utilice el plugin flutter_timezone para detectar la zona horaria actual del dispositivo. Incluir métodos getCurrentTimeZone(), detectTimeZoneChange() y registerTimeZoneListener(). Configurar el plugin en pubspec.yaml y manejar permisos necesarios para Android/iOS.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios usando mocks del plugin flutter_timezone simulando diferentes zonas horarias GMT-5, GMT+2, etc.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar TimezoneChangeListener para ajuste automático de timers",
            "description": "Desarrollar el listener que monitorea cambios de zona horaria y ajusta automáticamente los timers de ayuno activos",
            "dependencies": [
              1
            ],
            "details": "Implementar TimezoneChangeListener que use zone_detector para monitorear cambios automáticos y manuales. Al detectar cambio: 1) Pausar timers activos usando FastingTimerService, 2) Calcular diferencia horaria y ajustar start_time y end_time de sesiones activas en Isar database, 3) Reiniciar timers con nuevos timestamps. Incluir throttling de 5 minutos para viajes internacionales con múltiples cambios rápidos.",
            "status": "pending",
            "testStrategy": "Probar scenarios de cambio manual de zona, viaje internacional, horario de verano. Verificar que los timers se ajusten correctamente sin perder progreso.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrar notificaciones y analytics para cambios de zona horaria",
            "description": "Implementar sistema de notificaciones al usuario y registro de eventos en analytics cuando ocurren cambios de zona horaria",
            "dependencies": [
              2
            ],
            "details": "Mostrar notification usando local_notifications explicando el ajuste realizado con detalles de zona anterior/nueva. Integrar con analytics service registrando eventos timezone_change_detected y timezone_adjustment_completed con metadata de zonas y duración de ajuste. Implementar configuración en user preferences para habilitar/deshabilitar ajustes automáticos. Manejar sincronización con Supabase respetando UTC timestamps.",
            "status": "pending",
            "testStrategy": "Verificar que las notificaciones se muestren correctamente con información precisa de las zonas horarias. Validar que los eventos de analytics se registren con los metadatos correctos.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar detección y ajuste automático de zona horaria en flutter."
      },
      {
        "id": 78,
        "title": "Implementar manejo de conectividad en sección Learning de Flutter",
        "description": "Desarrollar sistema completo de detección de conectividad para la sección Learning usando connectivity_plus, incluyendo empty states apropiados para offline, caché de metadatos y funcionalidad de favoritos offline con sincronización posterior.",
        "details": "Crear archivo lib/services/connectivity_service.dart implementando ConnectivityService usando connectivity_plus para monitorear estado de conexión. Implementar lib/providers/connectivity_provider.dart usando Riverpod para exponer ConnectivityNotifier que mantenga estado de conexión actual y stream de cambios. En lib/screens/learning/, crear LearningScreen con manejo de estados offline: mostrar empty state 'Este contenido requiere conexión' cuando offline usando widget EmptyStateWidget con ícono de red y botón retry. Implementar LearningContentCache en lib/services/ para cachear metadatos de ContentItem (título, descripción, thumbnailUrl, categoría) usando Isar database local. Crear FavoritesManager para marcar favoritos offline almacenándolos en tabla local favorites_cache con flag needsSync para sincronizar posteriormente con Supabase. Agregar ConnectivityBanner widget que muestre estado de conexión en top de pantalla con animación fade y colores apropiados (rojo offline, verde online). Implementar retry logic con exponential backoff cuando conexión se restaure. Integrar con sistema de analytics existente para trackear eventos connectivity_lost y connectivity_restored.",
        "testStrategy": "Crear tests unitarios para ConnectivityService verificando detección correcta de estados de conexión usando mocks de connectivity_plus. Probar ConnectivityNotifier con scenarios de cambio de conectividad. Crear widget tests para LearningScreen verificando renderizado de empty state cuando offline y contenido normal cuando online. Probar LearningContentCache con operaciones CRUD de metadatos y verificar persistencia correcta en Isar. Testear FavoritesManager con scenarios de marcado offline y sincronización posterior. Crear integration tests simulando pérdida/recuperación de conexión y verificando comportamiento correcto de retry button y feedback visual.",
        "status": "pending",
        "dependencies": [
          "11",
          "15",
          "52"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar ConnectivityService y ConnectivityProvider para detección de conexión",
            "description": "Crear el servicio principal de conectividad usando connectivity_plus y el provider con Riverpod para gestionar el estado de conexión en la aplicación",
            "dependencies": [],
            "details": "Crear archivo lib/services/connectivity_service.dart implementando ConnectivityService que use connectivity_plus para monitorear estado de conexión en tiempo real. Implementar métodos checkConnection(), startListening() y stopListening(). Crear lib/providers/connectivity_provider.dart usando Riverpod que exponga ConnectivityNotifier manteniendo estado booleano de conexión actual y Stream de cambios. El provider debe inicializar automáticamente el servicio y mantener estado sincronizado con cambios de red.",
            "status": "pending",
            "testStrategy": "Crear tests unitarios para ConnectivityService usando mocks de connectivity_plus verificando detección correcta de estados online/offline. Probar ConnectivityNotifier con scenarios de cambio de conectividad simulando pérdida y recuperación de conexión.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear sistema de caché de metadatos y gestión de favoritos offline",
            "description": "Implementar LearningContentCache y FavoritesManager para almacenar metadatos de contenido y favoritos cuando no hay conexión",
            "dependencies": [
              1
            ],
            "details": "Implementar LearningContentCache en lib/services/learning_content_cache.dart usando Isar database para cachear metadatos de ContentItem (título, descripción, thumbnailUrl, categoría). Crear FavoritesManager en lib/services/favorites_manager.dart para marcar favoritos offline almacenándolos en tabla local favorites_cache con campo needsSync boolean para sincronización posterior con Supabase. Implementar métodos saveFavorite(), removeFavorite() y syncPendingFavorites() que se ejecute cuando conexión se restaure.",
            "status": "pending",
            "testStrategy": "Probar caché funciona correctamente almacenando y recuperando metadatos. Verificar favoritos se guardan localmente cuando offline y se sincronizan correctamente cuando conexión regresa. Validar integridad de datos en Isar database.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar UI de estados offline y banner de conectividad en LearningScreen",
            "description": "Crear la interfaz de usuario para manejar estados sin conexión incluyendo empty states y banner de conectividad con animaciones",
            "dependencies": [
              1,
              2
            ],
            "details": "Modificar lib/screens/learning/learning_screen.dart para mostrar empty state 'Este contenido requiere conexión' cuando offline usando EmptyStateWidget con ícono de red y botón retry. Crear ConnectivityBanner widget que muestre estado de conexión en top de pantalla con animación fade y colores apropiados (rojo offline, verde online). Implementar retry logic con exponential backoff cuando conexión se restaure. Integrar con sistema de analytics existente para trackear eventos connectivity_lost y connectivity_restored. Agregar transiciones suaves entre estados online/offline.",
            "status": "pending",
            "testStrategy": "Crear widget tests para LearningScreen verificando renderizado correcto de empty state cuando offline y contenido normal cuando online. Probar ConnectivityBanner muestra colores y animaciones correctas. Verificar retry logic funciona con exponential backoff y analytics tracking se ejecuta correctamente.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on implementar manejo de conectividad en sección learning de flutter."
      },
      {
        "id": 79,
        "title": "Crear suite de unit tests para Riverpod providers críticos",
        "description": "Implementar tests unitarios completos para TimerProvider, MetricsProvider, HydrationProvider y FastingSessionProvider usando riverpod_test y mockito para alcanzar mínimo 80% de cobertura.",
        "details": "Crear archivo test/providers/timer_provider_test.dart implementando tests para TimerNotifier usando ProviderContainer.overrideWith() para mockear TimerService. Probar métodos: startTimer(), pauseTimer(), resumeTimer(), cancelTimer(), syncState() y getters: isRunning, progress, remainingMilliseconds, formattedTimes. Crear test/providers/metrics_provider_test.dart para MetricsProvider testeando cálculo de racha consecutiva, estadísticas totales, tasa de completación usando mocks de Isar database queries. Implementar test/providers/hydration_provider_test.dart verificando cálculo de ingesta diaria, progreso hacia meta, recordatorios, logs de hidratación con mocks de HydrationLog e Isar. Crear test/providers/fasting_session_provider_test.dart testeando inicio/fin de sesiones, validaciones de estado, persistencia usando mocks de FastingSession e Isar. Agregar dependencias dev: riverpod_test: ^2.0.0, mockito: ^5.4.4, build_runner para code generation. Usar @GenerateMocks() para TimerService, DatabaseService, Isar interfaces. Configurar tearDown() para ProviderContainer.dispose(). Implementar coverage con flutter test --coverage y genhtml para reportes HTML.",
        "testStrategy": "Ejecutar flutter test test/providers/ verificando todos los tests pasan. Generar reporte de cobertura con flutter test --coverage --test-randomize-ordering-seed random validando ≥80% line coverage en providers/. Probar scenarios edge: network failures, timer completion events, empty data states, concurrent operations. Verificar mocks configurados correctamente usando verify() calls. Validar tearDown limpia state entre tests con ProviderContainer fresh instances.",
        "status": "pending",
        "dependencies": [
          "4",
          "22"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar entorno de testing y dependencias para Riverpod providers",
            "description": "Instalar y configurar todas las dependencias necesarias para testing de providers incluyendo riverpod_test, mockito, build_runner y configurar estructura base de tests",
            "dependencies": [],
            "details": "Agregar a pubspec.yaml en dev_dependencies: riverpod_test: ^2.0.0, mockito: ^5.4.4, build_runner: ^2.4.6. Crear directorio test/providers/ con estructura organizada. Configurar @GenerateMocks() para TimerService, DatabaseService, Isar interfaces en test/test_helpers/mocks.dart. Ejecutar flutter packages pub run build_runner build para generar mocks. Crear test_helpers/provider_test_utils.dart con utilities comunes como createTestContainer() y tearDown helpers para ProviderContainer.dispose().",
            "status": "pending",
            "testStrategy": "Verificar que todas las dependencias se instalen correctamente ejecutando flutter pub get. Validar que los mocks se generen sin errores con build_runner. Probar que createTestContainer() funcione correctamente creando un container básico de prueba.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar tests unitarios para TimerProvider y MetricsProvider",
            "description": "Crear suites completas de tests para TimerNotifier y MetricsProvider cubriendo todos los métodos y estados críticos con mocks apropiados",
            "dependencies": [
              1
            ],
            "details": "Crear test/providers/timer_provider_test.dart implementando tests para TimerNotifier usando ProviderContainer.overrideWith() para mockear TimerService. Probar métodos: startTimer(), pauseTimer(), resumeTimer(), cancelTimer(), syncState() y getters: isRunning, progress, remainingMilliseconds, formattedTimes. Incluir edge cases como timer completion, state transitions. Crear test/providers/metrics_provider_test.dart para MetricsProvider testeando cálculo de racha consecutiva, estadísticas totales, tasa de completación usando mocks de Isar database queries. Probar scenarios de datos vacíos, un solo ayuno, múltiples ayunos exitosos/fallidos.",
            "status": "pending",
            "testStrategy": "Ejecutar flutter test test/providers/timer_provider_test.dart y metrics_provider_test.dart verificando 100% de tests pasan. Validar que todos los métodos públicos están cubiertos. Probar edge cases como datos corruptos, estados inconsistentes, transiciones de timer.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar tests para HydrationProvider y FastingSessionProvider con reporte de cobertura",
            "description": "Completar la suite de tests implementando HydrationProvider y FastingSessionProvider tests, configurar coverage reporting y validar cobertura mínima del 80%",
            "dependencies": [
              2
            ],
            "details": "Implementar test/providers/hydration_provider_test.dart verificando cálculo de ingesta diaria, progreso hacia meta, recordatorios, logs de hidratación con mocks de HydrationLog e Isar. Probar scenarios de múltiples logs diarios, metas diferentes, timezone handling. Crear test/providers/fasting_session_provider_test.dart testeando inicio/fin de sesiones, validaciones de estado, persistencia usando mocks de FastingSession e Isar. Incluir tests para interrupciones, sesiones concurrentes, validaciones de duración. Configurar coverage con flutter test --coverage y genhtml para reportes HTML. Validar ≥80% line coverage.",
            "status": "pending",
            "testStrategy": "Ejecutar flutter test test/providers/ verificando todos los tests pasan. Generar reporte de cobertura con flutter test --coverage --test-randomize-ordering-seed random validando ≥80% line coverage en providers/. Probar scenarios edge: network failures, timer completion events, empty data states, concurrent operations.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear suite de unit tests para riverpod providers críticos."
      },
      {
        "id": 80,
        "title": "Crear suite de widget tests para componentes UI críticos en Flutter",
        "description": "Implementar tests de widgets completos para TimerDisplay, PanicButton, HydrationTracker y ZendfastDialog usando flutter_test y golden tests para verificación visual, alcanzando 70% de cobertura en componentes UI.",
        "details": "Crear directorio test/widgets/ e implementar archivos: test/widgets/timer_display_test.dart verificando renderizado correcto del tiempo formateado (HH:MM:SS), actualización cada segundo usando testWidgets y FakeTimer, progress indicator actualización durante ayuno activo. test/widgets/panic_button_test.dart probando accesibilidad con semantics labels, estados habilitado/deshabilitado según fastingState, animaciones pulse usando AnimationController. test/widgets/hydration_tracker_test.dart verificando visualización de progreso usando LinearProgressIndicator, interacción táctil para logging, color changes (azul->verde al 100%). test/widgets/zendfast_dialog_test.dart testeando renderizado con showDialog, acciones de botones onPressed callbacks, dismissal con Navigator.pop(). Implementar golden tests usando flutter_test goldens comparando screenshots pixelPerfect. Configurar flutter_test_config.dart para golden file updates. Usar ProviderContainer.overrideWith() para mockear providers dependencies. Instalar coverage package y ejecutar flutter test --coverage para generar lcov.info alcanzando mínimo 70% line coverage en lib/widgets/.",
        "testStrategy": "Ejecutar flutter test test/widgets/ verificando todos los widget tests pasan sin errores. Generar reporte de cobertura con flutter test --coverage validando ≥70% coverage en componentes UI. Probar golden tests con flutter test --update-goldens para regenerar reference images. Verificar tests en diferentes screen sizes usando MediaQuery. Probar accessibility con semantics testing y tester.binding.pipelineOwner.flushSemantics(). Validar animations usando WidgetTester.pumpAndSettle() y AnimationController state verification.",
        "status": "pending",
        "dependencies": [
          "11",
          "18",
          "19"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configurar estructura básica de tests y dependencias para widgets",
            "description": "Crear directorio test/widgets/ y configurar archivos base de configuración para testing de widgets, instalando dependencias necesarias como coverage package y configurando flutter_test_config.dart",
            "dependencies": [],
            "details": "Crear directorio test/widgets/ en el proyecto. Instalar coverage package en pubspec.yaml dev_dependencies. Configurar flutter_test_config.dart para manejo de golden files con testExecutable que permita updates. Establecer estructura base con imports comunes para testing de widgets Flutter. Configurar ProviderContainer.overrideWith() base para mockear dependencies en todos los widget tests.",
            "status": "pending",
            "testStrategy": "Verificar que la estructura de directorios se crea correctamente y que flutter test puede ejecutarse sin errores de configuración",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar widget tests para TimerDisplay y PanicButton",
            "description": "Crear tests completos para los componentes TimerDisplay y PanicButton verificando renderizado, estados y interacciones usando testWidgets y FakeTimer",
            "dependencies": [
              1
            ],
            "details": "Implementar test/widgets/timer_display_test.dart verificando renderizado correcto del tiempo formateado (HH:MM:SS), actualización cada segundo usando testWidgets y FakeTimer, progress indicator actualización durante ayuno activo. Crear test/widgets/panic_button_test.dart probando accesibilidad con semantics labels, estados habilitado/deshabilitado según fastingState, animaciones pulse usando AnimationController. Mockear providers necesarios con ProviderContainer.overrideWith().",
            "status": "pending",
            "testStrategy": "Ejecutar testWidgets verificando que todos los estados se renderizan correctamente y las interacciones funcionan como esperado",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar widget tests para HydrationTracker y ZendfastDialog con golden tests",
            "description": "Crear tests para HydrationTracker y ZendfastDialog, implementar golden tests para verificación visual y generar reporte de cobertura alcanzando 70%",
            "dependencies": [
              2
            ],
            "details": "Implementar test/widgets/hydration_tracker_test.dart verificando visualización de progreso usando LinearProgressIndicator, interacción táctil para logging, color changes (azul->verde al 100%). Crear test/widgets/zendfast_dialog_test.dart testeando renderizado con showDialog, acciones de botones onPressed callbacks, dismissal con Navigator.pop(). Implementar golden tests usando flutter_test goldens comparando screenshots pixelPerfect. Ejecutar flutter test --coverage para generar lcov.info alcanzando mínimo 70% line coverage en lib/widgets/.",
            "status": "pending",
            "testStrategy": "Ejecutar flutter test --coverage validando ≥70% coverage en componentes UI. Probar golden tests con flutter test --update-goldens para regenerar reference images",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear suite de widget tests para componentes ui críticos en flutter."
      },
      {
        "id": 81,
        "title": "Crear datos seed iniciales para tabla learning_content con contenido educativo curado",
        "description": "Desarrollar script SQL de migración que inserte 25-30 piezas curadas de contenido educativo sobre ayuno intermitente en la tabla learning_content de Supabase",
        "details": "Crear archivo de migración SQL en supabase/migrations/ que inserte contenido educativo curado en tabla learning_content existente. Incluir 25-30 entradas con: artículos sobre beneficios del ayuno intermitente (8-10 piezas), estudios científicos sobre autofagia y metabolismo (6-8 piezas), videos de YouTube sobre técnicas de ayuno (8-10 piezas), guías sobre hidratación durante ayuno (4-5 piezas). Cada entrada debe contener: content_id (UUID), title (texto descriptivo en español), content_type (article/study/video), category (basics/science/tips/success_stories), content_url (URLs reales y funcionales), description (resumen 100-150 caracteres), difficulty_level (beginner/intermediate/advanced), estimated_read_time (minutos para artículos/estudios, duration_minutes para videos), is_premium (distribuir 70% gratuito, 30% premium). Implementar INSERT statements con datos reales verificados: artículos de sitios confiables como Healthline, estudios de PubMed, videos de canales educativos de YouTube. Incluir validaciones CHECK constraints para content_type y category según esquema existente. Agregar comentarios SQL explicando categorización y fuentes.",
        "testStrategy": "Verificar migración se ejecuta sin errores en Supabase, confirmar que se insertan exactamente 25-30 registros, validar URLs son accesibles y funcionales, probar que políticas RLS permiten lectura pública del contenido, verificar distribución correcta de dificultad y premium/gratuito, confirmar que content_type y category respetan constraints definidos, revisar que estimated_read_time es realista para cada tipo de contenido",
        "status": "pending",
        "dependencies": [
          "3",
          "48"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Investigar y recopilar contenido educativo sobre ayuno intermitente",
            "description": "Buscar y validar 25-30 piezas de contenido educativo de calidad sobre ayuno intermitente desde fuentes confiables",
            "dependencies": [],
            "details": "Investigar y recopilar contenido de fuentes verificadas: 8-10 artículos de Healthline/Mayo Clinic sobre beneficios del ayuno, 6-8 estudios científicos de PubMed sobre autofagia y metabolismo, 8-10 videos educativos de YouTube de canales médicos reconocidos, 4-5 guías sobre hidratación durante ayuno. Verificar que todas las URLs sean accesibles y el contenido sea actual. Categorizar por dificultad (principiante/intermedio/avanzado) y determinar distribución premium/gratuito (70%/30%).",
            "status": "pending",
            "testStrategy": "Verificar que todas las URLs recopiladas sean accesibles, validar que el contenido está actualizado y proviene de fuentes confiables, confirmar distribución correcta por categorías",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Crear script SQL de migración con datos seed",
            "description": "Desarrollar archivo de migración SQL que inserte todo el contenido educativo recopilado en la tabla learning_content",
            "dependencies": [
              1
            ],
            "details": "Crear archivo de migración en supabase/migrations/ con INSERT statements para las 25-30 piezas de contenido. Cada registro debe incluir: content_id (UUID generado), title en español, content_type (article/study/video), category (basics/science/tips), content_url válida, description de 100-150 caracteres, difficulty_level, estimated_read_time/duration_minutes, is_premium. Implementar validaciones CHECK constraints según esquema existente. Agregar comentarios SQL explicando categorización y fuentes de cada entrada.",
            "status": "pending",
            "testStrategy": "Validar sintaxis SQL es correcta, verificar que UUIDs son únicos, confirmar que constraints CHECK se respetan, probar ejecución en entorno de desarrollo",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Ejecutar y validar migración en Supabase",
            "description": "Aplicar la migración SQL en Supabase y verificar que todos los datos se insertaron correctamente",
            "dependencies": [
              2
            ],
            "details": "Ejecutar la migración SQL en Supabase usando el CLI o dashboard. Verificar que se insertan exactamente 25-30 registros sin errores. Probar que todas las URLs son accesibles mediante requests automáticos. Validar que las políticas RLS permiten lectura pública del contenido. Confirmar distribución correcta: 70% contenido gratuito, 30% premium. Verificar que los tipos de contenido y categorías coinciden con las validaciones del esquema.",
            "status": "pending",
            "testStrategy": "Ejecutar query COUNT para confirmar número exacto de registros insertados, probar acceso a URLs mediante script automatizado, verificar políticas RLS con usuarios de prueba, validar distribución premium/gratuito con consultas SQL",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on crear datos seed iniciales para tabla learning_content con contenido educativo curado."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-31T20:44:55.357Z",
      "taskCount": 81,
      "completedCount": 15,
      "tags": [
        "master"
      ],
      "created": "2025-11-01T03:28:51.489Z",
      "description": "Tasks for master context",
      "updated": "2025-11-06T13:41:45.214Z"
    }
  }
}